<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>6. 传感器仿真 &mdash; Docs</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="_static/collapsible-lists/css/tree_view.css?v=a885cde7" />
      <link rel="stylesheet" type="text/css" href="_static/extra.css?v=be618c9b" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=34088549"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="_static/translations.js?v=beaddf03"></script>
        <script src="_static/collapsible-lists/js/CollapsibleLists.compressed.js?v=73120307"></script>
        <script src="_static/collapsible-lists/js/apply-collapsible-lists.js?v=660e4f45"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="7. V2X仿真" href="307.V2X%E4%BB%BF%E7%9C%9F.html" />
    <link rel="prev" title="5. 动力学仿真" href="305.%E5%8A%A8%E5%8A%9B%E5%AD%A6%E4%BB%BF%E7%9C%9F.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            TAD Sim
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <p class="caption" role="heading"><span class="caption-text">🪄概述</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="101.%E5%85%B3%E4%BA%8E%20TAD%20Sim%20%E5%8D%95%E6%9C%BA%E7%89%88.html">1. 关于 TAD Sim 单机版</a></li>
<li class="toctree-l1"><a class="reference internal" href="102.%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D.html">2. 功能介绍</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">🚀快速入门</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="201.%E5%8D%95%E6%9C%BA%E7%89%88%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2.html">1. 单机版安装部署</a></li>
<li class="toctree-l1"><a class="reference internal" href="202.%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%AE%97%E6%B3%95%E6%8E%A5%E5%85%A5.html">2. 如何进行算法接入</a></li>
<li class="toctree-l1"><a class="reference internal" href="203.%E5%AF%BC%E5%85%A5%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E5%88%B0%E5%B9%B3%E5%8F%B0.html">3. 导入第一个算法到平台</a></li>
<li class="toctree-l1"><a class="reference internal" href="204.%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BB%BF%E7%9C%9F%E5%9C%BA%E6%99%AF.html">4. 创建第一个仿真场景</a></li>
<li class="toctree-l1"><a class="reference internal" href="205.%E6%92%AD%E6%94%BE%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%9C%BA%E6%99%AF.html">5. 播放第一个场景</a></li>
<li class="toctree-l1"><a class="reference internal" href="206.%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%9C%B0%E5%9B%BE.html">6. 创建第一个地图</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">💡用户指引</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="301.%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD.html">1. 专业术语</a></li>
<li class="toctree-l1"><a class="reference internal" href="302.%E5%9C%BA%E6%99%AF%E7%BC%96%E8%BE%91%E5%99%A8.html">2. 场景编辑器</a></li>
<li class="toctree-l1"><a class="reference internal" href="303.%E5%9C%BA%E6%99%AF%E6%92%AD%E6%94%BE%E5%99%A8.html">3. 场景播放器</a></li>
<li class="toctree-l1"><a class="reference internal" href="304.%E5%9C%B0%E5%9B%BE%E7%BC%96%E8%BE%91%E5%99%A8.html">4. 地图编辑器</a></li>
<li class="toctree-l1"><a class="reference internal" href="305.%E5%8A%A8%E5%8A%9B%E5%AD%A6%E4%BB%BF%E7%9C%9F.html">5. 动力学仿真</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">6. 传感器仿真</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">6.1 摄像头仿真</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">6.1.1 参数说明</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">6.1.2 数据获取</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id5">6.1.2.1 共享内存</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">6.1.2.2 磁盘保存</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pb">6.1.2.3 PB 消息</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gpu">6.1.2.4 GPU 显存共享</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id7">6.2 激光雷达仿真</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id8">6.2.1 参数说明</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id9">6.2.2 数据获取</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#udp">6.2.2.1 UDP 包</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">6.2.2.2 磁盘保存</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">6.2.2.3 PB 消息</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">6.2.2.4 其他设置</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id13">6.3 毫米波雷达仿真</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id14">6.3.1 参数说明</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id15">6.3.2 数据获取</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id16">6.3.2.1 PB消息</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id17">6.3.2.2 磁盘保存</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id18">6.4 超声波雷达仿真</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id19">6.4.1 参数说明</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id20">6.4.2 数据获取</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id21">6.4.2.1 磁盘保存</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id22">6.4.2.2 PB 消息</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id23">6.4.3 轮询模式</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id24">6.5 真值传感器仿真</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id25">6.5.1 参数说明</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id26">6.5.2 数据获取</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#imu">6.6 IMU 仿真</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id27">6.6.1 参数说明</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id28">6.6.2 数据获取</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id29">6.7 鱼眼相机仿真</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id30">6.7.1 参数说明</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id31">6.7.2 数据获取</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id32">6.7.2.1 内存共享</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id33">6.7.2.2 磁盘保存</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id34">6.7.2.3 PB 消息</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id35">6.8 语义相机仿真</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id36">6.8.1 参数说明</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id37">6.8.2 数据获取</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id38">6.8.2.1 内存共享</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id39">6.8.2.2 磁盘保存</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id40">6.8.2.3 PB 消息</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id41">6.9 深度相机仿真</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id42">6.9.1 参数说明</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id43">6.9.2 数据获取</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id44">6.9.2.1 内存共享</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id45">6.9.2.1 磁盘保存</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id46">6.9.2.3 PB 消息</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#gps">6.10 GPS 仿真</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id47">6.10.1. 参数说明</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id48">6.10.2. 数据获取</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#v2x">6.11 V2X 仿真</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id49">6.12 仿真合成数据生成</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id50">6.13 传感器依赖模块</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#display">6.13.1 Display 模块</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sensortruth">6.13.2 SensorTruth 模块</a></li>
<li class="toctree-l3"><a class="reference internal" href="#radar">6.13.3 Radar 模块</a></li>
<li class="toctree-l3"><a class="reference internal" href="#imu-gps">6.13.4 imu_gps 模块</a></li>
<li class="toctree-l3"><a class="reference internal" href="#synthetic-data">6.13.5 synthetic_data 模块</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="307.V2X%E4%BB%BF%E7%9C%9F.html">7. V2X仿真</a></li>
<li class="toctree-l1"><a class="reference internal" href="308.%E4%BB%BF%E7%9C%9F%E5%90%88%E6%88%90%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90.html">8. 仿真合成数据生成</a></li>
<li class="toctree-l1"><a class="reference internal" href="309.%E5%9C%BA%E6%99%AF%E8%AF%84%E6%B5%8B.html">9. 场景评测</a></li>
<li class="toctree-l1"><a class="reference internal" href="310.%E4%BB%BF%E7%9C%9F%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AE%B0%E5%BD%95%E5%92%8C%E5%9B%9E%E6%94%BE.html">10. 仿真数据的记录和回放</a></li>
<li class="toctree-l1"><a class="reference internal" href="311.%E5%8D%95%E6%9C%BA%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E8%A1%8C%E4%BB%BF%E7%9C%9F.html">11. 单机多进程并行仿真</a></li>
<li class="toctree-l1"><a class="reference internal" href="312.OpenSCENARIO%20%E6%94%AF%E6%8C%81.html">12. OpenSCENARIO 支持</a></li>
<li class="toctree-l1"><a class="reference internal" href="313.OpenDRIVE%20%E6%94%AF%E6%8C%81.html">13. OpenDRIVE 支持</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">📚开发者指引</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="401.%E7%B3%BB%E7%BB%9F%E7%BA%A6%E5%AE%9A.html">1. 系统约定</a></li>
<li class="toctree-l1"><a class="reference internal" href="402.%E7%AE%97%E6%B3%95%E6%8E%A5%E5%85%A5%E8%AF%B4%E6%98%8E.html">2. 算法接入说明 - txSimSDK</a></li>
<li class="toctree-l1"><a class="reference internal" href="403.%E4%BB%BF%E7%9C%9F%E6%B6%88%E6%81%AF%E8%AF%B4%E6%98%8E.html">3. 仿真消息说明</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">🔄版本说明</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="501.%E6%9C%80%E6%96%B0%E8%BF%AD%E4%BB%A3.html">1. 最新迭代</a></li>
<li class="toctree-l1"><a class="reference internal" href="502.%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC.html">2. 历史版本</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">TAD Sim</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">6. 传感器仿真</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1>6. 传感器仿真<a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
<p>TAD Sim 单机版支持多种类型传感器仿真, 包括摄像头仿真、激光雷达仿真及毫米波雷达仿真. 在测试任务中, 主车可搭载多台传感器, 用户可通过 TAD Sim 单机版, 在创建场景时完成传感器配置. 传感器配置支持多维度参数自定义, 包括位置、频率及分辨率等.</p>
<p>点击主车模型右侧的图标, 页面中间弹出详情窗口, 显示三维主车模型预览, 按住鼠标左键可转动模型, 鼠标滚轮可缩放模型.配置主车模型元素的相关参数, 包括传感器模型、控制器模型、动力学模型等. 点击保存, 配置主车模型完成.</p>
<div align="center"><img src="./_static/images/image25.png" alt="" width="700px"></div><br>
<p>支持设备从下方的设备列表中拖拽到主车上, 设备列表显示的传感器名称和下方的传感器列表需要一致. 鼠标选中后拖拽到车上, 自动吸附到松开时的车上相应装配位置, 可通过右侧参数调节调整位置. 列表中选中一个传感器, 左侧视图需要高亮定位, 右侧基本信息需要显示该传感器信息. 在列表选中后可右键删除和 delete 键删除传感器, 支持按住 shift 和 ctrl 多选. 多选后, 右侧信息列表显示为空.</p>
<div align="center"><img src="./_static/images/image26.png" alt="" width="700px"></div><br>
<section id="id2">
<h2>6.1 摄像头仿真<a class="headerlink" href="#id2" title="Link to this heading"></a></h2>
<p>TAD Sim 支持摄像头仿真, 基于真实摄像头模型仿真, 平台提供默认配置参数, 并支持各参数自定义配置功能, 摄像头仿真依赖 Display 模块.</p>
<div align="center"><img src="./_static/images/image51.png" alt="" width="700px"></div><br>
<section id="id3">
<h3>6.1.1 参数说明<a class="headerlink" href="#id3" title="Link to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th>范围</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>位置X(cm)</td>
<td>0</td>
<td>[-1000, 1000]</td>
<td>安装位置, 坐标原点位于四轮中心的地面垂点</td>
</tr>
<tr>
<td>位置Y(cm)</td>
<td>0</td>
<td>[-1000, 1000]</td>
<td>安装位置, 坐标原点位于四轮中心的地面垂点</td>
</tr>
<tr>
<td>位置Z(cm)</td>
<td>171</td>
<td>[0, 1000]</td>
<td>安装位置, 坐标原点位于四轮中心的地面垂点</td>
</tr>
<tr>
<td>旋转X(°)</td>
<td>0</td>
<td>[-180, 180]</td>
<td>安装角度</td>
</tr>
<tr>
<td>旋转Y(°)</td>
<td>0</td>
<td>[-180, 180]</td>
<td>安装角度</td>
</tr>
<tr>
<td>旋转Z(°)</td>
<td>0</td>
<td>[-180, 180]</td>
<td>安装角度</td>
</tr>
<tr>
<td>实例ID</td>
<td>0</td>
<td>-</td>
<td>当配置了多个 display 时, 只有Display的实例ID一致时, 才会被处理</td>
</tr>
<tr>
<td>频率(Hz)</td>
<td>25</td>
<td>[0, 1000]</td>
<td>拍照频率</td>
</tr>
<tr>
<td>色彩模式</td>
<td>彩色</td>
<td>彩色/灰度</td>
<td>-</td>
</tr>
<tr>
<td>水平分辨率</td>
<td>1920</td>
<td>整数</td>
<td>图像尺寸, 像素</td>
</tr>
<tr>
<td>垂直分辨率</td>
<td>1208</td>
<td>整数</td>
<td>图像尺寸, 像素</td>
</tr>
<tr>
<td>细腻度</td>
<td>0</td>
<td>[-5.0, 5.0]</td>
<td>正数细腻, 负数粗糙.细腻会增加渲染负担</td>
</tr>
<tr>
<td>模糊</td>
<td>0</td>
<td>[0, 1]</td>
<td>-</td>
</tr>
<tr>
<td>运动模糊</td>
<td>0</td>
<td>[0, 1]</td>
<td>-</td>
</tr>
<tr>
<td>光晕强度</td>
<td>0</td>
<td>[0, 1]</td>
<td>-</td>
</tr>
<tr>
<td>噪声强度</td>
<td>0</td>
<td>[0.0, 1.0]</td>
<td>-</td>
</tr>
<tr>
<td>暗角</td>
<td>0.4</td>
<td>[0.0, 1.0]</td>
<td></td>
</tr>
<tr>
<td>泛光 bloom</td>
<td>0.675</td>
<td>[0.0, 1.0]</td>
<td></td>
</tr>
<tr>
<td>曝光模式</td>
<td>0</td>
<td>自动0 <br> 手动1(手动时:快门速度, ISO, 孔径参数有效)</td>
<td></td>
</tr>
<tr>
<td>曝光补偿</td>
<td>1</td>
<td>-15.0～15.0</td>
<td>曝光的对数 2^n 调整, 负值变暗, 正值加亮</td>
</tr>
<tr>
<td>快门速度</td>
<td>60</td>
<td>1.0\~200</td>
<td>像素亮度B=曝光 * 场景表面亮度L <br> 曝光=1/ (孔径^2/快门速度*100/ISO)</td>
</tr>
<tr>
<td>ISO</td>
<td>100</td>
<td>1.0\~无穷</td>
<td>1.0\~无穷</td>
</tr>
<tr>
<td>孔径(光阑、光圈)</td>
<td>4</td>
<td>1.0\~32.0</td>
<td>1.0\~32.0</td>
</tr>
<tr>
<td>色温</td>
<td>6500</td>
<td>1500～15000K</td>
<td>色温</td>
</tr>
<tr>
<td>白色调</td>
<td>0</td>
<td>-1.0～1.0</td>
<td></td>
</tr>
<tr>
<td>镜头透镜率</td>
<td>98</td>
<td>1.0～100.0%</td>
<td></td>
</tr>
<tr>
<td>畸变参数</td>
<td>k1=-5.3336804278253547e-001, <br> k2=4.5773462092698042e-001, <br> k3=-4.8360765272003647e-001, <br> p1=-2.3929586859060227e-003, <br> p2=1.8364297357014352e-003</td>
<td>-</td>
<td>分布表示k1,k2,k3,p1,p2</td>
</tr>
<tr>
<td>内参形式</td>
<td>0</td>
<td>0:矩阵, 1:FOV, 2:感光器</td>
<td>-</td>
</tr>
<tr>
<td>内参矩阵</td>
<td>1.9451674168728503e+003, <br> 0, <br> 9.4611889604089231e+002; <br> 0,1.9381372280069070e+003, <br> 6.1970485474739780e+002; <br> 0,0,1</td>
<td>长度为9的数组 <br> 给出默认值的位置readonly <br> 其余位置值依次为fx, skew, cx, fy, cy</td>
<td>当内参形式为矩阵时</td>
</tr>
<tr>
<td>水平FOV(°)</td>
<td>60</td>
<td>[0, 180]</td>
<td>当内参形式为fov时</td>
</tr>
<tr>
<td>垂直FOV(°)</td>
<td>36.28</td>
<td>[0, 180]</td>
<td>当内参形式为fov时</td>
</tr>
<tr>
<td>感光器宽度(mm)</td>
<td>10</td>
<td>(0, 10000]</td>
<td>当内参形式为感光器时</td>
</tr>
<tr>
<td>感光器高度(mm)</td>
<td>10</td>
<td>(0, 10000]</td>
<td>当内参形式为感光器时</td>
</tr>
<tr>
<td>镜头焦距(mm)</td>
<td>10</td>
<td>(0, 10000]</td>
<td>当内参形式为感光器时</td>
</tr>
</tbody>
</table>
</section>
<section id="id4">
<h3>6.1.2 数据获取<a class="headerlink" href="#id4" title="Link to this heading"></a></h3>
<section id="id5">
<h4>6.1.2.1 共享内存<a class="headerlink" href="#id5" title="Link to this heading"></a></h4>
<p>摄像头仿真共享地址为 <code class="docutils literal notranslate"><span class="pre">Tadsim_Camera_{cameraID}</span></code>, 其中 cameraID 从前端传感器配置界面上获取 (如 <code class="docutils literal notranslate"><span class="pre">Tadsim_Camera_1</span></code>).
开关设置方法为, 首先打开 <code class="docutils literal notranslate"><span class="pre">Game.ini</span></code> 文件, 文件路径如下:</p>
<ul class="simple">
<li><p>Windows 下:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">C:\Users\用户名\AppData\Roaming\tadsim\data\service_data\display\Saved\Config\WindowsNoEditor\Game.ini</span></code></p></li>
</ul>
</li>
<li><p>Ubuntu 下:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">/home/用户名/.config/tadsim/Display/Saved/Config/LinuxNoEditor/Game.ini</span></code></p></li>
</ul>
</li>
</ul>
<p>在 Game.ini 中添加如下内容:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[Sensor]</span>
<span class="na">CameraMemShare</span><span class="o">=</span><span class="s">true</span>
</pre></div>
</div>
<p>数据格式为二进制流, 数据定位如下:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>占位长度</th>
<th>数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>int</td>
<td>固定为 123456</td>
</tr>
<tr>
<td>8</td>
<td>int64</td>
<td>时间戳 (逻辑时间)</td>
</tr>
<tr>
<td>4</td>
<td>int</td>
<td>图像大小 = 4 * w * h</td>
</tr>
<tr>
<td>4 * w * h</td>
<td>BGRA</td>
<td>图像数据</td>
</tr>
</tbody>
</table>
<!-- 参考: https://myst-parser.readthedocs.io/en/latest/syntax/code_and_apis.html#including-code-from-files -->
<p>代码示例:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;memory_io.h&quot;</span>

<span class="cp">#define BOOST_DISABLE_ABI_HEADERS</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;boost/interprocess/allocators/allocator.hpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;boost/interprocess/containers/vector.hpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;boost/interprocess/managed_shared_memory.hpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;boost/interprocess/sync/interprocess_sharable_mutex.hpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;boost/interprocess/sync/scoped_lock.hpp&quot;</span>

<span class="k">using</span><span class="w"> </span><span class="n">char_allocator</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">boost</span><span class="o">::</span><span class="n">interprocess</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="n">boost</span><span class="o">::</span><span class="n">interprocess</span><span class="o">::</span><span class="n">managed_shared_memory</span><span class="o">::</span><span class="n">segment_manager</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">char_vector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">boost</span><span class="o">::</span><span class="n">interprocess</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span><span class="w"> </span><span class="n">char_allocator</span><span class="o">&gt;</span><span class="p">;</span>

<span class="cp">#define SEGMENT_MAX_SIZE 100 * 1024 * 1024</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">kMagicNumber_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">123456</span><span class="p">;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">SharedSegment</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">boost</span><span class="o">::</span><span class="n">interprocess</span><span class="o">::</span><span class="n">managed_shared_memory</span><span class="w"> </span><span class="n">segment_</span><span class="p">;</span>
<span class="w">  </span><span class="n">boost</span><span class="o">::</span><span class="n">interprocess</span><span class="o">::</span><span class="n">interprocess_sharable_mutex</span><span class="o">*</span><span class="w"> </span><span class="n">mtx_</span><span class="p">;</span>
<span class="w">  </span><span class="n">char_vector</span><span class="o">*</span><span class="w"> </span><span class="n">ptr_</span><span class="p">;</span>

<span class="w">  </span><span class="n">SharedSegment</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">mtx_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">ptr_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>

<span class="n">SharedMemoryWriter</span><span class="o">::</span><span class="n">SharedMemoryWriter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">shared_segment_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SharedSegment</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="n">SharedMemoryWriter</span><span class="o">::~</span><span class="n">SharedMemoryWriter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">remove</span><span class="p">();</span>
<span class="w">  </span><span class="k">delete</span><span class="w"> </span><span class="n">shared_segment_</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span><span class="w"> </span><span class="n">SharedMemoryWriter</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">microsecond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">key_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">  </span><span class="n">mtx_key_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;.mtx&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">max_lock_wait_microsecond_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">microsecond</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">reset</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">bool</span><span class="w"> </span><span class="n">SharedMemoryWriter</span><span class="o">::</span><span class="n">reset</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">shared_segment_</span><span class="o">-&gt;</span><span class="n">segment_</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">boost</span><span class="o">::</span><span class="n">interprocess</span><span class="o">::</span><span class="n">managed_shared_memory</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">interprocess</span><span class="o">::</span><span class="n">open_or_create</span><span class="p">,</span><span class="w"> </span><span class="n">key_</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span><span class="w"> </span><span class="n">SEGMENT_MAX_SIZE</span><span class="p">);</span>
<span class="w">    </span><span class="n">shared_segment_</span><span class="o">-&gt;</span><span class="n">ptr_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shared_segment_</span><span class="o">-&gt;</span><span class="n">segment_</span><span class="p">.</span><span class="n">find_or_construct</span><span class="o">&lt;</span><span class="n">char_vector</span><span class="o">&gt;</span><span class="p">(</span><span class="n">key_</span><span class="p">.</span><span class="n">c_str</span><span class="p">())(</span>
<span class="w">        </span><span class="n">shared_segment_</span><span class="o">-&gt;</span><span class="n">segment_</span><span class="p">.</span><span class="n">get_segment_manager</span><span class="p">());</span>
<span class="w">    </span><span class="c1">// shared_segment_-&gt;mtx_ =</span>
<span class="w">    </span><span class="c1">// shared_segment_-&gt;segment_.find_or_construct&lt;boost::interprocess::interprocess_sharable_mutex&gt; \</span>
<span class="c1">			(mtx_key_.c_str())();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shared_segment_</span><span class="o">-&gt;</span><span class="n">ptr_</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;SharedMemory write init success</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="cm">/*shared_segment_-&gt;mtx_ &amp;&amp; */</span><span class="w"> </span><span class="n">shared_segment_</span><span class="o">-&gt;</span><span class="n">ptr_</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;SharedMemory write init failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span><span class="w"> </span><span class="n">SharedMemoryWriter</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">timestamp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">boost</span><span class="o">::</span><span class="nn">interprocess</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">boost</span><span class="o">::</span><span class="nn">posix_time</span><span class="p">;</span>

<span class="w">  </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">shared_segment_</span><span class="o">-&gt;</span><span class="n">ptr_</span><span class="p">)</span>
<span class="w">    </span><span class="c1">// while (!shared_segment_-&gt;mtx_-&gt;timed_lock(microsec_clock::universal_time() +</span>
<span class="w">    </span><span class="c1">// microseconds(max_lock_wait_microsecond_)))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// printf(&quot;SharedMemeory icannot get lock,remove lock\n&quot;);</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">reset</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;SharedMemory write init failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shared_segment_</span><span class="o">-&gt;</span><span class="n">ptr_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">sz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">ptr_sz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sz</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shared_segment_</span><span class="o">-&gt;</span><span class="n">ptr_</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ptr_sz</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">shared_segment_</span><span class="o">-&gt;</span><span class="n">ptr_</span><span class="o">-&gt;</span><span class="n">resize</span><span class="p">(</span><span class="n">ptr_sz</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shared_segment_</span><span class="o">-&gt;</span><span class="n">ptr_</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">();</span>
<span class="w">      </span><span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">kMagicNumber_</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="w">      </span><span class="n">buf</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="w">      </span><span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">timestamp</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int64_t</span><span class="p">));</span>
<span class="w">      </span><span class="n">buf</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int64_t</span><span class="p">);</span>
<span class="w">      </span><span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sz</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="w">      </span><span class="n">buf</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="w">      </span><span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">sz</span><span class="p">);</span>
<span class="w">      </span><span class="c1">// shared_segment_-&gt;mtx_-&gt;unlock();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;SharedMemory write failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// shared_segment_-&gt;mtx_-&gt;unlock();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span><span class="w"> </span><span class="n">SharedMemoryWriter</span><span class="o">::</span><span class="n">remove</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// if (shared_segment_)</span>
<span class="w">  </span><span class="c1">//{</span>
<span class="w">  </span><span class="c1">//  if(shared_segment_-&gt;ptr_)</span>
<span class="w">  </span><span class="c1">//    shared_segment_-&gt;segment_.destroy_ptr(shared_segment_-&gt;ptr_);</span>
<span class="w">  </span><span class="c1">//  //if(shared_segment_-&gt;mtx_)</span>
<span class="w">  </span><span class="c1">//  //  shared_segment_-&gt;segment_.destroy_ptr(shared_segment_-&gt;mtx_);</span>
<span class="w">  </span><span class="c1">//  shared_segment_-&gt;ptr_ = 0;</span>
<span class="w">  </span><span class="c1">//  shared_segment_-&gt;mtx_ = 0;</span>
<span class="w">  </span><span class="c1">// }</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w">  </span><span class="c1">// boost::interprocess::shared_memory_object::remove(key_.c_str());</span>
<span class="p">}</span>

<span class="n">SharedMemoryReader</span><span class="o">::</span><span class="n">SharedMemoryReader</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">shared_segment_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SharedSegment</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="n">SharedMemoryReader</span><span class="o">::~</span><span class="n">SharedMemoryReader</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">delete</span><span class="w"> </span><span class="n">shared_segment_</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="kt">bool</span><span class="w"> </span><span class="n">SharedMemoryReader</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">microsecond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">key_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">  </span><span class="n">mtx_key_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;.mtx&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">max_lock_wait_microsecond_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">microsecond</span><span class="p">;</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;init...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w">  </span><span class="c1">// reset();</span>
<span class="p">}</span>

<span class="kt">bool</span><span class="w"> </span><span class="n">SharedMemoryReader</span><span class="o">::</span><span class="n">reset</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;reset..</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">shared_segment_</span><span class="o">-&gt;</span><span class="n">segment_</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">boost</span><span class="o">::</span><span class="n">interprocess</span><span class="o">::</span><span class="n">managed_shared_memory</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">interprocess</span><span class="o">::</span><span class="n">open_read_only</span><span class="p">,</span><span class="w"> </span><span class="n">key_</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;managed_shared_memory create</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">shared_segment_</span><span class="o">-&gt;</span><span class="n">ptr_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shared_segment_</span><span class="o">-&gt;</span><span class="n">segment_</span><span class="p">.</span><span class="n">find</span><span class="o">&lt;</span><span class="n">char_vector</span><span class="o">&gt;</span><span class="p">(</span><span class="n">key_</span><span class="p">.</span><span class="n">c_str</span><span class="p">()).</span><span class="n">first</span><span class="p">;</span>
<span class="w">    </span><span class="c1">/// shared_segment_-&gt;mtx_ = shared_segment_-&gt;segment_.find&lt;boost::interprocess::interprocess_sharable_mutex&gt;</span>
<span class="w">    </span><span class="c1">//	(mtx_key_.c_str()).first;</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;shared_memory find</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="cm">/*shared_segment_-&gt;mtx_ &amp;&amp; */</span><span class="w"> </span><span class="n">shared_segment_</span><span class="o">-&gt;</span><span class="n">ptr_</span><span class="p">)</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;SharedMemory read init success</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="cm">/*shared_segment_-&gt;mtx_ &amp;&amp; */</span><span class="w"> </span><span class="n">shared_segment_</span><span class="o">-&gt;</span><span class="n">ptr_</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;SharedMemory reader init failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span><span class="w"> </span><span class="n">SharedMemoryReader</span><span class="o">::</span><span class="n">read</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">int64_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">timestamp</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">boost</span><span class="o">::</span><span class="nn">interprocess</span><span class="p">;</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">boost</span><span class="o">::</span><span class="nn">posix_time</span><span class="p">;</span>
<span class="w">  </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/*while (!shared_segment_-&gt;mtx_ ||</span>
<span class="cm">            !shared_segment_-&gt;mtx_-&gt;timed_lock_sharable(microsec_clock::universal_time() +</span>
<span class="cm">    microseconds(max_lock_wait_microsecond_)))</span>
<span class="cm">    {</span>
<span class="cm">            printf(&quot;SharedMemeory icannot get lock,remove lock\n&quot;);</span>
<span class="cm">            if (!reset())</span>
<span class="cm">            {</span>
<span class="cm">                    return false;</span>
<span class="cm">            }</span>
<span class="cm">    }*/</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">shared_segment_</span><span class="o">-&gt;</span><span class="n">ptr_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">reset</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">buffer</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shared_segment_</span><span class="o">-&gt;</span><span class="n">ptr_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">ptr_sz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shared_segment_</span><span class="o">-&gt;</span><span class="n">ptr_</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ptr_sz</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shared_segment_</span><span class="o">-&gt;</span><span class="n">ptr_</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">();</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">buf</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">kMagicNumber_</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="n">buf</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="w">          </span><span class="n">timestamp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="kt">int64_t</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
<span class="w">          </span><span class="n">buf</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int64_t</span><span class="p">);</span>
<span class="w">          </span><span class="kt">int</span><span class="w"> </span><span class="n">sz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
<span class="w">          </span><span class="n">buf</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="w">          </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shared_segment_</span><span class="o">-&gt;</span><span class="n">ptr_</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="p">(</span><span class="n">ptr_sz</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sz</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">buffer</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>
<span class="w">            </span><span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">sz</span><span class="p">);</span>
<span class="w">          </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">// shared_segment_-&gt;mtx_-&gt;unlock_sharable();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="n">buffer</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;SharedMemory read failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// shared_segment_-&gt;mtx_-&gt;unlock();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="id6">
<h4>6.1.2.2 磁盘保存<a class="headerlink" href="#id6" title="Link to this heading"></a></h4>
<p>摄像头仿真同时支持磁盘保存方式, 但由于图像数据 IO 很大, 且图像 jpeg 压缩也会消耗性能, 暂不推荐此方式.</p>
<p>在 Game.ini 中添加如下内容:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[Sensor]</span>
<span class="na">CameraSaved</span><span class="o">=</span><span class="s">true</span>
</pre></div>
</div>
<p>重启仿真软件, 图像数据即保存于:</p>
<ul class="simple">
<li><p>Windows 下:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">C:\Users\用户名\AppData\Roaming\tadsim\service_data\display\Saved\SensorData</span></code></p></li>
</ul>
</li>
<li><p>Ubuntu 下:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">/home/.config/tadsim/Display/Saved/SensorData</span></code></p></li>
</ul>
</li>
</ul>
</section>
<section id="pb">
<h4>6.1.2.3 PB 消息<a class="headerlink" href="#pb" title="Link to this heading"></a></h4>
<p>首先需要打开 Display 的 PB 广播功能, 在 Game.ini 中添加如下内容:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[Sensor]</span>
<span class="na">PublicMsg</span><span class="o">=</span><span class="s">true</span>
</pre></div>
</div>
<p>然后通过订阅系统的消息, 来获取传感器数据 .TOPIC 为 <code class="docutils literal notranslate"><span class="pre">DISPLAYSENSOR_{id}</span></code>,  其中 id 是算法的 id, 通过 Display 模块的运行参数 -topicid 指定, 默认为 0.</p>
<p>SensorPose 详细定义:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>单位</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>longitude</td>
<td>double</td>
<td>deg</td>
<td>经度</td>
</tr>
<tr>
<td>latitude</td>
<td>double</td>
<td>deg</td>
<td>纬度</td>
</tr>
<tr>
<td>altitude</td>
<td>double</td>
<td>m</td>
<td>高程</td>
</tr>
<tr>
<td>roll</td>
<td>float</td>
<td>rad</td>
<td>滚角</td>
</tr>
<tr>
<td>pitch</td>
<td>float</td>
<td>rad</td>
<td>俯仰角</td>
</tr>
<tr>
<td>yaw</td>
<td>float</td>
<td>rad</td>
<td>航向角</td>
</tr>
</tbody>
</table>
<p>Camera详细数据定义:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>单位</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>int32</td>
<td></td>
<td>传感器ID</td>
</tr>
<tr>
<td>timestamp</td>
<td>double</td>
<td>ms</td>
<td>时间戳</td>
</tr>
<tr>
<td>type</td>
<td>string</td>
<td>string</td>
<td>图片编码类型JPEG, PNG, EXR, BGRA</td>
</tr>
<tr>
<td>image_data</td>
<td>bytes</td>
<td>二进制</td>
<td>图像数据</td>
</tr>
<tr>
<td>width</td>
<td>int32</td>
<td>像素</td>
<td>图像宽</td>
</tr>
<tr>
<td>height</td>
<td>int32</td>
<td>像素</td>
<td>图像高</td>
</tr>
<tr>
<td>pose</td>
<td>SensorPose</td>
<td></td>
<td>位姿</td>
</tr>
</tbody>
</table>
<!-- 参考: https://myst-parser.readthedocs.io/en/latest/syntax/code_and_apis.html#including-code-from-files -->
<p>代码示例:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;sensor.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;algorithm&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;boost/filesystem.hpp&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;fstream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;map&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;sensor_raw.pb.h&quot;</span>

<span class="n">sim_sensor</span><span class="o">::</span><span class="n">sim_sensor</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">threads</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="n">sim_sensor</span><span class="o">::~</span><span class="n">sim_sensor</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">sim_sensor</span><span class="o">::</span><span class="n">Init</span><span class="p">(</span><span class="n">tx_sim</span><span class="o">::</span><span class="n">InitHelper</span><span class="o">&amp;</span><span class="w"> </span><span class="n">helper</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">NumOfDisplay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">helper</span><span class="p">.</span><span class="n">GetParameter</span><span class="p">(</span><span class="s">&quot;NumOfDisplay&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">NumOfDisplay</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">disNum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">atoi</span><span class="p">(</span><span class="n">NumOfDisplay</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">savePath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">helper</span><span class="p">.</span><span class="n">GetParameter</span><span class="p">(</span><span class="s">&quot;SavePath&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">disNum</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">helper</span><span class="p">.</span><span class="n">Subscribe</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;DISPLAYSENSOR_&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">boost</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">exists</span><span class="p">(</span><span class="n">savePath</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">boost</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="n">savePath</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">sim_sensor</span><span class="o">::</span><span class="n">Reset</span><span class="p">(</span><span class="n">tx_sim</span><span class="o">::</span><span class="n">ResetHelper</span><span class="o">&amp;</span><span class="w"> </span><span class="n">helper</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">saveJpg</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">fname</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">buf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">sim_msg</span><span class="o">::</span><span class="n">CameraRaw</span><span class="w"> </span><span class="n">camera</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">camera</span><span class="p">.</span><span class="n">ParseFromString</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;camera error&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">camera</span><span class="p">.</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;JPEG&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">fstream</span><span class="w"> </span><span class="nf">of</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">out</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">binary</span><span class="p">);</span>
<span class="w">    </span><span class="n">of</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">camera</span><span class="p">.</span><span class="n">image_data</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">image_data</span><span class="p">().</span><span class="n">size</span><span class="p">());</span>
<span class="w">    </span><span class="n">of</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">bool</span><span class="w"> </span><span class="n">savePcd</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">fname</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">buf</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">sim_msg</span><span class="o">::</span><span class="n">LidarRaw</span><span class="w"> </span><span class="n">lidar</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">lidar</span><span class="p">.</span><span class="n">ParseFromString</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;lidar error&quot;</span><span class="p">;</span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lidar</span><span class="p">.</span><span class="n">count</span><span class="p">();</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="w"> </span><span class="nf">of</span><span class="p">(</span><span class="n">fname</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">of</span><span class="p">.</span><span class="n">good</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">of</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;# .PCD v.7 - Point Cloud Data file format</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">of</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;VERSION 0.7</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">of</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;FIELDS x y z intensity label</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">of</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;SIZE 4 4 4 4 4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">of</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;TYPE F F F F I</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">of</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;COUNT 1 1 1 1 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">of</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;WIDTH &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">of</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;HEIGHT 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">of</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;VIEWPOINT 0 0 0 1 -1 0 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">of</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;POINTS &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">of</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;DATA binary</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lidar</span><span class="p">.</span><span class="n">point_lists</span><span class="p">().</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">of</span><span class="p">.</span><span class="n">write</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">lidar</span><span class="p">.</span><span class="n">point_lists</span><span class="p">().</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">lidar</span><span class="p">.</span><span class="n">point_lists</span><span class="p">().</span><span class="n">size</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#pragma pack(push, 4)</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">TMP</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">      </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">      </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">      </span><span class="kt">float</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">          </span><span class="c1">// intensity</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// type</span>
<span class="w">    </span><span class="p">};</span>
<span class="cp">#pragma pack(pop)</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TMP</span><span class="o">&gt;</span><span class="w"> </span><span class="n">datas</span><span class="p">;</span>
<span class="w">    </span><span class="n">datas</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">lidar</span><span class="p">.</span><span class="n">points</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">TMP</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">      </span><span class="n">tmp</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">();</span>
<span class="w">      </span><span class="n">tmp</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">();</span>
<span class="w">      </span><span class="n">tmp</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">z</span><span class="p">();</span>
<span class="w">      </span><span class="n">tmp</span><span class="p">.</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">i</span><span class="p">();</span>
<span class="w">      </span><span class="n">tmp</span><span class="p">.</span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">t</span><span class="p">();</span>
<span class="w">      </span><span class="n">datas</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">of</span><span class="p">.</span><span class="n">write</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">datas</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">of</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">sim_sensor</span><span class="o">::</span><span class="n">Step</span><span class="p">(</span><span class="n">tx_sim</span><span class="o">::</span><span class="n">StepHelper</span><span class="o">&amp;</span><span class="w"> </span><span class="n">helper</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">helper</span><span class="p">.</span><span class="n">timestamp</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;: &quot;</span><span class="p">;</span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">disNum</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">payload_</span><span class="p">;</span>
<span class="w">    </span><span class="n">helper</span><span class="p">.</span><span class="n">GetSubscribedMessage</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;DISPLAYSENSOR_&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">payload_</span><span class="p">);</span>
<span class="w">    </span><span class="n">sim_msg</span><span class="o">::</span><span class="n">SensorRaw</span><span class="w"> </span><span class="n">sensorraw</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">payload_</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">sensorraw</span><span class="p">.</span><span class="n">ParseFromString</span><span class="p">(</span><span class="n">payload_</span><span class="p">))</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">baseName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">savePath</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">helper</span><span class="p">.</span><span class="n">timestamp</span><span class="p">());</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;[&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;: &quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sensor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sensorraw</span><span class="p">.</span><span class="n">sensor</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;(&quot;</span><span class="p">;</span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sensor</span><span class="p">.</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">sim_msg</span><span class="o">::</span><span class="n">SensorRaw</span><span class="o">::</span><span class="n">TYPE_CAMERA</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">threads</span><span class="p">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">saveJpg</span><span class="p">,</span><span class="w"> </span><span class="n">baseName</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;_camera_&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">sensor</span><span class="p">.</span><span class="n">id</span><span class="p">())</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;.jpg&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sensor</span><span class="p">.</span><span class="n">raw</span><span class="p">());</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;camera=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sensor</span><span class="p">.</span><span class="n">raw</span><span class="p">().</span><span class="n">size</span><span class="p">();</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sensor</span><span class="p">.</span><span class="n">type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">sim_msg</span><span class="o">::</span><span class="n">SensorRaw</span><span class="o">::</span><span class="n">TYPE_LIDAR</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">threads</span><span class="p">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">savePcd</span><span class="p">,</span><span class="w"> </span><span class="n">baseName</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;_lidar_&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">sensor</span><span class="p">.</span><span class="n">id</span><span class="p">())</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;.pcd&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">sensor</span><span class="p">.</span><span class="n">raw</span><span class="p">());</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;lidar=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">sensor</span><span class="p">.</span><span class="n">raw</span><span class="p">().</span><span class="n">size</span><span class="p">();</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;), &quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;], &quot;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">sim_sensor</span><span class="o">::</span><span class="n">Stop</span><span class="p">(</span><span class="n">tx_sim</span><span class="o">::</span><span class="n">StopHelper</span><span class="o">&amp;</span><span class="w"> </span><span class="n">helper</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;stop.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="n">TXSIM_MODULE</span><span class="p">(</span><span class="n">sim_sensor</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="gpu">
<h4>6.1.2.4 GPU 显存共享<a class="headerlink" href="#gpu" title="Link to this heading"></a></h4>
<p><strong>a. IPC 概念</strong></p>
<p>CUDA IPC 机制允许将设备内存分配从一个进程共享到另一个进程. 见<a class="reference external" href="https://github.com/NVIDIA/cuda-samples/tree/master/Samples/0_Introduction/simpleIPC">官方例子</a>.</p>
<p>所需的步骤大致如下:</p>
<ul class="simple">
<li><p>进程 A 分配 GPU 显存.</p></li>
<li><p>进程 A 获取步骤 1 中分配的 CUDA IPC 句柄 (handle).</p></li>
<li><p>进程 A 创建一个共享内存, 以便可以将步骤 2 中的句柄传送给进程 B.</p></li>
<li><p>进程 A 将句柄放入共享内存.</p></li>
<li><p>进程 B 从共享内存中选取句柄.</p></li>
<li><p>进程 B 使用句柄访问 CUDA 共享显存.</p></li>
</ul>
<p>图像数据, 通过 IPC 方式, 传递给感知算法, 要求感知算法和 Display 模块在同一显卡中, 避免了图像传输的延时.</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>注: IPC 功能仅限 Linux. 上述步骤中, 进程 A 为 Display 程序, 进程 B 为用户的程序.</p>
</div>
<p><strong>b. IPC 信息交换</strong></p>
<p>Display 创建的共享内存 (非显存) 地址为: <code class="docutils literal notranslate"><span class="pre">Tadsim_Camera_{ID}_GPU</span></code>, 用户程序从该地址获取 IPC 必要的信息, 创建显存访问权限.</p>
<p>例如 id 为 0 的 camera 为 <code class="docutils literal notranslate"><span class="pre">Tadsim_Camera_0_GPU</span></code>, 该数据在 <code class="docutils literal notranslate"><span class="pre">reset</span></code> 和 <code class="docutils literal notranslate"><span class="pre">step</span></code> 阶段有效.</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>字段</th>
<th>偏移</th>
<th>类型</th>
<th>长度</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>tag=123456</td>
<td>0</td>
<td>int</td>
<td>4</td>
<td>标识</td>
</tr>
<tr>
<td>timestamp</td>
<td>4</td>
<td>int64</td>
<td>8</td>
<td>时间戳</td>
</tr>
<tr>
<td>size</td>
<td>12</td>
<td>int</td>
<td>4</td>
<td>后续buf的长度 = 1024</td>
</tr>
<tr>
<td>imgWidth</td>
<td>16</td>
<td>int</td>
<td>4</td>
<td>图像宽</td>
</tr>
<tr>
<td>imgHeight</td>
<td>20</td>
<td>int</td>
<td>4</td>
<td>图像高</td>
</tr>
<tr>
<td>memHandle</td>
<td>24</td>
<td>cudaIpcMemHandle_t</td>
<td>64</td>
<td>显存地址句柄</td>
</tr>
<tr>
<td>eventHandle</td>
<td>88</td>
<td>cudaIpcEventHandle_t</td>
<td>64</td>
<td>事件句柄</td>
</tr>
<tr>
<td>reserved</td>
<td>152</td>
<td></td>
<td>888</td>
<td>保留, 无意义</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>注: 在 reset 阶段, timestamp 保存的是 Display 执行 reset 的当前 unix 时间, 在 step 阶段, timestamp 保存的是当前的 step 逻辑时间. 由于 Display reset 较慢, 用户模块务必要校验 timestamp 是否是当前时间, 否则拿到的共享数据可能是旧的. TAD Sim 自带的例子里实现了 reset 校验和同步.</p>
</div>
<p><strong>c. IPC 共享格式</strong></p>
<p>图像数据和内存共享一样, 格式为 <code class="docutils literal notranslate"><span class="pre">BGRA</span> <span class="pre">BGRA</span> <span class="pre">BGRA</span></code>……一共 <code class="docutils literal notranslate"><span class="pre">width</span> <span class="pre">*</span> <span class="pre">height</span> <span class="pre">*</span> <span class="pre">4字节</span></code></p>
<p><strong>d. JPEG 质量</strong></p>
<p>[Sensor]分组下进行质量配置, 在 Game.ini 中添加如下内容:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[Sensor]</span>
<span class="na">JpegQuality</span><span class="o">=</span><span class="s">85</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="id7">
<h2>6.2 激光雷达仿真<a class="headerlink" href="#id7" title="Link to this heading"></a></h2>
<p>TAD Sim 激光雷达传感器仿真具有低延时、高保真、语义输出的特点.</p>
<p>基于实时光线追踪, 最高支持每帧600万点, 平均帧率不低于 60FPS.</p>
<p>激光仿真组件包含了能量衰减模型、雨雪雾天气模型和噪声模型, 使用实车数据标定模型参数, 有效模拟不同型号的激光雷达特性, 保证了仿真结果的真实性.</p>
<p>支持16线, 32线, 64线规格, 布线模型可配置.</p>
<p>采用显卡实时光追技术, 面对复杂场景也能实时仿真.目前已支持多种激光雷达型号的原生数据包模拟, 数据包通过 UDP 协议直接发送给用户, 无需额外适配数据格式.</p>
<p>支持语义点云输出, 可用于标注数据的生成, 帮助推理算法提示训练指标.</p>
<p>TAD Sim 支持激光雷达仿真, 平台提供默认配置参数, 并支持各参数自定义配置功能, 激光雷达依赖 Display 模块.</p>
<div align="center"><img src="./_static/images/image229.png" alt="" width="700px"></div><br>
<p>下文列出了激光雷达仿真配置及数据获取详细信息.</p>
<section id="id8">
<h3>6.2.1 参数说明<a class="headerlink" href="#id8" title="Link to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th>范围</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>位置X(cm)</td>
<td>0</td>
<td>[-1000, 1000]</td>
<td>安装位置</td>
</tr>
<tr>
<td>位置Y(cm)</td>
<td>0</td>
<td>[-1000, 1000]</td>
<td>安装位置</td>
</tr>
<tr>
<td>位置Z(cm)</td>
<td>171</td>
<td>[    0, 1000]</td>
<td>安装位置</td>
</tr>
<tr>
<td>旋转X(°)</td>
<td>0</td>
<td>[-180,   180]</td>
<td>安装角度</td>
</tr>
<tr>
<td>旋转Y(°)</td>
<td>0</td>
<td>[-180,   180]</td>
<td>安装角度</td>
</tr>
<tr>
<td>旋转Z(°)</td>
<td>0</td>
<td>[-180,   180]</td>
<td>安装角度</td>
</tr>
<tr>
<td>实例ID</td>
<td>0</td>
<td>-</td>
<td>当配置了多个 Display 时, 只有 Display 的实例 ID 一致时, 才会被处理</td>
</tr>
<tr>
<td>型号</td>
<td>RS32</td>
<td>RS32/RS16/HS40/Velodyne32/自定义</td>
<td></td>
</tr>
<tr>
<td>频率(Hz)</td>
<td>5</td>
<td>5/10/20 "Model = User 时此项可手动填 [1,128]"</td>
<td>激光雷达旋转频率.具体特定型号时, 只能选择 5、10、20hz, User 型号时频率开放</td>
</tr>
<tr>
<td>IP</td>
<td>127.0.0.1</td>
<td></td>
<td>接收者IP</td>
</tr>
<tr>
<td>端口</td>
<td>2000, 2001</td>
<td>1000～60000</td>
<td>端口, 速腾需要2个, 禾赛需要1个</td>
</tr>
<tr>
<td>衰减标定值</td>
<td>0</td>
<td></td>
<td>不同型号的标定值不一样, 填写后会覆盖默认值</td>
</tr>
<tr>
<td>角度标定数据</td>
<td></td>
<td></td>
<td>角度定义文件, 填写后会覆盖默认值</td>
</tr>
<tr>
<td>大气消光系数</td>
<td>0</td>
<td>[0.0,1.0]</td>
<td>AtmosphericExtinctionCoefficient</td>
</tr>
<tr>
<td>线数</td>
<td>16</td>
<td>[4, 1000]</td>
<td>型号为自定义时</td>
</tr>
<tr>
<td>半径范围(m)</td>
<td>150</td>
<td>(0, 1000]</td>
<td>型号为自定义时</td>
</tr>
<tr>
<td>水平分辨率(°)</td>
<td>1</td>
<td>(0, 360]</td>
<td>型号为自定义时</td>
</tr>
<tr>
<td>上仰角(°)</td>
<td>10</td>
<td>(0, 90]</td>
<td>型号为自定义时</td>
</tr>
<tr>
<td>下仰角(°)</td>
<td>10</td>
<td>(0, 90]</td>
<td>型号为自定义时</td>
</tr>
<tr>
<td>结束角度(°)</td>
<td>360</td>
<td>(0, 360.0]</td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="id9">
<h3>6.2.2 数据获取<a class="headerlink" href="#id9" title="Link to this heading"></a></h3>
<section id="udp">
<h4>6.2.2.1 UDP 包<a class="headerlink" href="#udp" title="Link to this heading"></a></h4>
<p>激光雷达仿真数据传输通过 UDP 传给可视化软件. 在传感器配置中设置 IP 和端口, 然后通过可视化软件显示点云.</p>
<p>以 RSView 为例: 首先打开传感器, 点击 <code class="docutils literal notranslate"><span class="pre">Add</span></code> 添加配置(首次需要), 在文件管理器中弹窗中选择目标地址. 设置成功后即可对传感器的 <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">of</span> <span class="pre">Lidar</span></code> 及 <code class="docutils literal notranslate"><span class="pre">Intensity</span></code> 进行设置.</p>
<div align="center"><img src="./_static/images/image230.png" alt="" width="700px"></div><br>
<div align="center"><img src="./_static/images/image231.png" alt="" width="700px"></div><br>
<p>也可通过工具栏进行端口配置, 右上角工具栏 <code class="docutils literal notranslate"><span class="pre">Tool</span></code>, 在下拉框中选择 <code class="docutils literal notranslate"><span class="pre">Data</span> <span class="pre">Port</span> <span class="pre">Setting</span></code>, 在弹出的设置窗口中修改相应信息即可. 需要修改为目录下 <code class="docutils literal notranslate"><span class="pre">cfg+数字.ini</span></code> 类型文件中对应的 <code class="docutils literal notranslate"><span class="pre">msop_port</span></code> 和 <code class="docutils literal notranslate"><span class="pre">difop_port</span></code> 值.</p>
<div align="center"><img src="./_static/images/image232.png" alt="" width="400px"></div><br>
<div align="center"><img src="./_static/images/image233.png" alt="" width="700px"></div><br>
</section>
<section id="id10">
<h4>6.2.2.2 磁盘保存<a class="headerlink" href="#id10" title="Link to this heading"></a></h4>
<p>激光仿真同时支持磁盘保存方式, 但由于点云数据IO很大, 不推荐此方式.</p>
<p>开关设置方法和图像类似, 在 Game.ini 中添加如下内容:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[Sensor]</span>
<span class="na">LidarSaved</span><span class="o">=</span><span class="s">true</span>
</pre></div>
</div>
<p>重启仿真软件, 点云数据即保存于:</p>
<ul class="simple">
<li><p>Windows 下:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">C:\Users\用户名\AppData\Roaming\tadsim\service_data\display\Saved\SensorData</span></code></p></li>
</ul>
</li>
<li><p>Ubuntu 下:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">/home/.config/tadsim/Display/Saved/SensorData</span></code></p></li>
</ul>
</li>
</ul>
</section>
<section id="id11">
<h4>6.2.2.3 PB 消息<a class="headerlink" href="#id11" title="Link to this heading"></a></h4>
<p>首先需要打开 Display 的 PB 广播功能, 在 Game.ini 中添加如下内容:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[Sensor]</span>
<span class="na">PublicMsg</span><span class="o">=</span><span class="s">true</span>
</pre></div>
</div>
<p>然后通过订阅系统的消息, 来获取传感器数据. TOPIC 为 <code class="docutils literal notranslate"><span class="pre">DISPLAYSENSOR_{id}</span></code>,  id 是算法 id, 通过 Display 模块的运行参数 -topicid 指定, 默认为 0.</p>
<p><strong>SensorPose 详细定义:</strong></p>
<table border="1" class="docutils">
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>单位</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>longitude</td>
<td>double</td>
<td>deg</td>
<td>经度</td>
</tr>
<tr>
<td>latitude</td>
<td>double</td>
<td>deg</td>
<td>纬度</td>
</tr>
<tr>
<td>altitude</td>
<td>double</td>
<td>m</td>
<td>高程</td>
</tr>
<tr>
<td>roll</td>
<td>float</td>
<td>rad</td>
<td>滚角</td>
</tr>
<tr>
<td>pitch</td>
<td>float</td>
<td>rad</td>
<td>俯仰角</td>
</tr>
<tr>
<td>yaw</td>
<td>float</td>
<td>rad</td>
<td>航向角</td>
</tr>
</tbody>
</table>
<p><strong>LidarRaw 详细定义:</strong></p>
<table border="1" class="docutils">
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>单位</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Point.x</td>
<td>float</td>
<td>m</td>
<td>单帧局部坐标x</td>
</tr>
<tr>
<td>Point.y</td>
<td>float</td>
<td>m</td>
<td>单帧局部坐标y</td>
</tr>
<tr>
<td>Point.z</td>
<td>float</td>
<td>m</td>
<td>单帧局部坐标z</td>
</tr>
<tr>
<td>Point.i</td>
<td>float</td>
<td></td>
<td>反射率</td>
</tr>
<tr>
<td>Point.t</td>
<td>uint</td>
<td></td>
<td>类型,点云标签值</td>
</tr>
<tr>
<td>id</td>
<td>int32</td>
<td></td>
<td>传感器ID</td>
</tr>
<tr>
<td>timestamp_begin</td>
<td>double</td>
<td>ms</td>
<td>开始时间戳</td>
</tr>
<tr>
<td>timestamp_end</td>
<td>double</td>
<td>ms</td>
<td>结束时间戳</td>
</tr>
<tr>
<td>points</td>
<td>repeated Point</td>
<td></td>
<td>点云,(repeat序列化很慢, 基本不用)</td>
</tr>
<tr>
<td>point_lists</td>
<td>bytes</td>
<td></td>
<td>点云的二进制形式,(速度快, 按照float数组存储, 一个点按照Point里字段的顺序占用5个float, 反射率也是float)</td>
</tr>
<tr>
<td>count</td>
<td>uint</td>
<td></td>
<td>点数</td>
</tr>
<tr>
<td>pose_first</td>
<td>SensorPose</td>
<td></td>
<td>初始pose</td>
</tr>
<tr>
<td>pose_last</td>
<td>SensorPose</td>
<td></td>
<td>最后pose</td>
</tr>
<tr>
<td>coord_type</td>
<td>CoordType枚举</td>
<td></td>
<td>COORD_SENSOR =0;COORD_VEHICLE = 1;COORD_ENU = 2;</td>
</tr>
</tbody>
</table>
<p>代码参考图像示例 (9.1.2.3 章节).</p>
</section>
<section id="id12">
<h4>6.2.2.4 其他设置<a class="headerlink" href="#id12" title="Link to this heading"></a></h4>
<p>Game.ini 中还有其他和 lidar 相关的设置:</p>
<ul class="simple">
<li><p><strong>LidarCoordType=[None,vehicle,enu]</strong></p>
<ul>
<li><p>设置点云坐标系.</p></li>
<li><p>None 表示传感器坐标系, vehicle 表示车辆坐标系, enu 表示世界坐标系</p></li>
</ul>
</li>
<li><p><strong>LidarMethod=[raytracing,depth,raycast]</strong></p>
<ul>
<li><p>设置 lidar 的扫描方式,</p></li>
<li><p>默认情况下 linux 平台为 depth, 用图像深度模拟光线;</p></li>
<li><p>Windows 平台如果美术场景打开了光线追踪, 则默认支持 raytracing;</p></li>
<li><p>raycast 为 cpu 扫描方式, 速度较慢.</p></li>
</ul>
</li>
<li><p><strong>LidarDualReturn=[true,false]</strong></p>
<ul>
<li><p>设置激光雷达是否为双反射, 默认关闭</p></li>
</ul>
</li>
<li><p><strong>LidarFrameAlign=[true,false]</strong></p>
<ul>
<li><p>设置激光运动补偿.</p></li>
<li><p>默认关闭, 当车辆运动时, 在 360 旋转型号上, 一帧点云会出现不对齐的现象, 如果设置 true, 则强制运动补偿.</p></li>
</ul>
</li>
</ul>
</section>
</section>
</section>
<section id="id13">
<h2>6.3 毫米波雷达仿真<a class="headerlink" href="#id13" title="Link to this heading"></a></h2>
<p>TAD Sim 支持毫米波雷达仿真, 基于真实毫米波雷达模型仿真, 平台提供默认配置参数, 并支持各参数自定义配置功能, 毫米波雷达依赖 Radar 模块.</p>
<div align="center"><img src="./_static/images/image234.png" alt="" width="700px"></div><br>
<section id="id14">
<h3>6.3.1 参数说明<a class="headerlink" href="#id14" title="Link to this heading"></a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>名称</p></th>
<th class="head"><p>默认值</p></th>
<th class="head"><p>范围</p></th>
<th class="head"><p>含义</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>位置X(cm)</p></td>
<td><p>0</p></td>
<td><p>[-1000, 1000]</p></td>
<td><p>安装位置</p></td>
</tr>
<tr class="row-odd"><td><p>位置Y(cm)</p></td>
<td><p>0</p></td>
<td><p>[-1000, 1000]</p></td>
<td><p>安装位置</p></td>
</tr>
<tr class="row-even"><td><p>位置Z(cm)</p></td>
<td><p>171</p></td>
<td><p>[0, 1000]</p></td>
<td><p>安装位置</p></td>
</tr>
<tr class="row-odd"><td><p>旋转X(°)</p></td>
<td><p>0</p></td>
<td><p>[-180, 180]</p></td>
<td><p>安装角度</p></td>
</tr>
<tr class="row-even"><td><p>旋转Y(°)</p></td>
<td><p>0</p></td>
<td><p>[-180, 180]</p></td>
<td><p>安装角度</p></td>
</tr>
<tr class="row-odd"><td><p>旋转Z(°)</p></td>
<td><p>0</p></td>
<td><p>[-180, 180]</p></td>
<td><p>安装角度</p></td>
</tr>
<tr class="row-even"><td><p>实例ID</p></td>
<td><p>0</p></td>
<td><p>-</p></td>
<td><p>当配置了多个 Display 时, 只有 Display 的实例 ID 一致时, 才会被处理</p></td>
</tr>
<tr class="row-odd"><td><p>频率(Hz)</p></td>
<td><p>10</p></td>
<td><p>(0, 200]</p></td>
<td><p>传感器频率</p></td>
</tr>
<tr class="row-even"><td><p>雷达载频</p></td>
<td><p>77</p></td>
<td><p>77/24</p></td>
<td><p>雷达波形的中心频率, 影响雷达最大探测距离、距离分辨率、速度分辨率、测距精度、测速精度、测角精度</p></td>
</tr>
<tr class="row-odd"><td><p>发射功率(dBm)</p></td>
<td><p>10</p></td>
<td><p>[5, 10]</p></td>
<td><p>雷达发射信号的功率值, 发射功率越大, 雷达威力越大, 最大探测距离越大.影响雷达最大探测距离、测距精度、测速精度、测角精度</p></td>
</tr>
<tr class="row-even"><td><p>发射天线增益(dBi)</p></td>
<td><p>15</p></td>
<td><p>[10, 15]</p></td>
<td><p>最大探测距离随发射天线增益的增大而增大.影响雷达最大探测距离、测距精度、测速精度、测角精度</p></td>
</tr>
<tr class="row-odd"><td><p>接收天线增益(dBi)</p></td>
<td><p>15</p></td>
<td><p>[10, 15]</p></td>
<td><p>最大探测距离随接收天线增益的增大而增大.影响雷达最大探测距离、测距精度、测速精度、测角精度</p></td>
</tr>
<tr class="row-even"><td><p>等效噪声温度(K)</p></td>
<td><p>300</p></td>
<td><p>[290, 310]</p></td>
<td><p>雷达所处环境的等效噪声温度, 最大探测距离随搭设天线增益的增大而减小.影响雷达最大探测距离、测距精度、测速精度、测角精度</p></td>
</tr>
<tr class="row-odd"><td><p>接收机噪声系数(dB)</p></td>
<td><p>12</p></td>
<td><p>[0, 45]</p></td>
<td><p>影响雷达最大探测距离、测距精度、测速精度、测角精度</p></td>
</tr>
<tr class="row-even"><td><p>系统衰减常数(dB)</p></td>
<td><p>10</p></td>
<td><p>联动F0_GHz(77: [5, 10], 24: [15, 30])</p></td>
<td><p>77/79/24GHz的雷达系统衰减常数范围不同, 需注意, 影响雷达最大探测距离</p></td>
</tr>
<tr class="row-odd"><td><p>最小可检测信噪比(dB)</p></td>
<td><p>18</p></td>
<td><p>[15, 22]</p></td>
<td><p>影响目标是否可被检测到的参数, 同时影响最大探测距离.在其他参数一定的情况下, 最大探测距离随最小可检测信噪比的增大而减小.影响雷达最大探测距离、测距精度、测速精度、测角精度</p></td>
</tr>
<tr class="row-even"><td><p>目标延迟参数(ms)</p></td>
<td><p>0</p></td>
<td><p>[0, 5000]</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>垂直fov(°)</p></td>
<td><p>10</p></td>
<td><p>[0, 160]</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p>水平fov(°)</p></td>
<td><p>0</p></td>
<td><p>[0, 160]</p></td>
<td><p>雷达天线水平探测范围, 请注意假设设置为10, 则代表探测范围为[-5, 5]</p></td>
</tr>
<tr class="row-odd"><td><p>水平角度分辨率(°)</p></td>
<td><p>3</p></td>
<td><p>[1, 10]</p></td>
<td><p>雷达天线水平角分辨率, 即水平天线3dB波束宽度, 以1°为步进输入</p></td>
</tr>
<tr class="row-even"><td><p>垂直角度分辨率(°)</p></td>
<td><p>3</p></td>
<td><p>[1, 10]</p></td>
<td><p>雷达天线垂直角分辨率, 即水平天线3dB波束宽度, 以1°为步进输入</p></td>
</tr>
<tr class="row-odd"><td><p>故障数据</p></td>
<td><p></p></td>
<td><p></p></td>
<td><p>故障注入文件, 包含类型, 关键帧, 故障值</p></td>
</tr>
</tbody>
</table>
</section>
<section id="id15">
<h3>6.3.2 数据获取<a class="headerlink" href="#id15" title="Link to this heading"></a></h3>
<section id="id16">
<h4>6.3.2.1 PB消息<a class="headerlink" href="#id16" title="Link to this heading"></a></h4>
<p>采用 OSI 标准格式定义, 数据保存在 radar_sensor 中, 格式定义请参考:</p>
<p><a class="reference external" href="https://opensimulationinterface.github.io/open-simulation-interface/structosi3_1_1FeatureData.html">open_simulation_interface: osi3::FeatureData Struct Reference</a></p>
</section>
<section id="id17">
<h4>6.3.2.2 磁盘保存<a class="headerlink" href="#id17" title="Link to this heading"></a></h4>
<p>如果模块中的初始化参数指定了 DebugDir=xxx 路径, 则会在设置的路径目录中保存每一帧的OSI消息, 保存为 JSON 格式.</p>
</section>
</section>
</section>
<section id="id18">
<h2>6.4 超声波雷达仿真<a class="headerlink" href="#id18" title="Link to this heading"></a></h2>
<p>TAD Sim 支持超声波雷达仿真, 平台提供默认配置参数, 并支持各参数自定义配置功能, 超声波雷达依赖 Display 模块.</p>
<div align="center"><img src="./_static/images/image235.png" alt="" width="700px"></div><br>
<section id="id19">
<h3>6.4.1 参数说明<a class="headerlink" href="#id19" title="Link to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th>名称</th>
<th>英文</th>
<th>默认值</th>
<th>范围</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>位置X(cm)</td>
<td></td>
<td>-37</td>
<td>[-1000, 1000]</td>
<td>安装位置</td>
</tr>
<tr>
<td>位置Y(cm)</td>
<td></td>
<td>25</td>
<td>[-1000, 1000]</td>
<td>安装位置</td>
</tr>
<tr>
<td>位置Z(cm)</td>
<td></td>
<td>171</td>
<td>[0, 1000]</td>
<td>安装位置</td>
</tr>
<tr>
<td>旋转X(°)</td>
<td></td>
<td>0</td>
<td>[-180, 180]</td>
<td>安装角度</td>
</tr>
<tr>
<td>旋转Y(°)</td>
<td></td>
<td>0</td>
<td>[-180, 180]</td>
<td>安装角度</td>
</tr>
<tr>
<td>旋转Z(°)</td>
<td></td>
<td>0</td>
<td>[-180, 180]</td>
<td>安装角度</td>
</tr>
<tr>
<td>实例ID</td>
<td></td>
<td>0</td>
<td>-</td>
<td>当配置了多个 display 时, 只有Display的实例ID一致时, 才会被处理</td>
</tr>
<tr>
<td>频率(Hz)</td>
<td>Frequency</td>
<td>40000</td>
<td>[4, 250K]</td>
<td>声波频率</td>
</tr>
<tr>
<td>垂直fov(°)</td>
<td>FovVertical</td>
<td>30</td>
<td>[0.0,160.0]</td>
<td>雷达天线垂直探测范围, 请注意假设设置为10, 则代表探测范围为[-5,5]</td>
</tr>
<tr>
<td>水平fov(°)</td>
<td>FovHorizontal</td>
<td>60</td>
<td>[0.0,160.0]</td>
<td>雷达天线水平探测范围, 请注意假设设置为10, 则代表探测范围为[-5,5]</td>
</tr>
<tr>
<td>有效分贝(dB)</td>
<td>dBmin</td>
<td>-6</td>
<td>[-1000.0,0.0]</td>
<td>能量分贝</td>
</tr>
<tr>
<td>发声半径(m)</td>
<td>Radius</td>
<td>0.01</td>
<td>[0.001,0.3]</td>
<td>发声半径</td>
</tr>
<tr>
<td>噪声系数</td>
<td>NoiseFactor</td>
<td>5</td>
<td>[0.2, 10.0]</td>
<td>综合噪声系数</td>
</tr>
<tr>
<td>噪声方差</td>
<td>NoiseStd</td>
<td>5</td>
<td>[0.1, 10.0]</td>
<td>高斯噪声方差</td>
</tr>
<tr>
<td>附着物类型</td>
<td>AttachmentType</td>
<td>Water</td>
<td>Mud</td>
<td>外部附着物类型, 会影响探测距离</td>
</tr>
<tr>
<td>探测距离(m)</td>
<td>Distance</td>
<td>5</td>
<td>[0.001,100.0]</td>
<td>最大的探测距离</td>
</tr>
<tr>
<td>间接距离</td>
<td>IndirectDistance</td>
<td>false</td>
<td></td>
<td>是否打开间接距离</td>
</tr>
<tr>
<td>脉冲时刻(毫秒)</td>
<td>PulseMoment</td>
<td>0</td>
<td>[0.0, 100.0]</td>
<td>发声脉冲的起始时刻</td>
</tr>
<tr>
<td>脉冲周期(毫秒)</td>
<td>PulsePeriod</td>
<td>100</td>
<td>[0.1, 100.0]</td>
<td>发声脉冲的周期</td>
</tr>
<tr>
<td>轮询</td>
<td>PollTurn</td>
<td>空</td>
<td>"01SR" 4个字符任意组合</td>
<td>脉冲发声时的工作方式</td>
</tr>
</tbody>
</table>
</section>
<section id="id20">
<h3>6.4.2 数据获取<a class="headerlink" href="#id20" title="Link to this heading"></a></h3>
<section id="id21">
<h4>6.4.2.1 磁盘保存<a class="headerlink" href="#id21" title="Link to this heading"></a></h4>
<p>开关设置方法和图像类似, 在 Game.ini 中添加如下内容:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[Sensor]</span>
<span class="na">UltrasonicSaved</span><span class="o">=</span><span class="s">true</span>
</pre></div>
</div>
<p>重启仿真软件, 点云数据即保存于:</p>
<ul class="simple">
<li><p>Windows 下:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">C:\Users\用户名\AppData\Roaming\tadsim\service_data\display\Saved\SensorData</span></code></p></li>
</ul>
</li>
<li><p>Ubuntu 下:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">/home/.config/tadsim/Display/Saved/SensorData</span></code></p></li>
</ul>
</li>
</ul>
</section>
<section id="id22">
<h4>6.4.2.2 PB 消息<a class="headerlink" href="#id22" title="Link to this heading"></a></h4>
<p>首先需要打开 Display 的 PB 广播功能, 在 Game.ini 中添加如下内容:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[Sensor]</span>
<span class="na">PublicMsg</span><span class="o">=</span><span class="s">true</span>
</pre></div>
</div>
<p>然后通过订阅系统的消息, 来获取传感器数据 .TOPIC 为 DISPLAYSENSOR_{id},  id 是算法 id, 通过 Display 模块的运行参数 -topicid 指定, 默认为 0.</p>
<p>参考图像示例代码, 从 PB 中获取到超声波的二进制 raw 数据, 然后再对 raw 数据进行反序列化.具体的 proto 定义格式采用 OSI 标准格式定义, 格式定义请参考:</p>
<p><a class="reference external" href="https://opensimulationinterface.github.io/open-simulation-interface/structosi3_1_1UltrasonicDetectionData.html">open_simulation_interface: osi3::UltrasonicDetectionData Struct Reference</a></p>
<table border="1" class="docutils">
<thead>
<tr>
<th>变量</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ultrasonic_sensor</td>
<td>UltrasonicDetectionData</td>
<td>每个传感器对应一个ultrasonic_sensor</td>
</tr>
<tr>
<td>header.measurement_time</td>
<td>Timestamp</td>
<td>radar时间戳</td>
</tr>
<tr>
<td>detection</td>
<td>UltrasonicDetection</td>
<td>仿真数据</td>
</tr>
<tr>
<td>detection[i].distance</td>
<td>double</td>
<td>距离</td>
</tr>
</tbody>
</table>
<p>detection 的 size, 直接距离时为 1, 间接距离为 2.</p>
</section>
</section>
<section id="id23">
<h3>6.4.3 轮询模式<a class="headerlink" href="#id23" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>轮询模式下, 原有的间接距离失效关闭</p></li>
<li><p>参与轮询的超声波, 将按照相同频率, 相同节拍计算.</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>关闭</td>
</tr>
<tr>
<td>1</td>
<td>正常工作, 能发能收</td>
</tr>
<tr>
<td>s</td>
<td>send只发声</td>
</tr>
<tr>
<td>r</td>
<td>receive只接收</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="id24">
<h2>6.5 真值传感器仿真<a class="headerlink" href="#id24" title="Link to this heading"></a></h2>
<p>TAD Sim 支持真值传感器仿真, 平台提供默认配置参数, 并支持各参数自定义配置功能, 真值传感器依赖 SensorTruth 模块.</p>
<div align="center"><img src="./_static/images/image236.png" alt="" width="700px"></div><br>
<p>下文列出了真值传感器仿真配置及数据获取详细信息.</p>
<section id="id25">
<h3>6.5.1 参数说明<a class="headerlink" href="#id25" title="Link to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th>范围</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>位置X(cm)</td>
<td>0</td>
<td>[-1000, 1000]</td>
<td>安装位置</td>
</tr>
<tr>
<td>位置Y(cm)</td>
<td>0</td>
<td>[-1000, 1000]</td>
<td>安装位置</td>
</tr>
<tr>
<td>位置Z(cm)</td>
<td>171</td>
<td>[0, 1000]</td>
<td>安装位置</td>
</tr>
<tr>
<td>旋转X(°)</td>
<td>0</td>
<td>[-180, 180]</td>
<td>安装角度</td>
</tr>
<tr>
<td>旋转Y(°)</td>
<td>0</td>
<td>[-180, 180]</td>
<td>安装角度</td>
</tr>
<tr>
<td>旋转Z(°)</td>
<td>0</td>
<td>[-180, 180]</td>
<td>安装角度</td>
</tr>
<tr>
<td>实例ID</td>
<td>0</td>
<td>-</td>
<td>当配置了多个SensorTruth时, 只有实例ID一致时, 才会被处理</td>
</tr>
<tr>
<td>垂直fov(°)</td>
<td>10</td>
<td>[0, 160]</td>
<td>雷达天线水平过滤范围, 请注意假设设置为10, 则代表探测范围为[-5,5]</td>
</tr>
<tr>
<td>水平fov(°)</td>
<td>20</td>
<td>[0, 160]</td>
<td>雷达天线水平过滤范围, 请注意假设设置为10, 则代表探测范围为[-5,5]</td>
</tr>
<tr>
<td>探测距离(m)</td>
<td>200</td>
<td>(0, 1000]</td>
<td>过滤半径</td>
</tr>
</tbody>
</table>
</section>
<section id="id26">
<h3>6.5.2 数据获取<a class="headerlink" href="#id26" title="Link to this heading"></a></h3>
<p>打开 SensotTruth 模块, 模块将广播过滤后的 traffic 消息 .Topic: <code class="docutils literal notranslate"><span class="pre">TXSIM_SENSOR_OBJECT</span></code>, 依赖camera、lidar、ultrasonic 传感器, 如果指定了 -device, topic 为 <code class="docutils literal notranslate"><span class="pre">TXSIM_SENSOR_OBJECT_{id}</span></code>.
详细信息见 <a class="reference internal" href="403.%E4%BB%BF%E7%9C%9F%E6%B6%88%E6%81%AF%E8%AF%B4%E6%98%8E.html#id1"><span class="std std-ref">403.仿真消息说明</span></a> 的定义.</p>
</section>
</section>
<section id="imu">
<h2>6.6 IMU 仿真<a class="headerlink" href="#imu" title="Link to this heading"></a></h2>
<p>TAD Sim 支持 IMU 仿真, 平台提供默认配置参数, 并支持各参数自定义配置功能.</p>
<div align="center"><img src="./_static/images/image237.png" alt="" width="700px"></div><br>
<section id="id27">
<h3>6.6.1 参数说明<a class="headerlink" href="#id27" title="Link to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th>范围</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>位置X(cm)</td>
<td>-154.1</td>
<td>[-1000, 1000]</td>
<td>安装位置, 坐标原点位于四轮中心的地面垂点</td>
</tr>
<tr>
<td>位置Y(cm)</td>
<td>0</td>
<td>[-1000, 1000]</td>
<td>安装位置, 坐标原点位于四轮中心的地面垂点</td>
</tr>
<tr>
<td>位置Z(cm)</td>
<td>58</td>
<td>[0, 1000]</td>
<td>安装位置, 坐标原点位于四轮中心的地面垂点</td>
</tr>
<tr>
<td>四元数</td>
<td>qx:0 <br> qy:0, <br> qz:-0.70710678118 <br> qw:0.70710678118</td>
<td>[-1, 1]</td>
<td>传感器姿态, Euler角按照zyx顺序计算生成</td>
</tr>
</tbody>
</table>
</section>
<section id="id28">
<h3>6.6.2 数据获取<a class="headerlink" href="#id28" title="Link to this heading"></a></h3>
<p>IMU 仿真数据的 topic 是 IMU_SIM, 对应的 proto 是 osi_imu.proto. 依赖 osi_version.proto 和 osi_common.proto.</p>
<p>用户可以通过以下方式获取数据:</p>
<ul class="simple">
<li><p>实时 subscribe IMU_SIM topic 可以获取 IMU 数据</p></li>
<li><p>使用数据记录及后处理功能可以生成 xlsx 格式的 IMU 数据, 详见”[仿真数据的记录和回放](#12. 仿真数据的记录和回放)”章节, 其中 post_process 需要加上 -i 选项.</p></li>
</ul>
</section>
</section>
<section id="id29">
<h2>6.7 鱼眼相机仿真<a class="headerlink" href="#id29" title="Link to this heading"></a></h2>
<p>TAD Sim 支持鱼眼摄像头仿真, 平台提供默认配置参数, 并支持各参数自定义配置功能, 鱼眼相机仿真依赖 Display 模块.</p>
<div align="center"><img src="./_static/images/image238.png" alt="" width="700px"></div><br>
<section id="id30">
<h3>6.7.1 参数说明<a class="headerlink" href="#id30" title="Link to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th>范围</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>位置X(cm)</td>
<td>0</td>
<td>[-1000, 1000]</td>
<td>安装位置, 坐标原点位于四轮中心的地面垂点</td>
</tr>
<tr>
<td>位置Y(cm)</td>
<td>0</td>
<td>[-1000, 1000]</td>
<td>安装位置, 坐标原点位于四轮中心的地面垂点</td>
</tr>
<tr>
<td>位置Z(cm)</td>
<td>171</td>
<td>[0, 1000]</td>
<td>安装位置, 坐标原点位于四轮中心的地面垂点</td>
</tr>
<tr>
<td>旋转X(°)</td>
<td>0</td>
<td>[-180, 180]</td>
<td>安装角度</td>
</tr>
<tr>
<td>旋转Y(°)</td>
<td>0</td>
<td>[-180, 180]</td>
<td>安装角度</td>
</tr>
<tr>
<td>旋转Z(°)</td>
<td>0</td>
<td>[-180, 180]</td>
<td>安装角度</td>
</tr>
<tr>
<td>实例ID</td>
<td>0</td>
<td>-</td>
<td>当配置了多个 display 时, 只有Display的实例ID一致时, 才会被处理</td>
</tr>
<tr>
<td>频率(Hz)</td>
<td>50</td>
<td>[0, 1000]</td>
<td>拍照频率</td>
</tr>
<tr>
<td>水平分辨率</td>
<td>1200</td>
<td>整数</td>
<td>图像尺寸, 像素</td>
</tr>
<tr>
<td>垂直分辨率</td>
<td>1080</td>
<td>整数</td>
<td>图像尺寸, 像素</td>
</tr>
<tr>
<td>细腻度</td>
<td>0</td>
<td>[-5.0, 5.0]</td>
<td>正数细腻, 负数粗糙.细腻会增加渲染负担</td>
</tr>
<tr>
<td>颜色模式</td>
<td>0</td>
<td>0彩色, 1黑白</td>
<td></td>
</tr>
<tr>
<td>模糊</td>
<td>0</td>
<td>[0, 1]</td>
<td>-</td>
</tr>
<tr>
<td>运动模糊</td>
<td>0</td>
<td>[0, 1]</td>
<td>-</td>
</tr>
<tr>
<td>光晕强度</td>
<td>0</td>
<td>[0, 1]</td>
<td>-</td>
</tr>
<tr>
<td>噪声强度</td>
<td>低</td>
<td>低/中/高/无</td>
<td>-</td>
</tr>
<tr>
<td>暗角</td>
<td>0.4</td>
<td>[0.0, 1.0]</td>
<td></td>
</tr>
<tr>
<td>泛光bloom</td>
<td>0.675</td>
<td>[0.0, 1.0]</td>
<td></td>
</tr>
<tr>
<td>曝光模式</td>
<td>0</td>
<td>自动0/手动1 (手动时:快门速度, ISO, 孔径参数有效)</td>
<td></td>
</tr>
<tr>
<td>曝光补偿</td>
<td>1</td>
<td>-15.0～15.0</td>
<td>曝光的对数2^n调整, 负值变暗, 正值加亮</td>
</tr>
<tr>
<td>色温</td>
<td>6500</td>
<td>1500～15000K</td>
<td>色温</td>
</tr>
<tr>
<td>白色调</td>
<td>0</td>
<td>-1.0～1.0</td>
<td></td>
</tr>
<tr>
<td>镜头透镜率</td>
<td>98</td>
<td>1.0～100.0%</td>
<td></td>
</tr>
<tr>
<td>畸变参数</td>
<td>0,0,0,0</td>
<td>分布表示k1,k2,k3,k4</td>
<td></td>
</tr>
<tr>
<td>内参矩阵</td>
<td>,,,0,,,0,0,1</td>
<td>长度为9的数组, 给出默认值的位置readonly, 其余位置值依次为fx, skew, cx, fy, cy.</td>
<td>内参形式只能为矩阵</td>
</tr>
</tbody>
</table>
</section>
<section id="id31">
<h3>6.7.2 数据获取<a class="headerlink" href="#id31" title="Link to this heading"></a></h3>
<section id="id32">
<h4>6.7.2.1 内存共享<a class="headerlink" href="#id32" title="Link to this heading"></a></h4>
<p>和 Camera 方法一致, 共享内存地址为 Tadsim_Fisheye_{cameraID}</p>
</section>
<section id="id33">
<h4>6.7.2.2 磁盘保存<a class="headerlink" href="#id33" title="Link to this heading"></a></h4>
<p>Game.ini 中添加如下内容:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[Sensor]</span>
<span class="na">FisheyeSaved</span><span class="o">=</span><span class="s">true</span>
</pre></div>
</div>
</section>
<section id="id34">
<h4>6.7.2.3 PB 消息<a class="headerlink" href="#id34" title="Link to this heading"></a></h4>
<p>同图像方法 (9.1.2.3 章节)</p>
</section>
</section>
</section>
<section id="id35">
<h2>6.8 语义相机仿真<a class="headerlink" href="#id35" title="Link to this heading"></a></h2>
<p>TAD Sim 支持语义相机仿真, 语义相机是在普通相机的基础上添加了 alpha 通道, 用于标记像素的类别.</p>
<p>平台提供默认配置参数, 并支持各参数自定义配置功能, 语义相机依赖 Display 模块.</p>
<div align="center"><img src="./_static/images/image239.png" alt="" width="700px"></div><br>
<section id="id36">
<h3>6.8.1 参数说明<a class="headerlink" href="#id36" title="Link to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th>范围</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>位置X(cm)</td>
<td>0</td>
<td>[-1000, 1000]</td>
<td>安装位置, 坐标原点位于四轮中心的地面垂点</td>
</tr>
<tr>
<td>位置Y(cm)</td>
<td>0</td>
<td>[-1000, 1000]</td>
<td>安装位置, 坐标原点位于四轮中心的地面垂点</td>
</tr>
<tr>
<td>位置Z(cm)</td>
<td>171</td>
<td>[0, 1000]</td>
<td>安装位置, 坐标原点位于四轮中心的地面垂点</td>
</tr>
<tr>
<td>旋转X(°)</td>
<td>0</td>
<td>[-180, 180]</td>
<td>安装角度</td>
</tr>
<tr>
<td>旋转Y(°)</td>
<td>0</td>
<td>[-180, 180]</td>
<td>安装角度</td>
</tr>
<tr>
<td>旋转Z(°)</td>
<td>0</td>
<td>[-180, 180]</td>
<td>安装角度</td>
</tr>
<tr>
<td>实例ID</td>
<td>0</td>
<td>-</td>
<td>当配置了多个 display 时, 只有Display的实例ID一致时, 才会被处理</td>
</tr>
<tr>
<td>频率(Hz)</td>
<td>25</td>
<td>[0, 1000]</td>
<td>拍照频率</td>
</tr>
<tr>
<td>水平分辨率</td>
<td>1920</td>
<td>整数</td>
<td>图像尺寸, 像素</td>
</tr>
<tr>
<td>垂直分辨率</td>
<td>1208</td>
<td>整数</td>
<td>图像尺寸, 像素</td>
</tr>
<tr>
<td>畸变参数</td>
<td>k1=-5.3336804278253547e-001, <br> k2=4.5773462092698042e-001, <br> k3=-4.8360765272003647e-001, <br> p1=-2.3929586859060227e-003, <br> p2=1.8364297357014352e-003</td>
<td></td>
<td>分布表示k1, k2, k3, p1, p2</td>
</tr>
<tr>
<td>内参形式</td>
<td>0</td>
<td>0:矩阵, 1:FOV, 2:感光器</td>
<td>-</td>
</tr>
<tr>
<td>内参矩阵</td>
<td>1.9451674168728503e+003,0, 9.4611889604089231e+002; <br> 0,1.9381372280069070e+003, 6.1970485474739780e+002; <br> 0,0,1</td>
<td>长度为9的数组,  <br> 给出默认值的位置readonly, <br>  其余位置值依次为fx, skew, cx, fy, cy.</td>
<td>当内参形式为矩阵时</td>
</tr>
<tr>
<td>水平FOV(°)</td>
<td>60</td>
<td>[0, 180]</td>
<td>当内参形式为fov时</td>
</tr>
<tr>
<td>垂直FOV(°)</td>
<td>36.28</td>
<td>[0, 180]</td>
<td>当内参形式为fov时</td>
</tr>
<tr>
<td>感光器宽度(mm)</td>
<td>10</td>
<td>(0, 10000]</td>
<td>当内参形式为感光器时</td>
</tr>
<tr>
<td>感光器高度(mm)</td>
<td>10</td>
<td>(0, 10000]</td>
<td>当内参形式为感光器时</td>
</tr>
<tr>
<td>镜头焦距(mm)</td>
<td>10</td>
<td>(0, 10000]</td>
<td>当内参形式为感光器时</td>
</tr>
</tbody>
</table>
</section>
<section id="id37">
<h3>6.8.2 数据获取<a class="headerlink" href="#id37" title="Link to this heading"></a></h3>
<section id="id38">
<h4>6.8.2.1 内存共享<a class="headerlink" href="#id38" title="Link to this heading"></a></h4>
<p>和 Camera 方法一致, 共享内存地址为 <code class="docutils literal notranslate"><span class="pre">Tadsim_Semantic_{cameraID}</span></code>.</p>
</section>
<section id="id39">
<h4>6.8.2.2 磁盘保存<a class="headerlink" href="#id39" title="Link to this heading"></a></h4>
<p>Game.ini中添加如下内容:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[Sensor]</span>
<span class="na">SemanticSaved</span><span class="o">=</span><span class="s">true</span>
</pre></div>
</div>
</section>
<section id="id40">
<h4>6.8.2.3 PB 消息<a class="headerlink" href="#id40" title="Link to this heading"></a></h4>
<p>同图像方法 (9.1.2.3 章节)</p>
</section>
</section>
</section>
<section id="id41">
<h2>6.9 深度相机仿真<a class="headerlink" href="#id41" title="Link to this heading"></a></h2>
<p>TAD Sim 支持深度相机仿真, 平台提供默认配置参数, 并支持各参数自定义配置功能, 深度相机依赖 Display 模块.</p>
<div align="center"><img src="./_static/images/image240.png" alt="" width="700px"></div><br>
<section id="id42">
<h3>6.9.1 参数说明<a class="headerlink" href="#id42" title="Link to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th>范围</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>位置X(cm)</td>
<td>0</td>
<td>[-1000, 1000]</td>
<td>安装位置, 坐标原点位于四轮中心的地面垂点</td>
</tr>
<tr>
<td>位置Y(cm)</td>
<td>0</td>
<td>[-1000, 1000]</td>
<td>安装位置, 坐标原点位于四轮中心的地面垂点</td>
</tr>
<tr>
<td>位置Z(cm)</td>
<td>171</td>
<td>[0, 1000]</td>
<td>安装位置, 坐标原点位于四轮中心的地面垂点</td>
</tr>
<tr>
<td>旋转X(°)</td>
<td>0</td>
<td>[-180, 180]</td>
<td>安装角度</td>
</tr>
<tr>
<td>旋转Y(°)</td>
<td>0</td>
<td>[-180, 180]</td>
<td>安装角度</td>
</tr>
<tr>
<td>旋转Z(°)</td>
<td>0</td>
<td>[-180, 180]</td>
<td>安装角度</td>
</tr>
<tr>
<td>实例ID</td>
<td>0</td>
<td>-</td>
<td>当配置了多个 display 时, 只有Display的实例ID一致时, 才会被处理</td>
</tr>
<tr>
<td>频率(Hz)</td>
<td>25</td>
<td>[0, 1000]</td>
<td>拍照频率</td>
</tr>
<tr>
<td>水平分辨率</td>
<td>1920</td>
<td>整数</td>
<td>图像尺寸, 像素</td>
</tr>
<tr>
<td>垂直分辨率</td>
<td>1208</td>
<td>整数</td>
<td>图像尺寸, 像素</td>
</tr>
<tr>
<td>畸变参数</td>
<td>k1=-5.3336804278253547e-001, <br> k2=4.5773462092698042e-001, <br> k3=-4.8360765272003647e-001, <br> p1=-2.3929586859060227e-003, <br> p2=1.8364297357014352e-003</td>
<td></td>
<td>分布表示k1,k2,k3,p1,p2</td>
</tr>
<tr>
<td>内参形式</td>
<td>0</td>
<td>0:矩阵, 1:FOV, 2:感光器</td>
<td>-</td>
</tr>
<tr>
<td>内参矩阵</td>
<td>1.9451674168728503e+003, 0, 9.4611889604089231e+002; <br> 0,1.9381372280069070e+003, 6.1970485474739780e+002; <br> 0,0,1</td>
<td>长度为9的数组,给出默认值的位置 readonly,其余位置值依次为fx, skew, cx, fy, cy.</td>
<td>当内参形式为矩阵时</td>
</tr>
<tr>
<td>水平FOV(°)</td>
<td>60</td>
<td>[0, 180]</td>
<td>当内参形式为 fov时</td>
</tr>
<tr>
<td>垂直FOV(°)</td>
<td>36.28</td>
<td>[0, 180]</td>
<td>当内参形式为fov时</td>
</tr>
<tr>
<td>感光器宽度(mm)</td>
<td>10</td>
<td>(0, 10000]</td>
<td>当内参形式为感光器时</td>
</tr>
<tr>
<td>感光器高度(mm)</td>
<td>10</td>
<td>(0, 10000]</td>
<td>当内参形式为感光器时</td>
</tr>
<tr>
<td>镜头焦距(mm)</td>
<td>10</td>
<td>(0, 10000]</td>
<td>当内参形式为感光器时</td>
</tr>
</tbody>
</table>
</section>
<section id="id43">
<h3>6.9.2 数据获取<a class="headerlink" href="#id43" title="Link to this heading"></a></h3>
<section id="id44">
<h4>6.9.2.1 内存共享<a class="headerlink" href="#id44" title="Link to this heading"></a></h4>
<p>和 Camera 方法一致, 共享内存地址为 Tadsim_Depth_{cameraID}</p>
</section>
<section id="id45">
<h4>6.9.2.1 磁盘保存<a class="headerlink" href="#id45" title="Link to this heading"></a></h4>
<p>Game.ini中添加如下内容:</p>
<div class="highlight-ini notranslate"><div class="highlight"><pre><span></span><span class="k">[Sensor]</span>
<span class="na">DepthSaved</span><span class="o">=</span><span class="s">true</span>
</pre></div>
</div>
</section>
<section id="id46">
<h4>6.9.2.3 PB 消息<a class="headerlink" href="#id46" title="Link to this heading"></a></h4>
<p>同图像方法 (9.1.2.3 章节)</p>
</section>
</section>
</section>
<section id="gps">
<h2>6.10 GPS 仿真<a class="headerlink" href="#gps" title="Link to this heading"></a></h2>
<p>TAD Sim 支持 GPS 仿真, 平台提供默认配置参数, 并支持各参数自定义配置功能.</p>
<div align="center"><img src="./_static/images/image241.png" alt="" width="700px"></div><br>
<p>下文列出了 GPS 仿真配置及数据获取详细信息.</p>
<section id="id47">
<h3>6.10.1. 参数说明<a class="headerlink" href="#id47" title="Link to this heading"></a></h3>
<table border="1" class="docutils">
<thead>
<tr>
<th>名称</th>
<th>默认值</th>
<th>范围</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>位置X(cm)</td>
<td>0</td>
<td>[-1000, 1000]</td>
<td>安装位置, 坐标原点位于四轮中心的地面垂点</td>
</tr>
<tr>
<td>位置Y(cm)</td>
<td>15.8</td>
<td>[-1000, 1000]</td>
<td>安装位置, 坐标原点位于四轮中心的地面垂点</td>
</tr>
<tr>
<td>位置Z(cm)</td>
<td>112.6</td>
<td>[0, 1000]</td>
<td>安装位置, 坐标原点位于四轮中心的地面垂点</td>
</tr>
</tbody>
</table>
</section>
<section id="id48">
<h3>6.10.2. 数据获取<a class="headerlink" href="#id48" title="Link to this heading"></a></h3>
<p>GPS 仿真数据的 topic 是 GPS_SIM, proto 文件为 osi_gps.proto. 依赖 osi_version.proto 和 osi_common.proto.</p>
<p>用户可以通过以下方式获取数据:</p>
<ul class="simple">
<li><p>实时 subscribe GPS_SIM topic 可以获取 GPS 数据</p></li>
<li><p>使用数据记录及后处理功能可以生成 xlsx 格式的 GPS 数据, 详见 “[仿真数据的记录和回放](#12. 仿真数据的记录和回放)” 章节, 其中 post_process 需要加上 <code class="docutils literal notranslate"><span class="pre">-i</span></code> 选项.</p></li>
</ul>
</section>
</section>
<section id="v2x">
<h2>6.11 V2X 仿真<a class="headerlink" href="#v2x" title="Link to this heading"></a></h2>
<p>TAD Sim 通过地图编辑器配置 RSU, 场景编辑器配置 OBU 进行 V2X 仿真, 平台提供默认配置参数, 并支持各参数自定义配置功能.</p>
<p>详细信息请查看 <a class="reference internal" href="307.V2X%E4%BB%BF%E7%9C%9F.html"><span class="std std-doc">10. V2X 仿真</span></a></p>
</section>
<section id="id49">
<h2>6.12 仿真合成数据生成<a class="headerlink" href="#id49" title="Link to this heading"></a></h2>
<p>在仿真过程中 TAD Sim 可为模拟对象(如车辆、行人、传感器数据等) 添加描述性信息, 实现该功能的模块为 simlabel, 其主要完成仿真数据的标注转换 (即将仿真数据转换为标注数据).</p>
<p>仿真系统可以用于生成自动驾驶标注数据, 这些数据对于训练和验证自动驾驶算法至关重要. 通过在仿真环境中创建各种交通场景, 可以收集大量有关车辆、行人、自行车等交通参与者的信息, 从而为自动驾驶系统提供丰富的训练数据.</p>
<p>详细信息请查看 <a class="reference internal" href="308.%E4%BB%BF%E7%9C%9F%E5%90%88%E6%88%90%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90.html"><span class="std std-doc">11. 仿真合成数据生成</span></a></p>
</section>
<section id="id50">
<h2>6.13 传感器依赖模块<a class="headerlink" href="#id50" title="Link to this heading"></a></h2>
<section id="display">
<h3>6.13.1 Display 模块<a class="headerlink" href="#display" title="Link to this heading"></a></h3>
<p><strong>可执行参数说明</strong></p>
<table border="1" class="docutils">
<thead>
<tr>
<th>参数</th>
<th>取值</th>
<th>含义</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>-name</td>
<td>模块名字, 默认 Display</td>
<td>模块名字</td>
<td>-name=Display</td>
</tr>
<tr>
<td>-mode</td>
<td>FrameAsync、FrameSync</td>
<td>同步和异步模式,同步模式: 帧率和 step 保持同步, 但在 Step 暂停时, 以极低帧率运行, 异步模式: 帧率和 step 无关, 画面以最大帧率渲染.</td>
<td>-mode=FrameAsync</td>
</tr>
<tr>
<td>UserDir</td>
<td>本地目录</td>
<td>日志目录</td>
<td>UserDir=xx/xx/x/</td>
</tr>
<tr>
<td>-address</td>
<td>TadsimServer</td>
<td>tadsim 地址, 缺省值为 127.0.0.1:21302</td>
<td>-address=192.168.0.1:21302</td>
</tr>
<tr>
<td>-device</td>
<td>数字或all(默认)</td>
<td>指定实例 id, 只有绑定到该id的传感器才被读取, 可以指定all, 表示所有传感器</td>
<td>-device=all</td>
</tr>
<tr>
<td>-topicId</td>
<td>数字</td>
<td>指定 Topicid, 设置传感器广播的topic为DISPLAYSENSOR_{id}, 如果没有设置, 等同于 -device</td>
<td>-topicId=3</td>
</tr>
<tr>
<td>-hil</td>
<td>屏幕像素坐标</td>
<td>设置 HIL 方式, 指定(所有屏幕组合的全局)坐标点, 即可在当前位置的屏幕内全屏</td>
<td>-hil=100x500</td>
</tr>
<tr>
<td>-graphicsadapter</td>
<td>自然数</td>
<td>指定特定 GPU, 从 0 开始, 即 0 表示 GPU0, Linux 平台的该参数需要打开息屏</td>
<td>-graphicsadapter=1</td>
</tr>
<tr>
<td>-RenderOffscreen</td>
<td></td>
<td>息屏渲染</td>
<td>-RenderOffscreen</td>
</tr>
<tr>
<td>-LocalLogTimes</td>
<td></td>
<td>日志时间使用当前时区</td>
<td>-LocalLogTimes</td>
</tr>
<tr>
<td>-log LOG</td>
<td>文件名</td>
<td>指定日志名称</td>
<td>-log LOG=Display.log</td>
</tr>
</tbody>
</table>
</section>
<section id="sensortruth">
<h3>6.13.2 SensorTruth 模块<a class="headerlink" href="#sensortruth" title="Link to this heading"></a></h3>
<p><strong>初始化参数说明</strong></p>
<table border="1" class="docutils">
<thead>
<tr>
<th>参数</th>
<th>取值</th>
<th>含义</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>CameraTruth</td>
<td>ON, OFF</td>
<td>开启图像真值子模块</td>
<td>CameraTruth=ON</td>
</tr>
<tr>
<td>LidarTruth</td>
<td>ON, OFF</td>
<td>开启lidar真值子模块</td>
<td>LidarTruth=ON</td>
</tr>
<tr>
<td>UltrasonicTruth</td>
<td>ON, OFF</td>
<td>开启超声波真值子模块</td>
<td>UltrasonicTruth=ON</td>
</tr>
<tr>
<td>SensorTruth</td>
<td>ON, OFF</td>
<td>开启目标真值子模块</td>
<td>SensorTruth=ON</td>
</tr>
<tr>
<td>DebugDir</td>
<td>路径</td>
<td>指定调试输出目录</td>
<td>DebugDir=XXX/XXX</td>
</tr>
<tr>
<td>-device</td>
<td>数字或all(默认)</td>
<td>指定实例 id, 只有绑定到该id的传感器才被读取, 可以指定all, 表示所有传感器</td>
<td>-device=all</td>
</tr>
<tr>
<td>CT_MaxDistance</td>
<td>米</td>
<td>相机目标最大距离</td>
<td>CT_MaxDistance=100.0</td>
</tr>
<tr>
<td>CT_Completeness</td>
<td>0~1</td>
<td>相机目标完整度, 被遮挡的面积比例不能小于该值</td>
<td>CT_Completeness=0.5</td>
</tr>
<tr>
<td>CT_MinArea</td>
<td>像素</td>
<td>相机目标的像素面积</td>
<td>CT_MinArea=20</td>
</tr>
<tr>
<td>LT_Completeness</td>
<td>0~1</td>
<td>Lidar 目标完整度, 被遮挡的激光数比例不能小于该值</td>
<td>LT_Completeness=0.5</td>
</tr>
<tr>
<td>LT_MinHitNum</td>
<td>大于0的整数</td>
<td>最小激光个数, 小于它的目标被丢弃</td>
<td>LT_MinHitNum=5</td>
</tr>
</tbody>
</table>
</section>
<section id="radar">
<h3>6.13.3 Radar 模块<a class="headerlink" href="#radar" title="Link to this heading"></a></h3>
<p>TAD Sim 支持 Radar 仿真, 平台提供默认配置参数, 并支持各参数自定义配置功能.</p>
<p><strong>初始化参数说明</strong></p>
<table border="1" class="docutils">
<thead>
<tr>
<th>参数</th>
<th>取值</th>
<th>含义</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>DebugDir</td>
<td>路径</td>
<td>调试输出目录</td>
<td>DebugDir=/XX/XX/</td>
</tr>
<tr>
<td>IgnoreZ</td>
<td>ON, OFF</td>
<td>忽略高程</td>
<td>IgnoreZ=ON</td>
</tr>
<tr>
<td>-device</td>
<td>数字<br>或<br>all(默认)</td>
<td>指定实例 id, 只有绑定到该 id 的传感器才被读取, 可以指定 all, 表示所有传感器</td>
<td>-device=all</td>
</tr>
</tbody>
</table>
</section>
<section id="imu-gps">
<h3>6.13.4 imu_gps 模块<a class="headerlink" href="#imu-gps" title="Link to this heading"></a></h3>
<p>TAD Sim 支持 GPS IMU 仿真, 平台提供默认配置参数, 并支持各参数自定义配置功能.</p>
<p><strong>初始化参数说明</strong></p>
<table border="1" class="docutils">
<thead>
<tr>
<th>参数</th>
<th>取值</th>
<th>含义</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>mode</td>
<td>imu 或 gps</td>
<td>分别表示 imu only, gps only</td>
<td>mode=imu</td>
</tr>
</tbody>
</table>
</section>
<section id="synthetic-data">
<h3>6.13.5 synthetic_data 模块<a class="headerlink" href="#synthetic-data" title="Link to this heading"></a></h3>
<p>TAD Sim 支持仿真标注数据生成, 平台提供默认配置参数, 并支持各参数自定义配置功能.</p>
<p><strong>初始化参数说明</strong></p>
<table border="1" class="docutils">
<thead>
<tr>
<th>参数</th>
<th>取值</th>
<th>含义</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>-device</td>
<td>数字<br>或<br>all(默认)</td>
<td>指定实例id, 只有绑定到该id的传感器才被读取, 可以指定all, 表示所有传感器</td>
<td>-device=all</td>
</tr>
<tr>
<td>CreateScenarioDir</td>
<td>true, false</td>
<td>是否创建场景目录, 默认 true, 在多个场景连续播放时, 防止数据被覆盖</td>
<td>CreateScenarioDir=false</td>
</tr>
<tr>
<td>NumOfDisplay</td>
<td>整数</td>
<td>Display 的个数, 用于分布式多个渲染引擎所有传感器的接收.</td>
<td>NumOfDisplay=30</td>
</tr>
<tr>
<td>DataSavePath</td>
<td>路径</td>
<td>保存目录路径</td>
<td>DataSavePath=<br>/home/sim/data/display_pic_dir</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>注: NumOfDisplay 一定要覆盖 Display 的 topic, simlabel 会订阅 DISPLAYSENSOR_{id}, 保证接收完整.</p>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="305.%E5%8A%A8%E5%8A%9B%E5%AD%A6%E4%BB%BF%E7%9C%9F.html" class="btn btn-neutral float-left" title="5. 动力学仿真" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="307.V2X%E4%BB%BF%E7%9C%9F.html" class="btn btn-neutral float-right" title="7. V2X仿真" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 Copyright (C) 2024 Tencent Inc.  All rights reserved。</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>