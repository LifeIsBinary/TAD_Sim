// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: moduleService.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_moduleService_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_moduleService_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "basic.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_moduleService_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_moduleService_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_moduleService_2eproto;
namespace sim_msg {
class ErrorStatus;
class ErrorStatusDefaultTypeInternal;
extern ErrorStatusDefaultTypeInternal _ErrorStatus_default_instance_;
class InitParams;
class InitParamsDefaultTypeInternal;
extern InitParamsDefaultTypeInternal _InitParams_default_instance_;
class InitParams_ParamsEntry_DoNotUse;
class InitParams_ParamsEntry_DoNotUseDefaultTypeInternal;
extern InitParams_ParamsEntry_DoNotUseDefaultTypeInternal _InitParams_ParamsEntry_DoNotUse_default_instance_;
class InitResult;
class InitResultDefaultTypeInternal;
extern InitResultDefaultTypeInternal _InitResult_default_instance_;
class ResetParams;
class ResetParamsDefaultTypeInternal;
extern ResetParamsDefaultTypeInternal _ResetParams_default_instance_;
class SimMessage;
class SimMessageDefaultTypeInternal;
extern SimMessageDefaultTypeInternal _SimMessage_default_instance_;
class SimMessage_MessagesEntry_DoNotUse;
class SimMessage_MessagesEntry_DoNotUseDefaultTypeInternal;
extern SimMessage_MessagesEntry_DoNotUseDefaultTypeInternal _SimMessage_MessagesEntry_DoNotUse_default_instance_;
class StepResult;
class StepResultDefaultTypeInternal;
extern StepResultDefaultTypeInternal _StepResult_default_instance_;
class StopResult;
class StopResultDefaultTypeInternal;
extern StopResultDefaultTypeInternal _StopResult_default_instance_;
class StopResult_FeedbackEntry_DoNotUse;
class StopResult_FeedbackEntry_DoNotUseDefaultTypeInternal;
extern StopResult_FeedbackEntry_DoNotUseDefaultTypeInternal _StopResult_FeedbackEntry_DoNotUse_default_instance_;
class TopicList;
class TopicListDefaultTypeInternal;
extern TopicListDefaultTypeInternal _TopicList_default_instance_;
}  // namespace sim_msg
PROTOBUF_NAMESPACE_OPEN
template<> ::sim_msg::ErrorStatus* Arena::CreateMaybeMessage<::sim_msg::ErrorStatus>(Arena*);
template<> ::sim_msg::InitParams* Arena::CreateMaybeMessage<::sim_msg::InitParams>(Arena*);
template<> ::sim_msg::InitParams_ParamsEntry_DoNotUse* Arena::CreateMaybeMessage<::sim_msg::InitParams_ParamsEntry_DoNotUse>(Arena*);
template<> ::sim_msg::InitResult* Arena::CreateMaybeMessage<::sim_msg::InitResult>(Arena*);
template<> ::sim_msg::ResetParams* Arena::CreateMaybeMessage<::sim_msg::ResetParams>(Arena*);
template<> ::sim_msg::SimMessage* Arena::CreateMaybeMessage<::sim_msg::SimMessage>(Arena*);
template<> ::sim_msg::SimMessage_MessagesEntry_DoNotUse* Arena::CreateMaybeMessage<::sim_msg::SimMessage_MessagesEntry_DoNotUse>(Arena*);
template<> ::sim_msg::StepResult* Arena::CreateMaybeMessage<::sim_msg::StepResult>(Arena*);
template<> ::sim_msg::StopResult* Arena::CreateMaybeMessage<::sim_msg::StopResult>(Arena*);
template<> ::sim_msg::StopResult_FeedbackEntry_DoNotUse* Arena::CreateMaybeMessage<::sim_msg::StopResult_FeedbackEntry_DoNotUse>(Arena*);
template<> ::sim_msg::TopicList* Arena::CreateMaybeMessage<::sim_msg::TopicList>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sim_msg {

enum Topic : int {
  LOCATION = 0,
  TRAFFIC = 1,
  TRAJECTORY = 2,
  PLAN_OUTPUT = 3,
  CONTROL = 4,
  IBEO_DATA = 5,
  LANE_MARKS = 6,
  LOCAL_LOCATION = 7,
  GRADING = 8,
  PLAN_DEBUG_INFO = 9,
  GROUND_TRUTH = 10,
  CAMERA_SENSOR_VIEW = 11,
  GT_SENSOR_DATA = 12,
  PLAN_STATUS = 13,
  L3_STATE_MACHINE = 14,
  L3_SYSTEM_STATE = 15,
  EGO_TRAFFIC = 16,
  VEHICLE_STATE = 17,
  Topic_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Topic_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Topic_IsValid(int value);
constexpr Topic Topic_MIN = LOCATION;
constexpr Topic Topic_MAX = VEHICLE_STATE;
constexpr int Topic_ARRAYSIZE = Topic_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Topic_descriptor();
template<typename T>
inline const std::string& Topic_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Topic>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Topic_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Topic_descriptor(), enum_t_value);
}
inline bool Topic_Parse(
    const std::string& name, Topic* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Topic>(
    Topic_descriptor(), name, value);
}
enum ErrorCode : int {
  SUCCESS = 0,
  MODULE_STOP = 1,
  ERROR_INIT = 2,
  ERROR_RESET = 3,
  ERROR_STEP = 4,
  ERROR_STOP = 5,
  ERROR_NOT_INIT = 6,
  ERROR_MULTI_CONNECT = 7,
  ERROR_CONNECT = 8,
  ERROR_INVALID_CAR = 9,
  ERROR_NOT_BELONG = 10,
  ERROR_UNKNOWN = 11,
  ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ErrorCode_IsValid(int value);
constexpr ErrorCode ErrorCode_MIN = SUCCESS;
constexpr ErrorCode ErrorCode_MAX = ERROR_UNKNOWN;
constexpr int ErrorCode_ARRAYSIZE = ErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ErrorCode_descriptor();
template<typename T>
inline const std::string& ErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ErrorCode_descriptor(), enum_t_value);
}
inline bool ErrorCode_Parse(
    const std::string& name, ErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ErrorCode>(
    ErrorCode_descriptor(), name, value);
}
// ===================================================================

class ErrorStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.ErrorStatus) */ {
 public:
  ErrorStatus();
  virtual ~ErrorStatus();

  ErrorStatus(const ErrorStatus& from);
  ErrorStatus(ErrorStatus&& from) noexcept
    : ErrorStatus() {
    *this = ::std::move(from);
  }

  inline ErrorStatus& operator=(const ErrorStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorStatus& operator=(ErrorStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ErrorStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ErrorStatus* internal_default_instance() {
    return reinterpret_cast<const ErrorStatus*>(
               &_ErrorStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ErrorStatus& a, ErrorStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ErrorStatus* New() const final {
    return CreateMaybeMessage<ErrorStatus>(nullptr);
  }

  ErrorStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ErrorStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ErrorStatus& from);
  void MergeFrom(const ErrorStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.ErrorStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_moduleService_2eproto);
    return ::descriptor_table_moduleService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kErrorCodeFieldNumber = 1,
  };
  // string errorMessage = 2;
  void clear_errormessage();
  const std::string& errormessage() const;
  void set_errormessage(const std::string& value);
  void set_errormessage(std::string&& value);
  void set_errormessage(const char* value);
  void set_errormessage(const char* value, size_t size);
  std::string* mutable_errormessage();
  std::string* release_errormessage();
  void set_allocated_errormessage(std::string* errormessage);

  // .sim_msg.ErrorCode errorCode = 1;
  void clear_errorcode();
  ::sim_msg::ErrorCode errorcode() const;
  void set_errorcode(::sim_msg::ErrorCode value);

  // @@protoc_insertion_point(class_scope:sim_msg.ErrorStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormessage_;
  int errorcode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_moduleService_2eproto;
};
// -------------------------------------------------------------------

class InitParams_ParamsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InitParams_ParamsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InitParams_ParamsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  InitParams_ParamsEntry_DoNotUse();
  InitParams_ParamsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const InitParams_ParamsEntry_DoNotUse& other);
  static const InitParams_ParamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const InitParams_ParamsEntry_DoNotUse*>(&_InitParams_ParamsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sim_msg.InitParams.ParamsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sim_msg.InitParams.ParamsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_moduleService_2eproto);
    return ::descriptor_table_moduleService_2eproto.file_level_metadata[1];
  }

  public:
};

// -------------------------------------------------------------------

class InitParams :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.InitParams) */ {
 public:
  InitParams();
  virtual ~InitParams();

  InitParams(const InitParams& from);
  InitParams(InitParams&& from) noexcept
    : InitParams() {
    *this = ::std::move(from);
  }

  inline InitParams& operator=(const InitParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitParams& operator=(InitParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InitParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitParams* internal_default_instance() {
    return reinterpret_cast<const InitParams*>(
               &_InitParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InitParams& a, InitParams& b) {
    a.Swap(&b);
  }
  inline void Swap(InitParams* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InitParams* New() const final {
    return CreateMaybeMessage<InitParams>(nullptr);
  }

  InitParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InitParams>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InitParams& from);
  void MergeFrom(const InitParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitParams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.InitParams";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_moduleService_2eproto);
    return ::descriptor_table_moduleService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 1,
  };
  // map<string, string> params = 1;
  int params_size() const;
  void clear_params();
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      params() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_params();

  // @@protoc_insertion_point(class_scope:sim_msg.InitParams)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      InitParams_ParamsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > params_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_moduleService_2eproto;
};
// -------------------------------------------------------------------

class TopicList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.TopicList) */ {
 public:
  TopicList();
  virtual ~TopicList();

  TopicList(const TopicList& from);
  TopicList(TopicList&& from) noexcept
    : TopicList() {
    *this = ::std::move(from);
  }

  inline TopicList& operator=(const TopicList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TopicList& operator=(TopicList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TopicList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TopicList* internal_default_instance() {
    return reinterpret_cast<const TopicList*>(
               &_TopicList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TopicList& a, TopicList& b) {
    a.Swap(&b);
  }
  inline void Swap(TopicList* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TopicList* New() const final {
    return CreateMaybeMessage<TopicList>(nullptr);
  }

  TopicList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TopicList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TopicList& from);
  void MergeFrom(const TopicList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TopicList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.TopicList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_moduleService_2eproto);
    return ::descriptor_table_moduleService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicFieldNumber = 1,
  };
  // repeated .sim_msg.Topic topic = 1;
  int topic_size() const;
  void clear_topic();
  ::sim_msg::Topic topic(int index) const;
  void set_topic(int index, ::sim_msg::Topic value);
  void add_topic(::sim_msg::Topic value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& topic() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_topic();

  // @@protoc_insertion_point(class_scope:sim_msg.TopicList)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> topic_;
  mutable std::atomic<int> _topic_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_moduleService_2eproto;
};
// -------------------------------------------------------------------

class InitResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.InitResult) */ {
 public:
  InitResult();
  virtual ~InitResult();

  InitResult(const InitResult& from);
  InitResult(InitResult&& from) noexcept
    : InitResult() {
    *this = ::std::move(from);
  }

  inline InitResult& operator=(const InitResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitResult& operator=(InitResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InitResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitResult* internal_default_instance() {
    return reinterpret_cast<const InitResult*>(
               &_InitResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(InitResult& a, InitResult& b) {
    a.Swap(&b);
  }
  inline void Swap(InitResult* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InitResult* New() const final {
    return CreateMaybeMessage<InitResult>(nullptr);
  }

  InitResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InitResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InitResult& from);
  void MergeFrom(const InitResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.InitResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_moduleService_2eproto);
    return ::descriptor_table_moduleService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStrTopicsFieldNumber = 3,
    kTopicsFieldNumber = 1,
    kErrorStatusFieldNumber = 2,
  };
  // repeated string str_topics = 3;
  int str_topics_size() const;
  void clear_str_topics();
  const std::string& str_topics(int index) const;
  std::string* mutable_str_topics(int index);
  void set_str_topics(int index, const std::string& value);
  void set_str_topics(int index, std::string&& value);
  void set_str_topics(int index, const char* value);
  void set_str_topics(int index, const char* value, size_t size);
  std::string* add_str_topics();
  void add_str_topics(const std::string& value);
  void add_str_topics(std::string&& value);
  void add_str_topics(const char* value);
  void add_str_topics(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& str_topics() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_str_topics();

  // .sim_msg.TopicList topics = 1;
  bool has_topics() const;
  void clear_topics();
  const ::sim_msg::TopicList& topics() const;
  ::sim_msg::TopicList* release_topics();
  ::sim_msg::TopicList* mutable_topics();
  void set_allocated_topics(::sim_msg::TopicList* topics);

  // .sim_msg.ErrorStatus errorStatus = 2;
  bool has_errorstatus() const;
  void clear_errorstatus();
  const ::sim_msg::ErrorStatus& errorstatus() const;
  ::sim_msg::ErrorStatus* release_errorstatus();
  ::sim_msg::ErrorStatus* mutable_errorstatus();
  void set_allocated_errorstatus(::sim_msg::ErrorStatus* errorstatus);

  // @@protoc_insertion_point(class_scope:sim_msg.InitResult)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> str_topics_;
  ::sim_msg::TopicList* topics_;
  ::sim_msg::ErrorStatus* errorstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_moduleService_2eproto;
};
// -------------------------------------------------------------------

class ResetParams :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.ResetParams) */ {
 public:
  ResetParams();
  virtual ~ResetParams();

  ResetParams(const ResetParams& from);
  ResetParams(ResetParams&& from) noexcept
    : ResetParams() {
    *this = ::std::move(from);
  }

  inline ResetParams& operator=(const ResetParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetParams& operator=(ResetParams&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResetParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResetParams* internal_default_instance() {
    return reinterpret_cast<const ResetParams*>(
               &_ResetParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ResetParams& a, ResetParams& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetParams* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResetParams* New() const final {
    return CreateMaybeMessage<ResetParams>(nullptr);
  }

  ResetParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResetParams>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResetParams& from);
  void MergeFrom(const ResetParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetParams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.ResetParams";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_moduleService_2eproto);
    return ::descriptor_table_moduleService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGeoFenceFieldNumber = 18,
    kEgoPathFieldNumber = 19,
    kScenarioPathFieldNumber = 1,
    kHadmapPathFieldNumber = 2,
    kRosbagFilePathFieldNumber = 12,
    kStartPosFieldNumber = 3,
    kEndPosFieldNumber = 4,
    kLocalOriginFieldNumber = 13,
    kStartVelFieldNumber = 5,
    kMaxVelFieldNumber = 6,
    kThetaFieldNumber = 7,
    kSpeedLimitMaxFieldNumber = 8,
    kSpeedLimitMinFieldNumber = 9,
    kAccelerationLimitMaxFieldNumber = 10,
    kAccelerationLimitMinFieldNumber = 11,
    kTimeheadwayMinFieldNumber = 14,
    kJobIdFieldNumber = 15,
    kSceneIdFieldNumber = 16,
    kEgoIdFieldNumber = 17,
  };
  // repeated .sim_msg.Vec2 geo_fence = 18;
  int geo_fence_size() const;
  void clear_geo_fence();
  ::sim_msg::Vec2* mutable_geo_fence(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Vec2 >*
      mutable_geo_fence();
  const ::sim_msg::Vec2& geo_fence(int index) const;
  ::sim_msg::Vec2* add_geo_fence();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Vec2 >&
      geo_fence() const;

  // repeated .sim_msg.Vec3 ego_path = 19;
  int ego_path_size() const;
  void clear_ego_path();
  ::sim_msg::Vec3* mutable_ego_path(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Vec3 >*
      mutable_ego_path();
  const ::sim_msg::Vec3& ego_path(int index) const;
  ::sim_msg::Vec3* add_ego_path();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Vec3 >&
      ego_path() const;

  // string scenarioPath = 1;
  void clear_scenariopath();
  const std::string& scenariopath() const;
  void set_scenariopath(const std::string& value);
  void set_scenariopath(std::string&& value);
  void set_scenariopath(const char* value);
  void set_scenariopath(const char* value, size_t size);
  std::string* mutable_scenariopath();
  std::string* release_scenariopath();
  void set_allocated_scenariopath(std::string* scenariopath);

  // string hadmapPath = 2;
  void clear_hadmappath();
  const std::string& hadmappath() const;
  void set_hadmappath(const std::string& value);
  void set_hadmappath(std::string&& value);
  void set_hadmappath(const char* value);
  void set_hadmappath(const char* value, size_t size);
  std::string* mutable_hadmappath();
  std::string* release_hadmappath();
  void set_allocated_hadmappath(std::string* hadmappath);

  // string rosbagFilePath = 12;
  void clear_rosbagfilepath();
  const std::string& rosbagfilepath() const;
  void set_rosbagfilepath(const std::string& value);
  void set_rosbagfilepath(std::string&& value);
  void set_rosbagfilepath(const char* value);
  void set_rosbagfilepath(const char* value, size_t size);
  std::string* mutable_rosbagfilepath();
  std::string* release_rosbagfilepath();
  void set_allocated_rosbagfilepath(std::string* rosbagfilepath);

  // .sim_msg.Vec3 startPos = 3;
  bool has_startpos() const;
  void clear_startpos();
  const ::sim_msg::Vec3& startpos() const;
  ::sim_msg::Vec3* release_startpos();
  ::sim_msg::Vec3* mutable_startpos();
  void set_allocated_startpos(::sim_msg::Vec3* startpos);

  // .sim_msg.Vec3 endPos = 4;
  bool has_endpos() const;
  void clear_endpos();
  const ::sim_msg::Vec3& endpos() const;
  ::sim_msg::Vec3* release_endpos();
  ::sim_msg::Vec3* mutable_endpos();
  void set_allocated_endpos(::sim_msg::Vec3* endpos);

  // .sim_msg.Vec3 localOrigin = 13;
  bool has_localorigin() const;
  void clear_localorigin();
  const ::sim_msg::Vec3& localorigin() const;
  ::sim_msg::Vec3* release_localorigin();
  ::sim_msg::Vec3* mutable_localorigin();
  void set_allocated_localorigin(::sim_msg::Vec3* localorigin);

  // double startVel = 5;
  void clear_startvel();
  double startvel() const;
  void set_startvel(double value);

  // double maxVel = 6;
  void clear_maxvel();
  double maxvel() const;
  void set_maxvel(double value);

  // double theta = 7;
  void clear_theta();
  double theta() const;
  void set_theta(double value);

  // double speedLimit_Max = 8;
  void clear_speedlimit_max();
  double speedlimit_max() const;
  void set_speedlimit_max(double value);

  // double speedLimit_Min = 9;
  void clear_speedlimit_min();
  double speedlimit_min() const;
  void set_speedlimit_min(double value);

  // double accelerationLimit_Max = 10;
  void clear_accelerationlimit_max();
  double accelerationlimit_max() const;
  void set_accelerationlimit_max(double value);

  // double accelerationLimit_Min = 11;
  void clear_accelerationlimit_min();
  double accelerationlimit_min() const;
  void set_accelerationlimit_min(double value);

  // double timeheadway_Min = 14;
  void clear_timeheadway_min();
  double timeheadway_min() const;
  void set_timeheadway_min(double value);

  // int32 job_id = 15;
  void clear_job_id();
  ::PROTOBUF_NAMESPACE_ID::int32 job_id() const;
  void set_job_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 scene_id = 16;
  void clear_scene_id();
  ::PROTOBUF_NAMESPACE_ID::int32 scene_id() const;
  void set_scene_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // int32 ego_id = 17;
  void clear_ego_id();
  ::PROTOBUF_NAMESPACE_ID::int32 ego_id() const;
  void set_ego_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:sim_msg.ResetParams)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Vec2 > geo_fence_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Vec3 > ego_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scenariopath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hadmappath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rosbagfilepath_;
  ::sim_msg::Vec3* startpos_;
  ::sim_msg::Vec3* endpos_;
  ::sim_msg::Vec3* localorigin_;
  double startvel_;
  double maxvel_;
  double theta_;
  double speedlimit_max_;
  double speedlimit_min_;
  double accelerationlimit_max_;
  double accelerationlimit_min_;
  double timeheadway_min_;
  ::PROTOBUF_NAMESPACE_ID::int32 job_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 scene_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 ego_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_moduleService_2eproto;
};
// -------------------------------------------------------------------

class SimMessage_MessagesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SimMessage_MessagesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SimMessage_MessagesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES,
    0 > SuperType;
  SimMessage_MessagesEntry_DoNotUse();
  SimMessage_MessagesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SimMessage_MessagesEntry_DoNotUse& other);
  static const SimMessage_MessagesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SimMessage_MessagesEntry_DoNotUse*>(&_SimMessage_MessagesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sim_msg.SimMessage.MessagesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_moduleService_2eproto);
    return ::descriptor_table_moduleService_2eproto.file_level_metadata[6];
  }

  public:
};

// -------------------------------------------------------------------

class SimMessage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.SimMessage) */ {
 public:
  SimMessage();
  virtual ~SimMessage();

  SimMessage(const SimMessage& from);
  SimMessage(SimMessage&& from) noexcept
    : SimMessage() {
    *this = ::std::move(from);
  }

  inline SimMessage& operator=(const SimMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimMessage& operator=(SimMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimMessage* internal_default_instance() {
    return reinterpret_cast<const SimMessage*>(
               &_SimMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SimMessage& a, SimMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SimMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimMessage* New() const final {
    return CreateMaybeMessage<SimMessage>(nullptr);
  }

  SimMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimMessage& from);
  void MergeFrom(const SimMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.SimMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_moduleService_2eproto);
    return ::descriptor_table_moduleService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 1,
    kFrameIdFieldNumber = 2,
    kTimeStampFieldNumber = 3,
  };
  // map<string, bytes> messages = 1;
  int messages_size() const;
  void clear_messages();
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      messages() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_messages();

  // uint64 frameId = 2;
  void clear_frameid();
  ::PROTOBUF_NAMESPACE_ID::uint64 frameid() const;
  void set_frameid(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // double timeStamp = 3;
  void clear_timestamp();
  double timestamp() const;
  void set_timestamp(double value);

  // @@protoc_insertion_point(class_scope:sim_msg.SimMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      SimMessage_MessagesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES,
      0 > messages_;
  ::PROTOBUF_NAMESPACE_ID::uint64 frameid_;
  double timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_moduleService_2eproto;
};
// -------------------------------------------------------------------

class StepResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.StepResult) */ {
 public:
  StepResult();
  virtual ~StepResult();

  StepResult(const StepResult& from);
  StepResult(StepResult&& from) noexcept
    : StepResult() {
    *this = ::std::move(from);
  }

  inline StepResult& operator=(const StepResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline StepResult& operator=(StepResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StepResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StepResult* internal_default_instance() {
    return reinterpret_cast<const StepResult*>(
               &_StepResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StepResult& a, StepResult& b) {
    a.Swap(&b);
  }
  inline void Swap(StepResult* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StepResult* New() const final {
    return CreateMaybeMessage<StepResult>(nullptr);
  }

  StepResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StepResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StepResult& from);
  void MergeFrom(const StepResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StepResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.StepResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_moduleService_2eproto);
    return ::descriptor_table_moduleService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kErrorStatusFieldNumber = 2,
    kTimeCostFieldNumber = 3,
  };
  // .sim_msg.SimMessage result = 1;
  bool has_result() const;
  void clear_result();
  const ::sim_msg::SimMessage& result() const;
  ::sim_msg::SimMessage* release_result();
  ::sim_msg::SimMessage* mutable_result();
  void set_allocated_result(::sim_msg::SimMessage* result);

  // .sim_msg.ErrorStatus errorStatus = 2;
  bool has_errorstatus() const;
  void clear_errorstatus();
  const ::sim_msg::ErrorStatus& errorstatus() const;
  ::sim_msg::ErrorStatus* release_errorstatus();
  ::sim_msg::ErrorStatus* mutable_errorstatus();
  void set_allocated_errorstatus(::sim_msg::ErrorStatus* errorstatus);

  // double timeCost = 3;
  void clear_timecost();
  double timecost() const;
  void set_timecost(double value);

  // @@protoc_insertion_point(class_scope:sim_msg.StepResult)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::sim_msg::SimMessage* result_;
  ::sim_msg::ErrorStatus* errorstatus_;
  double timecost_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_moduleService_2eproto;
};
// -------------------------------------------------------------------

class StopResult_FeedbackEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StopResult_FeedbackEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StopResult_FeedbackEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  StopResult_FeedbackEntry_DoNotUse();
  StopResult_FeedbackEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const StopResult_FeedbackEntry_DoNotUse& other);
  static const StopResult_FeedbackEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StopResult_FeedbackEntry_DoNotUse*>(&_StopResult_FeedbackEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sim_msg.StopResult.FeedbackEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sim_msg.StopResult.FeedbackEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_moduleService_2eproto);
    return ::descriptor_table_moduleService_2eproto.file_level_metadata[9];
  }

  public:
};

// -------------------------------------------------------------------

class StopResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.StopResult) */ {
 public:
  StopResult();
  virtual ~StopResult();

  StopResult(const StopResult& from);
  StopResult(StopResult&& from) noexcept
    : StopResult() {
    *this = ::std::move(from);
  }

  inline StopResult& operator=(const StopResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopResult& operator=(StopResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StopResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopResult* internal_default_instance() {
    return reinterpret_cast<const StopResult*>(
               &_StopResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StopResult& a, StopResult& b) {
    a.Swap(&b);
  }
  inline void Swap(StopResult* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopResult* New() const final {
    return CreateMaybeMessage<StopResult>(nullptr);
  }

  StopResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StopResult& from);
  void MergeFrom(const StopResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.StopResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_moduleService_2eproto);
    return ::descriptor_table_moduleService_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kFeedbackFieldNumber = 1,
    kErrorStatusFieldNumber = 2,
  };
  // map<string, string> feedback = 1;
  int feedback_size() const;
  void clear_feedback();
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      feedback() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_feedback();

  // .sim_msg.ErrorStatus errorStatus = 2;
  bool has_errorstatus() const;
  void clear_errorstatus();
  const ::sim_msg::ErrorStatus& errorstatus() const;
  ::sim_msg::ErrorStatus* release_errorstatus();
  ::sim_msg::ErrorStatus* mutable_errorstatus();
  void set_allocated_errorstatus(::sim_msg::ErrorStatus* errorstatus);

  // @@protoc_insertion_point(class_scope:sim_msg.StopResult)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      StopResult_FeedbackEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > feedback_;
  ::sim_msg::ErrorStatus* errorstatus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_moduleService_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ErrorStatus

// .sim_msg.ErrorCode errorCode = 1;
inline void ErrorStatus::clear_errorcode() {
  errorcode_ = 0;
}
inline ::sim_msg::ErrorCode ErrorStatus::errorcode() const {
  // @@protoc_insertion_point(field_get:sim_msg.ErrorStatus.errorCode)
  return static_cast< ::sim_msg::ErrorCode >(errorcode_);
}
inline void ErrorStatus::set_errorcode(::sim_msg::ErrorCode value) {
  
  errorcode_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ErrorStatus.errorCode)
}

// string errorMessage = 2;
inline void ErrorStatus::clear_errormessage() {
  errormessage_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ErrorStatus::errormessage() const {
  // @@protoc_insertion_point(field_get:sim_msg.ErrorStatus.errorMessage)
  return errormessage_.GetNoArena();
}
inline void ErrorStatus::set_errormessage(const std::string& value) {
  
  errormessage_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.ErrorStatus.errorMessage)
}
inline void ErrorStatus::set_errormessage(std::string&& value) {
  
  errormessage_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.ErrorStatus.errorMessage)
}
inline void ErrorStatus::set_errormessage(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  errormessage_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.ErrorStatus.errorMessage)
}
inline void ErrorStatus::set_errormessage(const char* value, size_t size) {
  
  errormessage_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.ErrorStatus.errorMessage)
}
inline std::string* ErrorStatus::mutable_errormessage() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.ErrorStatus.errorMessage)
  return errormessage_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ErrorStatus::release_errormessage() {
  // @@protoc_insertion_point(field_release:sim_msg.ErrorStatus.errorMessage)
  
  return errormessage_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ErrorStatus::set_allocated_errormessage(std::string* errormessage) {
  if (errormessage != nullptr) {
    
  } else {
    
  }
  errormessage_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errormessage);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.ErrorStatus.errorMessage)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// InitParams

// map<string, string> params = 1;
inline int InitParams::params_size() const {
  return params_.size();
}
inline void InitParams::clear_params() {
  params_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
InitParams::params() const {
  // @@protoc_insertion_point(field_map:sim_msg.InitParams.params)
  return params_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
InitParams::mutable_params() {
  // @@protoc_insertion_point(field_mutable_map:sim_msg.InitParams.params)
  return params_.MutableMap();
}

// -------------------------------------------------------------------

// TopicList

// repeated .sim_msg.Topic topic = 1;
inline int TopicList::topic_size() const {
  return topic_.size();
}
inline void TopicList::clear_topic() {
  topic_.Clear();
}
inline ::sim_msg::Topic TopicList::topic(int index) const {
  // @@protoc_insertion_point(field_get:sim_msg.TopicList.topic)
  return static_cast< ::sim_msg::Topic >(topic_.Get(index));
}
inline void TopicList::set_topic(int index, ::sim_msg::Topic value) {
  topic_.Set(index, value);
  // @@protoc_insertion_point(field_set:sim_msg.TopicList.topic)
}
inline void TopicList::add_topic(::sim_msg::Topic value) {
  topic_.Add(value);
  // @@protoc_insertion_point(field_add:sim_msg.TopicList.topic)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
TopicList::topic() const {
  // @@protoc_insertion_point(field_list:sim_msg.TopicList.topic)
  return topic_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TopicList::mutable_topic() {
  // @@protoc_insertion_point(field_mutable_list:sim_msg.TopicList.topic)
  return &topic_;
}

// -------------------------------------------------------------------

// InitResult

// .sim_msg.TopicList topics = 1;
inline bool InitResult::has_topics() const {
  return this != internal_default_instance() && topics_ != nullptr;
}
inline void InitResult::clear_topics() {
  if (GetArenaNoVirtual() == nullptr && topics_ != nullptr) {
    delete topics_;
  }
  topics_ = nullptr;
}
inline const ::sim_msg::TopicList& InitResult::topics() const {
  const ::sim_msg::TopicList* p = topics_;
  // @@protoc_insertion_point(field_get:sim_msg.InitResult.topics)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::TopicList*>(
      &::sim_msg::_TopicList_default_instance_);
}
inline ::sim_msg::TopicList* InitResult::release_topics() {
  // @@protoc_insertion_point(field_release:sim_msg.InitResult.topics)
  
  ::sim_msg::TopicList* temp = topics_;
  topics_ = nullptr;
  return temp;
}
inline ::sim_msg::TopicList* InitResult::mutable_topics() {
  
  if (topics_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::TopicList>(GetArenaNoVirtual());
    topics_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.InitResult.topics)
  return topics_;
}
inline void InitResult::set_allocated_topics(::sim_msg::TopicList* topics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete topics_;
  }
  if (topics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      topics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topics, submessage_arena);
    }
    
  } else {
    
  }
  topics_ = topics;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.InitResult.topics)
}

// .sim_msg.ErrorStatus errorStatus = 2;
inline bool InitResult::has_errorstatus() const {
  return this != internal_default_instance() && errorstatus_ != nullptr;
}
inline void InitResult::clear_errorstatus() {
  if (GetArenaNoVirtual() == nullptr && errorstatus_ != nullptr) {
    delete errorstatus_;
  }
  errorstatus_ = nullptr;
}
inline const ::sim_msg::ErrorStatus& InitResult::errorstatus() const {
  const ::sim_msg::ErrorStatus* p = errorstatus_;
  // @@protoc_insertion_point(field_get:sim_msg.InitResult.errorStatus)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::ErrorStatus*>(
      &::sim_msg::_ErrorStatus_default_instance_);
}
inline ::sim_msg::ErrorStatus* InitResult::release_errorstatus() {
  // @@protoc_insertion_point(field_release:sim_msg.InitResult.errorStatus)
  
  ::sim_msg::ErrorStatus* temp = errorstatus_;
  errorstatus_ = nullptr;
  return temp;
}
inline ::sim_msg::ErrorStatus* InitResult::mutable_errorstatus() {
  
  if (errorstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::ErrorStatus>(GetArenaNoVirtual());
    errorstatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.InitResult.errorStatus)
  return errorstatus_;
}
inline void InitResult::set_allocated_errorstatus(::sim_msg::ErrorStatus* errorstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete errorstatus_;
  }
  if (errorstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      errorstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errorstatus, submessage_arena);
    }
    
  } else {
    
  }
  errorstatus_ = errorstatus;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.InitResult.errorStatus)
}

// repeated string str_topics = 3;
inline int InitResult::str_topics_size() const {
  return str_topics_.size();
}
inline void InitResult::clear_str_topics() {
  str_topics_.Clear();
}
inline const std::string& InitResult::str_topics(int index) const {
  // @@protoc_insertion_point(field_get:sim_msg.InitResult.str_topics)
  return str_topics_.Get(index);
}
inline std::string* InitResult::mutable_str_topics(int index) {
  // @@protoc_insertion_point(field_mutable:sim_msg.InitResult.str_topics)
  return str_topics_.Mutable(index);
}
inline void InitResult::set_str_topics(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:sim_msg.InitResult.str_topics)
  str_topics_.Mutable(index)->assign(value);
}
inline void InitResult::set_str_topics(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:sim_msg.InitResult.str_topics)
  str_topics_.Mutable(index)->assign(std::move(value));
}
inline void InitResult::set_str_topics(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  str_topics_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sim_msg.InitResult.str_topics)
}
inline void InitResult::set_str_topics(int index, const char* value, size_t size) {
  str_topics_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sim_msg.InitResult.str_topics)
}
inline std::string* InitResult::add_str_topics() {
  // @@protoc_insertion_point(field_add_mutable:sim_msg.InitResult.str_topics)
  return str_topics_.Add();
}
inline void InitResult::add_str_topics(const std::string& value) {
  str_topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sim_msg.InitResult.str_topics)
}
inline void InitResult::add_str_topics(std::string&& value) {
  str_topics_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sim_msg.InitResult.str_topics)
}
inline void InitResult::add_str_topics(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  str_topics_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sim_msg.InitResult.str_topics)
}
inline void InitResult::add_str_topics(const char* value, size_t size) {
  str_topics_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sim_msg.InitResult.str_topics)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InitResult::str_topics() const {
  // @@protoc_insertion_point(field_list:sim_msg.InitResult.str_topics)
  return str_topics_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InitResult::mutable_str_topics() {
  // @@protoc_insertion_point(field_mutable_list:sim_msg.InitResult.str_topics)
  return &str_topics_;
}

// -------------------------------------------------------------------

// ResetParams

// string scenarioPath = 1;
inline void ResetParams::clear_scenariopath() {
  scenariopath_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ResetParams::scenariopath() const {
  // @@protoc_insertion_point(field_get:sim_msg.ResetParams.scenarioPath)
  return scenariopath_.GetNoArena();
}
inline void ResetParams::set_scenariopath(const std::string& value) {
  
  scenariopath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.ResetParams.scenarioPath)
}
inline void ResetParams::set_scenariopath(std::string&& value) {
  
  scenariopath_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.ResetParams.scenarioPath)
}
inline void ResetParams::set_scenariopath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  scenariopath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.ResetParams.scenarioPath)
}
inline void ResetParams::set_scenariopath(const char* value, size_t size) {
  
  scenariopath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.ResetParams.scenarioPath)
}
inline std::string* ResetParams::mutable_scenariopath() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.ResetParams.scenarioPath)
  return scenariopath_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResetParams::release_scenariopath() {
  // @@protoc_insertion_point(field_release:sim_msg.ResetParams.scenarioPath)
  
  return scenariopath_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResetParams::set_allocated_scenariopath(std::string* scenariopath) {
  if (scenariopath != nullptr) {
    
  } else {
    
  }
  scenariopath_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), scenariopath);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.ResetParams.scenarioPath)
}

// string hadmapPath = 2;
inline void ResetParams::clear_hadmappath() {
  hadmappath_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ResetParams::hadmappath() const {
  // @@protoc_insertion_point(field_get:sim_msg.ResetParams.hadmapPath)
  return hadmappath_.GetNoArena();
}
inline void ResetParams::set_hadmappath(const std::string& value) {
  
  hadmappath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.ResetParams.hadmapPath)
}
inline void ResetParams::set_hadmappath(std::string&& value) {
  
  hadmappath_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.ResetParams.hadmapPath)
}
inline void ResetParams::set_hadmappath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hadmappath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.ResetParams.hadmapPath)
}
inline void ResetParams::set_hadmappath(const char* value, size_t size) {
  
  hadmappath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.ResetParams.hadmapPath)
}
inline std::string* ResetParams::mutable_hadmappath() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.ResetParams.hadmapPath)
  return hadmappath_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResetParams::release_hadmappath() {
  // @@protoc_insertion_point(field_release:sim_msg.ResetParams.hadmapPath)
  
  return hadmappath_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResetParams::set_allocated_hadmappath(std::string* hadmappath) {
  if (hadmappath != nullptr) {
    
  } else {
    
  }
  hadmappath_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hadmappath);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.ResetParams.hadmapPath)
}

// .sim_msg.Vec3 startPos = 3;
inline bool ResetParams::has_startpos() const {
  return this != internal_default_instance() && startpos_ != nullptr;
}
inline const ::sim_msg::Vec3& ResetParams::startpos() const {
  const ::sim_msg::Vec3* p = startpos_;
  // @@protoc_insertion_point(field_get:sim_msg.ResetParams.startPos)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Vec3*>(
      &::sim_msg::_Vec3_default_instance_);
}
inline ::sim_msg::Vec3* ResetParams::release_startpos() {
  // @@protoc_insertion_point(field_release:sim_msg.ResetParams.startPos)
  
  ::sim_msg::Vec3* temp = startpos_;
  startpos_ = nullptr;
  return temp;
}
inline ::sim_msg::Vec3* ResetParams::mutable_startpos() {
  
  if (startpos_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Vec3>(GetArenaNoVirtual());
    startpos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.ResetParams.startPos)
  return startpos_;
}
inline void ResetParams::set_allocated_startpos(::sim_msg::Vec3* startpos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(startpos_);
  }
  if (startpos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      startpos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, startpos, submessage_arena);
    }
    
  } else {
    
  }
  startpos_ = startpos;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.ResetParams.startPos)
}

// .sim_msg.Vec3 endPos = 4;
inline bool ResetParams::has_endpos() const {
  return this != internal_default_instance() && endpos_ != nullptr;
}
inline const ::sim_msg::Vec3& ResetParams::endpos() const {
  const ::sim_msg::Vec3* p = endpos_;
  // @@protoc_insertion_point(field_get:sim_msg.ResetParams.endPos)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Vec3*>(
      &::sim_msg::_Vec3_default_instance_);
}
inline ::sim_msg::Vec3* ResetParams::release_endpos() {
  // @@protoc_insertion_point(field_release:sim_msg.ResetParams.endPos)
  
  ::sim_msg::Vec3* temp = endpos_;
  endpos_ = nullptr;
  return temp;
}
inline ::sim_msg::Vec3* ResetParams::mutable_endpos() {
  
  if (endpos_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Vec3>(GetArenaNoVirtual());
    endpos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.ResetParams.endPos)
  return endpos_;
}
inline void ResetParams::set_allocated_endpos(::sim_msg::Vec3* endpos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpos_);
  }
  if (endpos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      endpos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpos, submessage_arena);
    }
    
  } else {
    
  }
  endpos_ = endpos;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.ResetParams.endPos)
}

// double startVel = 5;
inline void ResetParams::clear_startvel() {
  startvel_ = 0;
}
inline double ResetParams::startvel() const {
  // @@protoc_insertion_point(field_get:sim_msg.ResetParams.startVel)
  return startvel_;
}
inline void ResetParams::set_startvel(double value) {
  
  startvel_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ResetParams.startVel)
}

// double maxVel = 6;
inline void ResetParams::clear_maxvel() {
  maxvel_ = 0;
}
inline double ResetParams::maxvel() const {
  // @@protoc_insertion_point(field_get:sim_msg.ResetParams.maxVel)
  return maxvel_;
}
inline void ResetParams::set_maxvel(double value) {
  
  maxvel_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ResetParams.maxVel)
}

// double theta = 7;
inline void ResetParams::clear_theta() {
  theta_ = 0;
}
inline double ResetParams::theta() const {
  // @@protoc_insertion_point(field_get:sim_msg.ResetParams.theta)
  return theta_;
}
inline void ResetParams::set_theta(double value) {
  
  theta_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ResetParams.theta)
}

// double speedLimit_Max = 8;
inline void ResetParams::clear_speedlimit_max() {
  speedlimit_max_ = 0;
}
inline double ResetParams::speedlimit_max() const {
  // @@protoc_insertion_point(field_get:sim_msg.ResetParams.speedLimit_Max)
  return speedlimit_max_;
}
inline void ResetParams::set_speedlimit_max(double value) {
  
  speedlimit_max_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ResetParams.speedLimit_Max)
}

// double speedLimit_Min = 9;
inline void ResetParams::clear_speedlimit_min() {
  speedlimit_min_ = 0;
}
inline double ResetParams::speedlimit_min() const {
  // @@protoc_insertion_point(field_get:sim_msg.ResetParams.speedLimit_Min)
  return speedlimit_min_;
}
inline void ResetParams::set_speedlimit_min(double value) {
  
  speedlimit_min_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ResetParams.speedLimit_Min)
}

// double accelerationLimit_Max = 10;
inline void ResetParams::clear_accelerationlimit_max() {
  accelerationlimit_max_ = 0;
}
inline double ResetParams::accelerationlimit_max() const {
  // @@protoc_insertion_point(field_get:sim_msg.ResetParams.accelerationLimit_Max)
  return accelerationlimit_max_;
}
inline void ResetParams::set_accelerationlimit_max(double value) {
  
  accelerationlimit_max_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ResetParams.accelerationLimit_Max)
}

// double accelerationLimit_Min = 11;
inline void ResetParams::clear_accelerationlimit_min() {
  accelerationlimit_min_ = 0;
}
inline double ResetParams::accelerationlimit_min() const {
  // @@protoc_insertion_point(field_get:sim_msg.ResetParams.accelerationLimit_Min)
  return accelerationlimit_min_;
}
inline void ResetParams::set_accelerationlimit_min(double value) {
  
  accelerationlimit_min_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ResetParams.accelerationLimit_Min)
}

// string rosbagFilePath = 12;
inline void ResetParams::clear_rosbagfilepath() {
  rosbagfilepath_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ResetParams::rosbagfilepath() const {
  // @@protoc_insertion_point(field_get:sim_msg.ResetParams.rosbagFilePath)
  return rosbagfilepath_.GetNoArena();
}
inline void ResetParams::set_rosbagfilepath(const std::string& value) {
  
  rosbagfilepath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.ResetParams.rosbagFilePath)
}
inline void ResetParams::set_rosbagfilepath(std::string&& value) {
  
  rosbagfilepath_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.ResetParams.rosbagFilePath)
}
inline void ResetParams::set_rosbagfilepath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  rosbagfilepath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.ResetParams.rosbagFilePath)
}
inline void ResetParams::set_rosbagfilepath(const char* value, size_t size) {
  
  rosbagfilepath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.ResetParams.rosbagFilePath)
}
inline std::string* ResetParams::mutable_rosbagfilepath() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.ResetParams.rosbagFilePath)
  return rosbagfilepath_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ResetParams::release_rosbagfilepath() {
  // @@protoc_insertion_point(field_release:sim_msg.ResetParams.rosbagFilePath)
  
  return rosbagfilepath_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ResetParams::set_allocated_rosbagfilepath(std::string* rosbagfilepath) {
  if (rosbagfilepath != nullptr) {
    
  } else {
    
  }
  rosbagfilepath_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rosbagfilepath);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.ResetParams.rosbagFilePath)
}

// .sim_msg.Vec3 localOrigin = 13;
inline bool ResetParams::has_localorigin() const {
  return this != internal_default_instance() && localorigin_ != nullptr;
}
inline const ::sim_msg::Vec3& ResetParams::localorigin() const {
  const ::sim_msg::Vec3* p = localorigin_;
  // @@protoc_insertion_point(field_get:sim_msg.ResetParams.localOrigin)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Vec3*>(
      &::sim_msg::_Vec3_default_instance_);
}
inline ::sim_msg::Vec3* ResetParams::release_localorigin() {
  // @@protoc_insertion_point(field_release:sim_msg.ResetParams.localOrigin)
  
  ::sim_msg::Vec3* temp = localorigin_;
  localorigin_ = nullptr;
  return temp;
}
inline ::sim_msg::Vec3* ResetParams::mutable_localorigin() {
  
  if (localorigin_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Vec3>(GetArenaNoVirtual());
    localorigin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.ResetParams.localOrigin)
  return localorigin_;
}
inline void ResetParams::set_allocated_localorigin(::sim_msg::Vec3* localorigin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(localorigin_);
  }
  if (localorigin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      localorigin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, localorigin, submessage_arena);
    }
    
  } else {
    
  }
  localorigin_ = localorigin;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.ResetParams.localOrigin)
}

// double timeheadway_Min = 14;
inline void ResetParams::clear_timeheadway_min() {
  timeheadway_min_ = 0;
}
inline double ResetParams::timeheadway_min() const {
  // @@protoc_insertion_point(field_get:sim_msg.ResetParams.timeheadway_Min)
  return timeheadway_min_;
}
inline void ResetParams::set_timeheadway_min(double value) {
  
  timeheadway_min_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ResetParams.timeheadway_Min)
}

// int32 job_id = 15;
inline void ResetParams::clear_job_id() {
  job_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ResetParams::job_id() const {
  // @@protoc_insertion_point(field_get:sim_msg.ResetParams.job_id)
  return job_id_;
}
inline void ResetParams::set_job_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ResetParams.job_id)
}

// int32 scene_id = 16;
inline void ResetParams::clear_scene_id() {
  scene_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ResetParams::scene_id() const {
  // @@protoc_insertion_point(field_get:sim_msg.ResetParams.scene_id)
  return scene_id_;
}
inline void ResetParams::set_scene_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  scene_id_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ResetParams.scene_id)
}

// int32 ego_id = 17;
inline void ResetParams::clear_ego_id() {
  ego_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ResetParams::ego_id() const {
  // @@protoc_insertion_point(field_get:sim_msg.ResetParams.ego_id)
  return ego_id_;
}
inline void ResetParams::set_ego_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ego_id_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ResetParams.ego_id)
}

// repeated .sim_msg.Vec2 geo_fence = 18;
inline int ResetParams::geo_fence_size() const {
  return geo_fence_.size();
}
inline ::sim_msg::Vec2* ResetParams::mutable_geo_fence(int index) {
  // @@protoc_insertion_point(field_mutable:sim_msg.ResetParams.geo_fence)
  return geo_fence_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Vec2 >*
ResetParams::mutable_geo_fence() {
  // @@protoc_insertion_point(field_mutable_list:sim_msg.ResetParams.geo_fence)
  return &geo_fence_;
}
inline const ::sim_msg::Vec2& ResetParams::geo_fence(int index) const {
  // @@protoc_insertion_point(field_get:sim_msg.ResetParams.geo_fence)
  return geo_fence_.Get(index);
}
inline ::sim_msg::Vec2* ResetParams::add_geo_fence() {
  // @@protoc_insertion_point(field_add:sim_msg.ResetParams.geo_fence)
  return geo_fence_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Vec2 >&
ResetParams::geo_fence() const {
  // @@protoc_insertion_point(field_list:sim_msg.ResetParams.geo_fence)
  return geo_fence_;
}

// repeated .sim_msg.Vec3 ego_path = 19;
inline int ResetParams::ego_path_size() const {
  return ego_path_.size();
}
inline ::sim_msg::Vec3* ResetParams::mutable_ego_path(int index) {
  // @@protoc_insertion_point(field_mutable:sim_msg.ResetParams.ego_path)
  return ego_path_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Vec3 >*
ResetParams::mutable_ego_path() {
  // @@protoc_insertion_point(field_mutable_list:sim_msg.ResetParams.ego_path)
  return &ego_path_;
}
inline const ::sim_msg::Vec3& ResetParams::ego_path(int index) const {
  // @@protoc_insertion_point(field_get:sim_msg.ResetParams.ego_path)
  return ego_path_.Get(index);
}
inline ::sim_msg::Vec3* ResetParams::add_ego_path() {
  // @@protoc_insertion_point(field_add:sim_msg.ResetParams.ego_path)
  return ego_path_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Vec3 >&
ResetParams::ego_path() const {
  // @@protoc_insertion_point(field_list:sim_msg.ResetParams.ego_path)
  return ego_path_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SimMessage

// map<string, bytes> messages = 1;
inline int SimMessage::messages_size() const {
  return messages_.size();
}
inline void SimMessage::clear_messages() {
  messages_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SimMessage::messages() const {
  // @@protoc_insertion_point(field_map:sim_msg.SimMessage.messages)
  return messages_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SimMessage::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_map:sim_msg.SimMessage.messages)
  return messages_.MutableMap();
}

// uint64 frameId = 2;
inline void SimMessage::clear_frameid() {
  frameid_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SimMessage::frameid() const {
  // @@protoc_insertion_point(field_get:sim_msg.SimMessage.frameId)
  return frameid_;
}
inline void SimMessage::set_frameid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  frameid_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.SimMessage.frameId)
}

// double timeStamp = 3;
inline void SimMessage::clear_timestamp() {
  timestamp_ = 0;
}
inline double SimMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:sim_msg.SimMessage.timeStamp)
  return timestamp_;
}
inline void SimMessage::set_timestamp(double value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.SimMessage.timeStamp)
}

// -------------------------------------------------------------------

// StepResult

// .sim_msg.SimMessage result = 1;
inline bool StepResult::has_result() const {
  return this != internal_default_instance() && result_ != nullptr;
}
inline void StepResult::clear_result() {
  if (GetArenaNoVirtual() == nullptr && result_ != nullptr) {
    delete result_;
  }
  result_ = nullptr;
}
inline const ::sim_msg::SimMessage& StepResult::result() const {
  const ::sim_msg::SimMessage* p = result_;
  // @@protoc_insertion_point(field_get:sim_msg.StepResult.result)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::SimMessage*>(
      &::sim_msg::_SimMessage_default_instance_);
}
inline ::sim_msg::SimMessage* StepResult::release_result() {
  // @@protoc_insertion_point(field_release:sim_msg.StepResult.result)
  
  ::sim_msg::SimMessage* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::sim_msg::SimMessage* StepResult::mutable_result() {
  
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::SimMessage>(GetArenaNoVirtual());
    result_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.StepResult.result)
  return result_;
}
inline void StepResult::set_allocated_result(::sim_msg::SimMessage* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.StepResult.result)
}

// .sim_msg.ErrorStatus errorStatus = 2;
inline bool StepResult::has_errorstatus() const {
  return this != internal_default_instance() && errorstatus_ != nullptr;
}
inline void StepResult::clear_errorstatus() {
  if (GetArenaNoVirtual() == nullptr && errorstatus_ != nullptr) {
    delete errorstatus_;
  }
  errorstatus_ = nullptr;
}
inline const ::sim_msg::ErrorStatus& StepResult::errorstatus() const {
  const ::sim_msg::ErrorStatus* p = errorstatus_;
  // @@protoc_insertion_point(field_get:sim_msg.StepResult.errorStatus)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::ErrorStatus*>(
      &::sim_msg::_ErrorStatus_default_instance_);
}
inline ::sim_msg::ErrorStatus* StepResult::release_errorstatus() {
  // @@protoc_insertion_point(field_release:sim_msg.StepResult.errorStatus)
  
  ::sim_msg::ErrorStatus* temp = errorstatus_;
  errorstatus_ = nullptr;
  return temp;
}
inline ::sim_msg::ErrorStatus* StepResult::mutable_errorstatus() {
  
  if (errorstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::ErrorStatus>(GetArenaNoVirtual());
    errorstatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.StepResult.errorStatus)
  return errorstatus_;
}
inline void StepResult::set_allocated_errorstatus(::sim_msg::ErrorStatus* errorstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete errorstatus_;
  }
  if (errorstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      errorstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errorstatus, submessage_arena);
    }
    
  } else {
    
  }
  errorstatus_ = errorstatus;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.StepResult.errorStatus)
}

// double timeCost = 3;
inline void StepResult::clear_timecost() {
  timecost_ = 0;
}
inline double StepResult::timecost() const {
  // @@protoc_insertion_point(field_get:sim_msg.StepResult.timeCost)
  return timecost_;
}
inline void StepResult::set_timecost(double value) {
  
  timecost_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.StepResult.timeCost)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StopResult

// map<string, string> feedback = 1;
inline int StopResult::feedback_size() const {
  return feedback_.size();
}
inline void StopResult::clear_feedback() {
  feedback_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StopResult::feedback() const {
  // @@protoc_insertion_point(field_map:sim_msg.StopResult.feedback)
  return feedback_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StopResult::mutable_feedback() {
  // @@protoc_insertion_point(field_mutable_map:sim_msg.StopResult.feedback)
  return feedback_.MutableMap();
}

// .sim_msg.ErrorStatus errorStatus = 2;
inline bool StopResult::has_errorstatus() const {
  return this != internal_default_instance() && errorstatus_ != nullptr;
}
inline void StopResult::clear_errorstatus() {
  if (GetArenaNoVirtual() == nullptr && errorstatus_ != nullptr) {
    delete errorstatus_;
  }
  errorstatus_ = nullptr;
}
inline const ::sim_msg::ErrorStatus& StopResult::errorstatus() const {
  const ::sim_msg::ErrorStatus* p = errorstatus_;
  // @@protoc_insertion_point(field_get:sim_msg.StopResult.errorStatus)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::ErrorStatus*>(
      &::sim_msg::_ErrorStatus_default_instance_);
}
inline ::sim_msg::ErrorStatus* StopResult::release_errorstatus() {
  // @@protoc_insertion_point(field_release:sim_msg.StopResult.errorStatus)
  
  ::sim_msg::ErrorStatus* temp = errorstatus_;
  errorstatus_ = nullptr;
  return temp;
}
inline ::sim_msg::ErrorStatus* StopResult::mutable_errorstatus() {
  
  if (errorstatus_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::ErrorStatus>(GetArenaNoVirtual());
    errorstatus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.StopResult.errorStatus)
  return errorstatus_;
}
inline void StopResult::set_allocated_errorstatus(::sim_msg::ErrorStatus* errorstatus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete errorstatus_;
  }
  if (errorstatus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      errorstatus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errorstatus, submessage_arena);
    }
    
  } else {
    
  }
  errorstatus_ = errorstatus;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.StopResult.errorStatus)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sim_msg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sim_msg::Topic> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::Topic>() {
  return ::sim_msg::Topic_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::ErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::ErrorCode>() {
  return ::sim_msg::ErrorCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_moduleService_2eproto
