// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scene_infrastructure_group.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_scene_5finfrastructure_5fgroup_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_scene_5finfrastructure_5fgroup_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "waypoint.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_scene_5finfrastructure_5fgroup_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_scene_5finfrastructure_5fgroup_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_scene_5finfrastructure_5fgroup_2eproto;
namespace sim_msg {
class Infrastructure;
class InfrastructureDefaultTypeInternal;
extern InfrastructureDefaultTypeInternal _Infrastructure_default_instance_;
class InfrastructureGroup;
class InfrastructureGroupDefaultTypeInternal;
extern InfrastructureGroupDefaultTypeInternal _InfrastructureGroup_default_instance_;
class Infrastructure_Extrinsic;
class Infrastructure_ExtrinsicDefaultTypeInternal;
extern Infrastructure_ExtrinsicDefaultTypeInternal _Infrastructure_Extrinsic_default_instance_;
class Infrastructure_Intrinsic;
class Infrastructure_IntrinsicDefaultTypeInternal;
extern Infrastructure_IntrinsicDefaultTypeInternal _Infrastructure_Intrinsic_default_instance_;
class Infrastructure_Intrinsic_ParamsEntry_DoNotUse;
class Infrastructure_Intrinsic_ParamsEntry_DoNotUseDefaultTypeInternal;
extern Infrastructure_Intrinsic_ParamsEntry_DoNotUseDefaultTypeInternal _Infrastructure_Intrinsic_ParamsEntry_DoNotUse_default_instance_;
}  // namespace sim_msg
PROTOBUF_NAMESPACE_OPEN
template<> ::sim_msg::Infrastructure* Arena::CreateMaybeMessage<::sim_msg::Infrastructure>(Arena*);
template<> ::sim_msg::InfrastructureGroup* Arena::CreateMaybeMessage<::sim_msg::InfrastructureGroup>(Arena*);
template<> ::sim_msg::Infrastructure_Extrinsic* Arena::CreateMaybeMessage<::sim_msg::Infrastructure_Extrinsic>(Arena*);
template<> ::sim_msg::Infrastructure_Intrinsic* Arena::CreateMaybeMessage<::sim_msg::Infrastructure_Intrinsic>(Arena*);
template<> ::sim_msg::Infrastructure_Intrinsic_ParamsEntry_DoNotUse* Arena::CreateMaybeMessage<::sim_msg::Infrastructure_Intrinsic_ParamsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sim_msg {

enum InfrastructureType : int {
  INFRASTRUCTURE_TYPE_USER_DEFINE = 0,
  INFRASTRUCTURE_TYPE_TRAFFIC_SIGNAL = 1,
  INFRASTRUCTURE_TYPE_RSU = 2,
  INFRASTRUCTURE_TYPE_CAMERA = 3,
  INFRASTRUCTURE_TYPE_LIDAR = 4,
  INFRASTRUCTURE_TYPE_RADAR = 5,
  InfrastructureType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  InfrastructureType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool InfrastructureType_IsValid(int value);
constexpr InfrastructureType InfrastructureType_MIN = INFRASTRUCTURE_TYPE_USER_DEFINE;
constexpr InfrastructureType InfrastructureType_MAX = INFRASTRUCTURE_TYPE_RADAR;
constexpr int InfrastructureType_ARRAYSIZE = InfrastructureType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InfrastructureType_descriptor();
template<typename T>
inline const std::string& InfrastructureType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InfrastructureType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InfrastructureType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InfrastructureType_descriptor(), enum_t_value);
}
inline bool InfrastructureType_Parse(
    const std::string& name, InfrastructureType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InfrastructureType>(
    InfrastructureType_descriptor(), name, value);
}
// ===================================================================

class Infrastructure_Intrinsic_ParamsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Infrastructure_Intrinsic_ParamsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Infrastructure_Intrinsic_ParamsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Infrastructure_Intrinsic_ParamsEntry_DoNotUse();
  Infrastructure_Intrinsic_ParamsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Infrastructure_Intrinsic_ParamsEntry_DoNotUse& other);
  static const Infrastructure_Intrinsic_ParamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Infrastructure_Intrinsic_ParamsEntry_DoNotUse*>(&_Infrastructure_Intrinsic_ParamsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sim_msg.Infrastructure.Intrinsic.ParamsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), s->size(), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sim_msg.Infrastructure.Intrinsic.ParamsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_5finfrastructure_5fgroup_2eproto);
    return ::descriptor_table_scene_5finfrastructure_5fgroup_2eproto.file_level_metadata[0];
  }

  public:
};

// -------------------------------------------------------------------

class Infrastructure_Intrinsic :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Infrastructure.Intrinsic) */ {
 public:
  Infrastructure_Intrinsic();
  virtual ~Infrastructure_Intrinsic();

  Infrastructure_Intrinsic(const Infrastructure_Intrinsic& from);
  Infrastructure_Intrinsic(Infrastructure_Intrinsic&& from) noexcept
    : Infrastructure_Intrinsic() {
    *this = ::std::move(from);
  }

  inline Infrastructure_Intrinsic& operator=(const Infrastructure_Intrinsic& from) {
    CopyFrom(from);
    return *this;
  }
  inline Infrastructure_Intrinsic& operator=(Infrastructure_Intrinsic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Infrastructure_Intrinsic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Infrastructure_Intrinsic* internal_default_instance() {
    return reinterpret_cast<const Infrastructure_Intrinsic*>(
               &_Infrastructure_Intrinsic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Infrastructure_Intrinsic& a, Infrastructure_Intrinsic& b) {
    a.Swap(&b);
  }
  inline void Swap(Infrastructure_Intrinsic* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Infrastructure_Intrinsic* New() const final {
    return CreateMaybeMessage<Infrastructure_Intrinsic>(nullptr);
  }

  Infrastructure_Intrinsic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Infrastructure_Intrinsic>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Infrastructure_Intrinsic& from);
  void MergeFrom(const Infrastructure_Intrinsic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Infrastructure_Intrinsic* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Infrastructure.Intrinsic";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_5finfrastructure_5fgroup_2eproto);
    return ::descriptor_table_scene_5finfrastructure_5fgroup_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 1,
  };
  // map<string, string> params = 1;
  int params_size() const;
  void clear_params();
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      params() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_params();

  // @@protoc_insertion_point(class_scope:sim_msg.Infrastructure.Intrinsic)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Infrastructure_Intrinsic_ParamsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > params_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_5finfrastructure_5fgroup_2eproto;
};
// -------------------------------------------------------------------

class Infrastructure_Extrinsic :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Infrastructure.Extrinsic) */ {
 public:
  Infrastructure_Extrinsic();
  virtual ~Infrastructure_Extrinsic();

  Infrastructure_Extrinsic(const Infrastructure_Extrinsic& from);
  Infrastructure_Extrinsic(Infrastructure_Extrinsic&& from) noexcept
    : Infrastructure_Extrinsic() {
    *this = ::std::move(from);
  }

  inline Infrastructure_Extrinsic& operator=(const Infrastructure_Extrinsic& from) {
    CopyFrom(from);
    return *this;
  }
  inline Infrastructure_Extrinsic& operator=(Infrastructure_Extrinsic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Infrastructure_Extrinsic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Infrastructure_Extrinsic* internal_default_instance() {
    return reinterpret_cast<const Infrastructure_Extrinsic*>(
               &_Infrastructure_Extrinsic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Infrastructure_Extrinsic& a, Infrastructure_Extrinsic& b) {
    a.Swap(&b);
  }
  inline void Swap(Infrastructure_Extrinsic* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Infrastructure_Extrinsic* New() const final {
    return CreateMaybeMessage<Infrastructure_Extrinsic>(nullptr);
  }

  Infrastructure_Extrinsic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Infrastructure_Extrinsic>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Infrastructure_Extrinsic& from);
  void MergeFrom(const Infrastructure_Extrinsic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Infrastructure_Extrinsic* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Infrastructure.Extrinsic";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_5finfrastructure_5fgroup_2eproto);
    return ::descriptor_table_scene_5finfrastructure_5fgroup_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 2,
    kIDFieldNumber = 1,
  };
  // string Device = 2;
  void clear_device();
  const std::string& device() const;
  void set_device(const std::string& value);
  void set_device(std::string&& value);
  void set_device(const char* value);
  void set_device(const char* value, size_t size);
  std::string* mutable_device();
  std::string* release_device();
  void set_allocated_device(std::string* device);

  // int64 ID = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:sim_msg.Infrastructure.Extrinsic)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_5finfrastructure_5fgroup_2eproto;
};
// -------------------------------------------------------------------

class Infrastructure :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Infrastructure) */ {
 public:
  Infrastructure();
  virtual ~Infrastructure();

  Infrastructure(const Infrastructure& from);
  Infrastructure(Infrastructure&& from) noexcept
    : Infrastructure() {
    *this = ::std::move(from);
  }

  inline Infrastructure& operator=(const Infrastructure& from) {
    CopyFrom(from);
    return *this;
  }
  inline Infrastructure& operator=(Infrastructure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Infrastructure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Infrastructure* internal_default_instance() {
    return reinterpret_cast<const Infrastructure*>(
               &_Infrastructure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Infrastructure& a, Infrastructure& b) {
    a.Swap(&b);
  }
  inline void Swap(Infrastructure* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Infrastructure* New() const final {
    return CreateMaybeMessage<Infrastructure>(nullptr);
  }

  Infrastructure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Infrastructure>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Infrastructure& from);
  void MergeFrom(const Infrastructure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Infrastructure* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Infrastructure";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_5finfrastructure_5fgroup_2eproto);
    return ::descriptor_table_scene_5finfrastructure_5fgroup_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Infrastructure_Intrinsic Intrinsic;
  typedef Infrastructure_Extrinsic Extrinsic;

  // accessors -------------------------------------------------------

  enum : int {
    kExtrinsicFieldNumber = 2,
    kIntrinsicFieldNumber = 3,
    kWaypointFieldNumber = 4,
    kTypeFieldNumber = 1,
  };
  // .sim_msg.Infrastructure.Extrinsic extrinsic = 2;
  bool has_extrinsic() const;
  void clear_extrinsic();
  const ::sim_msg::Infrastructure_Extrinsic& extrinsic() const;
  ::sim_msg::Infrastructure_Extrinsic* release_extrinsic();
  ::sim_msg::Infrastructure_Extrinsic* mutable_extrinsic();
  void set_allocated_extrinsic(::sim_msg::Infrastructure_Extrinsic* extrinsic);

  // .sim_msg.Infrastructure.Intrinsic intrinsic = 3;
  bool has_intrinsic() const;
  void clear_intrinsic();
  const ::sim_msg::Infrastructure_Intrinsic& intrinsic() const;
  ::sim_msg::Infrastructure_Intrinsic* release_intrinsic();
  ::sim_msg::Infrastructure_Intrinsic* mutable_intrinsic();
  void set_allocated_intrinsic(::sim_msg::Infrastructure_Intrinsic* intrinsic);

  // .sim_msg.Waypoint waypoint = 4;
  bool has_waypoint() const;
  void clear_waypoint();
  const ::sim_msg::Waypoint& waypoint() const;
  ::sim_msg::Waypoint* release_waypoint();
  ::sim_msg::Waypoint* mutable_waypoint();
  void set_allocated_waypoint(::sim_msg::Waypoint* waypoint);

  // .sim_msg.InfrastructureType type = 1;
  void clear_type();
  ::sim_msg::InfrastructureType type() const;
  void set_type(::sim_msg::InfrastructureType value);

  // @@protoc_insertion_point(class_scope:sim_msg.Infrastructure)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::sim_msg::Infrastructure_Extrinsic* extrinsic_;
  ::sim_msg::Infrastructure_Intrinsic* intrinsic_;
  ::sim_msg::Waypoint* waypoint_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_5finfrastructure_5fgroup_2eproto;
};
// -------------------------------------------------------------------

class InfrastructureGroup :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.InfrastructureGroup) */ {
 public:
  InfrastructureGroup();
  virtual ~InfrastructureGroup();

  InfrastructureGroup(const InfrastructureGroup& from);
  InfrastructureGroup(InfrastructureGroup&& from) noexcept
    : InfrastructureGroup() {
    *this = ::std::move(from);
  }

  inline InfrastructureGroup& operator=(const InfrastructureGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfrastructureGroup& operator=(InfrastructureGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InfrastructureGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InfrastructureGroup* internal_default_instance() {
    return reinterpret_cast<const InfrastructureGroup*>(
               &_InfrastructureGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(InfrastructureGroup& a, InfrastructureGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(InfrastructureGroup* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InfrastructureGroup* New() const final {
    return CreateMaybeMessage<InfrastructureGroup>(nullptr);
  }

  InfrastructureGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InfrastructureGroup>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InfrastructureGroup& from);
  void MergeFrom(const InfrastructureGroup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InfrastructureGroup* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.InfrastructureGroup";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_5finfrastructure_5fgroup_2eproto);
    return ::descriptor_table_scene_5finfrastructure_5fgroup_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfrastructureFieldNumber = 2,
    kNameFieldNumber = 1,
    kActivePlanFieldNumber = 3,
  };
  // repeated .sim_msg.Infrastructure Infrastructure = 2;
  int infrastructure_size() const;
  void clear_infrastructure();
  ::sim_msg::Infrastructure* mutable_infrastructure(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Infrastructure >*
      mutable_infrastructure();
  const ::sim_msg::Infrastructure& infrastructure(int index) const;
  ::sim_msg::Infrastructure* add_infrastructure();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Infrastructure >&
      infrastructure() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // int32 active_plan = 3;
  void clear_active_plan();
  ::PROTOBUF_NAMESPACE_ID::int32 active_plan() const;
  void set_active_plan(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:sim_msg.InfrastructureGroup)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Infrastructure > infrastructure_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 active_plan_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_5finfrastructure_5fgroup_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Infrastructure_Intrinsic

// map<string, string> params = 1;
inline int Infrastructure_Intrinsic::params_size() const {
  return params_.size();
}
inline void Infrastructure_Intrinsic::clear_params() {
  params_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Infrastructure_Intrinsic::params() const {
  // @@protoc_insertion_point(field_map:sim_msg.Infrastructure.Intrinsic.params)
  return params_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Infrastructure_Intrinsic::mutable_params() {
  // @@protoc_insertion_point(field_mutable_map:sim_msg.Infrastructure.Intrinsic.params)
  return params_.MutableMap();
}

// -------------------------------------------------------------------

// Infrastructure_Extrinsic

// int64 ID = 1;
inline void Infrastructure_Extrinsic::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Infrastructure_Extrinsic::id() const {
  // @@protoc_insertion_point(field_get:sim_msg.Infrastructure.Extrinsic.ID)
  return id_;
}
inline void Infrastructure_Extrinsic::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Infrastructure.Extrinsic.ID)
}

// string Device = 2;
inline void Infrastructure_Extrinsic::clear_device() {
  device_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Infrastructure_Extrinsic::device() const {
  // @@protoc_insertion_point(field_get:sim_msg.Infrastructure.Extrinsic.Device)
  return device_.GetNoArena();
}
inline void Infrastructure_Extrinsic::set_device(const std::string& value) {
  
  device_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.Infrastructure.Extrinsic.Device)
}
inline void Infrastructure_Extrinsic::set_device(std::string&& value) {
  
  device_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.Infrastructure.Extrinsic.Device)
}
inline void Infrastructure_Extrinsic::set_device(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  device_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.Infrastructure.Extrinsic.Device)
}
inline void Infrastructure_Extrinsic::set_device(const char* value, size_t size) {
  
  device_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.Infrastructure.Extrinsic.Device)
}
inline std::string* Infrastructure_Extrinsic::mutable_device() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.Infrastructure.Extrinsic.Device)
  return device_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Infrastructure_Extrinsic::release_device() {
  // @@protoc_insertion_point(field_release:sim_msg.Infrastructure.Extrinsic.Device)
  
  return device_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Infrastructure_Extrinsic::set_allocated_device(std::string* device) {
  if (device != nullptr) {
    
  } else {
    
  }
  device_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Infrastructure.Extrinsic.Device)
}

// -------------------------------------------------------------------

// Infrastructure

// .sim_msg.InfrastructureType type = 1;
inline void Infrastructure::clear_type() {
  type_ = 0;
}
inline ::sim_msg::InfrastructureType Infrastructure::type() const {
  // @@protoc_insertion_point(field_get:sim_msg.Infrastructure.type)
  return static_cast< ::sim_msg::InfrastructureType >(type_);
}
inline void Infrastructure::set_type(::sim_msg::InfrastructureType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Infrastructure.type)
}

// .sim_msg.Infrastructure.Extrinsic extrinsic = 2;
inline bool Infrastructure::has_extrinsic() const {
  return this != internal_default_instance() && extrinsic_ != nullptr;
}
inline void Infrastructure::clear_extrinsic() {
  if (GetArenaNoVirtual() == nullptr && extrinsic_ != nullptr) {
    delete extrinsic_;
  }
  extrinsic_ = nullptr;
}
inline const ::sim_msg::Infrastructure_Extrinsic& Infrastructure::extrinsic() const {
  const ::sim_msg::Infrastructure_Extrinsic* p = extrinsic_;
  // @@protoc_insertion_point(field_get:sim_msg.Infrastructure.extrinsic)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Infrastructure_Extrinsic*>(
      &::sim_msg::_Infrastructure_Extrinsic_default_instance_);
}
inline ::sim_msg::Infrastructure_Extrinsic* Infrastructure::release_extrinsic() {
  // @@protoc_insertion_point(field_release:sim_msg.Infrastructure.extrinsic)
  
  ::sim_msg::Infrastructure_Extrinsic* temp = extrinsic_;
  extrinsic_ = nullptr;
  return temp;
}
inline ::sim_msg::Infrastructure_Extrinsic* Infrastructure::mutable_extrinsic() {
  
  if (extrinsic_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Infrastructure_Extrinsic>(GetArenaNoVirtual());
    extrinsic_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Infrastructure.extrinsic)
  return extrinsic_;
}
inline void Infrastructure::set_allocated_extrinsic(::sim_msg::Infrastructure_Extrinsic* extrinsic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete extrinsic_;
  }
  if (extrinsic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      extrinsic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extrinsic, submessage_arena);
    }
    
  } else {
    
  }
  extrinsic_ = extrinsic;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Infrastructure.extrinsic)
}

// .sim_msg.Infrastructure.Intrinsic intrinsic = 3;
inline bool Infrastructure::has_intrinsic() const {
  return this != internal_default_instance() && intrinsic_ != nullptr;
}
inline void Infrastructure::clear_intrinsic() {
  if (GetArenaNoVirtual() == nullptr && intrinsic_ != nullptr) {
    delete intrinsic_;
  }
  intrinsic_ = nullptr;
}
inline const ::sim_msg::Infrastructure_Intrinsic& Infrastructure::intrinsic() const {
  const ::sim_msg::Infrastructure_Intrinsic* p = intrinsic_;
  // @@protoc_insertion_point(field_get:sim_msg.Infrastructure.intrinsic)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Infrastructure_Intrinsic*>(
      &::sim_msg::_Infrastructure_Intrinsic_default_instance_);
}
inline ::sim_msg::Infrastructure_Intrinsic* Infrastructure::release_intrinsic() {
  // @@protoc_insertion_point(field_release:sim_msg.Infrastructure.intrinsic)
  
  ::sim_msg::Infrastructure_Intrinsic* temp = intrinsic_;
  intrinsic_ = nullptr;
  return temp;
}
inline ::sim_msg::Infrastructure_Intrinsic* Infrastructure::mutable_intrinsic() {
  
  if (intrinsic_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Infrastructure_Intrinsic>(GetArenaNoVirtual());
    intrinsic_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Infrastructure.intrinsic)
  return intrinsic_;
}
inline void Infrastructure::set_allocated_intrinsic(::sim_msg::Infrastructure_Intrinsic* intrinsic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete intrinsic_;
  }
  if (intrinsic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      intrinsic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, intrinsic, submessage_arena);
    }
    
  } else {
    
  }
  intrinsic_ = intrinsic;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Infrastructure.intrinsic)
}

// .sim_msg.Waypoint waypoint = 4;
inline bool Infrastructure::has_waypoint() const {
  return this != internal_default_instance() && waypoint_ != nullptr;
}
inline const ::sim_msg::Waypoint& Infrastructure::waypoint() const {
  const ::sim_msg::Waypoint* p = waypoint_;
  // @@protoc_insertion_point(field_get:sim_msg.Infrastructure.waypoint)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Waypoint*>(
      &::sim_msg::_Waypoint_default_instance_);
}
inline ::sim_msg::Waypoint* Infrastructure::release_waypoint() {
  // @@protoc_insertion_point(field_release:sim_msg.Infrastructure.waypoint)
  
  ::sim_msg::Waypoint* temp = waypoint_;
  waypoint_ = nullptr;
  return temp;
}
inline ::sim_msg::Waypoint* Infrastructure::mutable_waypoint() {
  
  if (waypoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Waypoint>(GetArenaNoVirtual());
    waypoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Infrastructure.waypoint)
  return waypoint_;
}
inline void Infrastructure::set_allocated_waypoint(::sim_msg::Waypoint* waypoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(waypoint_);
  }
  if (waypoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      waypoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, waypoint, submessage_arena);
    }
    
  } else {
    
  }
  waypoint_ = waypoint;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Infrastructure.waypoint)
}

// -------------------------------------------------------------------

// InfrastructureGroup

// string name = 1;
inline void InfrastructureGroup::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& InfrastructureGroup::name() const {
  // @@protoc_insertion_point(field_get:sim_msg.InfrastructureGroup.name)
  return name_.GetNoArena();
}
inline void InfrastructureGroup::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.InfrastructureGroup.name)
}
inline void InfrastructureGroup::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.InfrastructureGroup.name)
}
inline void InfrastructureGroup::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.InfrastructureGroup.name)
}
inline void InfrastructureGroup::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.InfrastructureGroup.name)
}
inline std::string* InfrastructureGroup::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.InfrastructureGroup.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InfrastructureGroup::release_name() {
  // @@protoc_insertion_point(field_release:sim_msg.InfrastructureGroup.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InfrastructureGroup::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.InfrastructureGroup.name)
}

// repeated .sim_msg.Infrastructure Infrastructure = 2;
inline int InfrastructureGroup::infrastructure_size() const {
  return infrastructure_.size();
}
inline void InfrastructureGroup::clear_infrastructure() {
  infrastructure_.Clear();
}
inline ::sim_msg::Infrastructure* InfrastructureGroup::mutable_infrastructure(int index) {
  // @@protoc_insertion_point(field_mutable:sim_msg.InfrastructureGroup.Infrastructure)
  return infrastructure_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Infrastructure >*
InfrastructureGroup::mutable_infrastructure() {
  // @@protoc_insertion_point(field_mutable_list:sim_msg.InfrastructureGroup.Infrastructure)
  return &infrastructure_;
}
inline const ::sim_msg::Infrastructure& InfrastructureGroup::infrastructure(int index) const {
  // @@protoc_insertion_point(field_get:sim_msg.InfrastructureGroup.Infrastructure)
  return infrastructure_.Get(index);
}
inline ::sim_msg::Infrastructure* InfrastructureGroup::add_infrastructure() {
  // @@protoc_insertion_point(field_add:sim_msg.InfrastructureGroup.Infrastructure)
  return infrastructure_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Infrastructure >&
InfrastructureGroup::infrastructure() const {
  // @@protoc_insertion_point(field_list:sim_msg.InfrastructureGroup.Infrastructure)
  return infrastructure_;
}

// int32 active_plan = 3;
inline void InfrastructureGroup::clear_active_plan() {
  active_plan_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InfrastructureGroup::active_plan() const {
  // @@protoc_insertion_point(field_get:sim_msg.InfrastructureGroup.active_plan)
  return active_plan_;
}
inline void InfrastructureGroup::set_active_plan(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  active_plan_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.InfrastructureGroup.active_plan)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sim_msg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sim_msg::InfrastructureType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::InfrastructureType>() {
  return ::sim_msg::InfrastructureType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_scene_5finfrastructure_5fgroup_2eproto
