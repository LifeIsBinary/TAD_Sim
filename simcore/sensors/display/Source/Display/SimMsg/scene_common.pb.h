// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scene_common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_scene_5fcommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_scene_5fcommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_scene_5fcommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_scene_5fcommon_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_scene_5fcommon_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace sim_msg {

enum OnOff : int {
  ONOFF_OFF = 0,
  ONOFF_ON = 1,
  OnOff_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OnOff_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OnOff_IsValid(int value);
constexpr OnOff OnOff_MIN = ONOFF_OFF;
constexpr OnOff OnOff_MAX = ONOFF_ON;
constexpr int OnOff_ARRAYSIZE = OnOff_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OnOff_descriptor();
template<typename T>
inline const std::string& OnOff_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OnOff>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OnOff_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OnOff_descriptor(), enum_t_value);
}
inline bool OnOff_Parse(
    const std::string& name, OnOff* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OnOff>(
    OnOff_descriptor(), name, value);
}
enum Dir : int {
  DIR_LEFT = 0,
  DIR_RIGHT = 1,
  DIR_ANY = 2,
  Dir_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Dir_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Dir_IsValid(int value);
constexpr Dir Dir_MIN = DIR_LEFT;
constexpr Dir Dir_MAX = DIR_ANY;
constexpr int Dir_ARRAYSIZE = Dir_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Dir_descriptor();
template<typename T>
inline const std::string& Dir_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Dir>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Dir_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Dir_descriptor(), enum_t_value);
}
inline bool Dir_Parse(
    const std::string& name, Dir* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Dir>(
    Dir_descriptor(), name, value);
}
enum GearSts : int {
  GEAR_STS_D = 0,
  GEAR_STS_P = 1,
  GEAR_STS_R = 2,
  GEAR_STS_N = 3,
  GEAR_STS_M1 = 4,
  GEAR_STS_M2 = 5,
  GEAR_STS_M3 = 6,
  GEAR_STS_M4 = 7,
  GEAR_STS_M5 = 8,
  GEAR_STS_M6 = 9,
  GEAR_STS_M7 = 10,
  GearSts_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  GearSts_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool GearSts_IsValid(int value);
constexpr GearSts GearSts_MIN = GEAR_STS_D;
constexpr GearSts GearSts_MAX = GEAR_STS_M7;
constexpr int GearSts_ARRAYSIZE = GearSts_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GearSts_descriptor();
template<typename T>
inline const std::string& GearSts_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GearSts>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GearSts_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GearSts_descriptor(), enum_t_value);
}
inline bool GearSts_Parse(
    const std::string& name, GearSts* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GearSts>(
    GearSts_descriptor(), name, value);
}
enum WiperSts : int {
  WIPER_STS_OFF = 0,
  WIPER_STS_LOW = 1,
  WIPER_STS_MED = 2,
  WIPER_STS_HIGH = 3,
  WiperSts_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  WiperSts_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool WiperSts_IsValid(int value);
constexpr WiperSts WiperSts_MIN = WIPER_STS_OFF;
constexpr WiperSts WiperSts_MAX = WIPER_STS_HIGH;
constexpr int WiperSts_ARRAYSIZE = WiperSts_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WiperSts_descriptor();
template<typename T>
inline const std::string& WiperSts_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WiperSts>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WiperSts_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WiperSts_descriptor(), enum_t_value);
}
inline bool WiperSts_Parse(
    const std::string& name, WiperSts* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WiperSts>(
    WiperSts_descriptor(), name, value);
}
enum ParkingBrakeSts : int {
  PARKING_BRAKE_STS_RELEASED = 0,
  PARKING_BRAKE_STS_APPLIED = 1,
  PARKING_BRAKE_STS_APPLYING = 2,
  PARKING_BRAKE_STS_RELEASING = 3,
  ParkingBrakeSts_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ParkingBrakeSts_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ParkingBrakeSts_IsValid(int value);
constexpr ParkingBrakeSts ParkingBrakeSts_MIN = PARKING_BRAKE_STS_RELEASED;
constexpr ParkingBrakeSts ParkingBrakeSts_MAX = PARKING_BRAKE_STS_RELEASING;
constexpr int ParkingBrakeSts_ARRAYSIZE = ParkingBrakeSts_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ParkingBrakeSts_descriptor();
template<typename T>
inline const std::string& ParkingBrakeSts_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ParkingBrakeSts>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ParkingBrakeSts_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ParkingBrakeSts_descriptor(), enum_t_value);
}
inline bool ParkingBrakeSts_Parse(
    const std::string& name, ParkingBrakeSts* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ParkingBrakeSts>(
    ParkingBrakeSts_descriptor(), name, value);
}
enum KeySts : int {
  KEY_STS_OFF = 0,
  KEY_STS_IGN = 1,
  KEY_STS_ACC = 2,
  KEY_STS_ON = 3,
  KeySts_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  KeySts_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool KeySts_IsValid(int value);
constexpr KeySts KeySts_MIN = KEY_STS_OFF;
constexpr KeySts KeySts_MAX = KEY_STS_ON;
constexpr int KeySts_ARRAYSIZE = KeySts_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KeySts_descriptor();
template<typename T>
inline const std::string& KeySts_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KeySts>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KeySts_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KeySts_descriptor(), enum_t_value);
}
inline bool KeySts_Parse(
    const std::string& name, KeySts* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KeySts>(
    KeySts_descriptor(), name, value);
}
enum BeamSts : int {
  BEAM_STS_OFF = 0,
  BEAM_STS_AUTO = 1,
  BEAM_STS_LOW = 2,
  BEAM_STS_HIGH = 3,
  BeamSts_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BeamSts_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BeamSts_IsValid(int value);
constexpr BeamSts BeamSts_MIN = BEAM_STS_OFF;
constexpr BeamSts BeamSts_MAX = BEAM_STS_HIGH;
constexpr int BeamSts_ARRAYSIZE = BeamSts_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BeamSts_descriptor();
template<typename T>
inline const std::string& BeamSts_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BeamSts>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BeamSts_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BeamSts_descriptor(), enum_t_value);
}
inline bool BeamSts_Parse(
    const std::string& name, BeamSts* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BeamSts>(
    BeamSts_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace sim_msg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sim_msg::OnOff> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::OnOff>() {
  return ::sim_msg::OnOff_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::Dir> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::Dir>() {
  return ::sim_msg::Dir_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::GearSts> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::GearSts>() {
  return ::sim_msg::GearSts_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::WiperSts> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::WiperSts>() {
  return ::sim_msg::WiperSts_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::ParkingBrakeSts> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::ParkingBrakeSts>() {
  return ::sim_msg::ParkingBrakeSts_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::KeySts> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::KeySts>() {
  return ::sim_msg::KeySts_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::BeamSts> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::BeamSts>() {
  return ::sim_msg::BeamSts_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_scene_5fcommon_2eproto
