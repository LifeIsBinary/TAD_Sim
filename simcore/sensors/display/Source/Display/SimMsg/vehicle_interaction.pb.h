// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vehicle_interaction.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_vehicle_5finteraction_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_vehicle_5finteraction_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "scene_common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_vehicle_5finteraction_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_vehicle_5finteraction_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_vehicle_5finteraction_2eproto;
namespace sim_msg {
class Activate;
class ActivateDefaultTypeInternal;
extern ActivateDefaultTypeInternal _Activate_default_instance_;
class Assign;
class AssignDefaultTypeInternal;
extern AssignDefaultTypeInternal _Assign_default_instance_;
class Assign_Cruise;
class Assign_CruiseDefaultTypeInternal;
extern Assign_CruiseDefaultTypeInternal _Assign_Cruise_default_instance_;
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class Command_LaneChange;
class Command_LaneChangeDefaultTypeInternal;
extern Command_LaneChangeDefaultTypeInternal _Command_LaneChange_default_instance_;
class Command_Overtaking;
class Command_OvertakingDefaultTypeInternal;
extern Command_OvertakingDefaultTypeInternal _Command_Overtaking_default_instance_;
class Override;
class OverrideDefaultTypeInternal;
extern OverrideDefaultTypeInternal _Override_default_instance_;
class Override_Brake;
class Override_BrakeDefaultTypeInternal;
extern Override_BrakeDefaultTypeInternal _Override_Brake_default_instance_;
class Override_Clutch;
class Override_ClutchDefaultTypeInternal;
extern Override_ClutchDefaultTypeInternal _Override_Clutch_default_instance_;
class Override_Gear;
class Override_GearDefaultTypeInternal;
extern Override_GearDefaultTypeInternal _Override_Gear_default_instance_;
class Override_ParkingBrake;
class Override_ParkingBrakeDefaultTypeInternal;
extern Override_ParkingBrakeDefaultTypeInternal _Override_ParkingBrake_default_instance_;
class Override_SteeringWheel;
class Override_SteeringWheelDefaultTypeInternal;
extern Override_SteeringWheelDefaultTypeInternal _Override_SteeringWheel_default_instance_;
class Override_Throttle;
class Override_ThrottleDefaultTypeInternal;
extern Override_ThrottleDefaultTypeInternal _Override_Throttle_default_instance_;
class Status;
class StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class VehicleInteraction;
class VehicleInteractionDefaultTypeInternal;
extern VehicleInteractionDefaultTypeInternal _VehicleInteraction_default_instance_;
}  // namespace sim_msg
PROTOBUF_NAMESPACE_OPEN
template<> ::sim_msg::Activate* Arena::CreateMaybeMessage<::sim_msg::Activate>(Arena*);
template<> ::sim_msg::Assign* Arena::CreateMaybeMessage<::sim_msg::Assign>(Arena*);
template<> ::sim_msg::Assign_Cruise* Arena::CreateMaybeMessage<::sim_msg::Assign_Cruise>(Arena*);
template<> ::sim_msg::Command* Arena::CreateMaybeMessage<::sim_msg::Command>(Arena*);
template<> ::sim_msg::Command_LaneChange* Arena::CreateMaybeMessage<::sim_msg::Command_LaneChange>(Arena*);
template<> ::sim_msg::Command_Overtaking* Arena::CreateMaybeMessage<::sim_msg::Command_Overtaking>(Arena*);
template<> ::sim_msg::Override* Arena::CreateMaybeMessage<::sim_msg::Override>(Arena*);
template<> ::sim_msg::Override_Brake* Arena::CreateMaybeMessage<::sim_msg::Override_Brake>(Arena*);
template<> ::sim_msg::Override_Clutch* Arena::CreateMaybeMessage<::sim_msg::Override_Clutch>(Arena*);
template<> ::sim_msg::Override_Gear* Arena::CreateMaybeMessage<::sim_msg::Override_Gear>(Arena*);
template<> ::sim_msg::Override_ParkingBrake* Arena::CreateMaybeMessage<::sim_msg::Override_ParkingBrake>(Arena*);
template<> ::sim_msg::Override_SteeringWheel* Arena::CreateMaybeMessage<::sim_msg::Override_SteeringWheel>(Arena*);
template<> ::sim_msg::Override_Throttle* Arena::CreateMaybeMessage<::sim_msg::Override_Throttle>(Arena*);
template<> ::sim_msg::Status* Arena::CreateMaybeMessage<::sim_msg::Status>(Arena*);
template<> ::sim_msg::VehicleInteraction* Arena::CreateMaybeMessage<::sim_msg::VehicleInteraction>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sim_msg {

enum Activate_Automode : int {
  Activate_Automode_AUTOMODE_OFF = 0,
  Activate_Automode_AUTOMODE_LATERAL = 1,
  Activate_Automode_AUTOMODE_LONGITUDINAL = 2,
  Activate_Automode_AUTOMODE_AUTOPILOT = 3,
  Activate_Automode_Activate_Automode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Activate_Automode_Activate_Automode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Activate_Automode_IsValid(int value);
constexpr Activate_Automode Activate_Automode_Automode_MIN = Activate_Automode_AUTOMODE_OFF;
constexpr Activate_Automode Activate_Automode_Automode_MAX = Activate_Automode_AUTOMODE_AUTOPILOT;
constexpr int Activate_Automode_Automode_ARRAYSIZE = Activate_Automode_Automode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Activate_Automode_descriptor();
template<typename T>
inline const std::string& Activate_Automode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Activate_Automode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Activate_Automode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Activate_Automode_descriptor(), enum_t_value);
}
inline bool Activate_Automode_Parse(
    const std::string& name, Activate_Automode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Activate_Automode>(
    Activate_Automode_descriptor(), name, value);
}
// ===================================================================

class Activate :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Activate) */ {
 public:
  Activate();
  virtual ~Activate();

  Activate(const Activate& from);
  Activate(Activate&& from) noexcept
    : Activate() {
    *this = ::std::move(from);
  }

  inline Activate& operator=(const Activate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Activate& operator=(Activate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Activate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Activate* internal_default_instance() {
    return reinterpret_cast<const Activate*>(
               &_Activate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Activate& a, Activate& b) {
    a.Swap(&b);
  }
  inline void Swap(Activate* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Activate* New() const final {
    return CreateMaybeMessage<Activate>(nullptr);
  }

  Activate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Activate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Activate& from);
  void MergeFrom(const Activate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Activate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Activate";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vehicle_5finteraction_2eproto);
    return ::descriptor_table_vehicle_5finteraction_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Activate_Automode Automode;
  static constexpr Automode AUTOMODE_OFF =
    Activate_Automode_AUTOMODE_OFF;
  static constexpr Automode AUTOMODE_LATERAL =
    Activate_Automode_AUTOMODE_LATERAL;
  static constexpr Automode AUTOMODE_LONGITUDINAL =
    Activate_Automode_AUTOMODE_LONGITUDINAL;
  static constexpr Automode AUTOMODE_AUTOPILOT =
    Activate_Automode_AUTOMODE_AUTOPILOT;
  static inline bool Automode_IsValid(int value) {
    return Activate_Automode_IsValid(value);
  }
  static constexpr Automode Automode_MIN =
    Activate_Automode_Automode_MIN;
  static constexpr Automode Automode_MAX =
    Activate_Automode_Automode_MAX;
  static constexpr int Automode_ARRAYSIZE =
    Activate_Automode_Automode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Automode_descriptor() {
    return Activate_Automode_descriptor();
  }
  template<typename T>
  static inline const std::string& Automode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Automode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Automode_Name.");
    return Activate_Automode_Name(enum_t_value);
  }
  static inline bool Automode_Parse(const std::string& name,
      Automode* value) {
    return Activate_Automode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAutomodeFieldNumber = 1,
  };
  // .sim_msg.Activate.Automode automode = 1;
  void clear_automode();
  ::sim_msg::Activate_Automode automode() const;
  void set_automode(::sim_msg::Activate_Automode value);

  // @@protoc_insertion_point(class_scope:sim_msg.Activate)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int automode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vehicle_5finteraction_2eproto;
};
// -------------------------------------------------------------------

class Assign_Cruise :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Assign.Cruise) */ {
 public:
  Assign_Cruise();
  virtual ~Assign_Cruise();

  Assign_Cruise(const Assign_Cruise& from);
  Assign_Cruise(Assign_Cruise&& from) noexcept
    : Assign_Cruise() {
    *this = ::std::move(from);
  }

  inline Assign_Cruise& operator=(const Assign_Cruise& from) {
    CopyFrom(from);
    return *this;
  }
  inline Assign_Cruise& operator=(Assign_Cruise&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Assign_Cruise& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Assign_Cruise* internal_default_instance() {
    return reinterpret_cast<const Assign_Cruise*>(
               &_Assign_Cruise_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Assign_Cruise& a, Assign_Cruise& b) {
    a.Swap(&b);
  }
  inline void Swap(Assign_Cruise* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Assign_Cruise* New() const final {
    return CreateMaybeMessage<Assign_Cruise>(nullptr);
  }

  Assign_Cruise* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Assign_Cruise>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Assign_Cruise& from);
  void MergeFrom(const Assign_Cruise& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Assign_Cruise* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Assign.Cruise";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vehicle_5finteraction_2eproto);
    return ::descriptor_table_vehicle_5finteraction_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResumeSwFieldNumber = 1,
    kCancelSwFieldNumber = 2,
    kSpeedIncSwFieldNumber = 3,
    kSpeedDecSwFieldNumber = 4,
    kSetTimegapFieldNumber = 5,
    kSetSpeedFieldNumber = 6,
  };
  // .sim_msg.OnOff resume_sw = 1;
  void clear_resume_sw();
  ::sim_msg::OnOff resume_sw() const;
  void set_resume_sw(::sim_msg::OnOff value);

  // .sim_msg.OnOff cancel_sw = 2;
  void clear_cancel_sw();
  ::sim_msg::OnOff cancel_sw() const;
  void set_cancel_sw(::sim_msg::OnOff value);

  // .sim_msg.OnOff speed_inc_sw = 3;
  void clear_speed_inc_sw();
  ::sim_msg::OnOff speed_inc_sw() const;
  void set_speed_inc_sw(::sim_msg::OnOff value);

  // .sim_msg.OnOff speed_dec_sw = 4;
  void clear_speed_dec_sw();
  ::sim_msg::OnOff speed_dec_sw() const;
  void set_speed_dec_sw(::sim_msg::OnOff value);

  // double set_timegap = 5;
  void clear_set_timegap();
  double set_timegap() const;
  void set_set_timegap(double value);

  // double set_speed = 6;
  void clear_set_speed();
  double set_speed() const;
  void set_set_speed(double value);

  // @@protoc_insertion_point(class_scope:sim_msg.Assign.Cruise)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int resume_sw_;
  int cancel_sw_;
  int speed_inc_sw_;
  int speed_dec_sw_;
  double set_timegap_;
  double set_speed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vehicle_5finteraction_2eproto;
};
// -------------------------------------------------------------------

class Assign :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Assign) */ {
 public:
  Assign();
  virtual ~Assign();

  Assign(const Assign& from);
  Assign(Assign&& from) noexcept
    : Assign() {
    *this = ::std::move(from);
  }

  inline Assign& operator=(const Assign& from) {
    CopyFrom(from);
    return *this;
  }
  inline Assign& operator=(Assign&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Assign& default_instance();

  enum PropertiesCase {
    kNone = 2,
    kCruise = 3,
    PROPERTIES_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Assign* internal_default_instance() {
    return reinterpret_cast<const Assign*>(
               &_Assign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Assign& a, Assign& b) {
    a.Swap(&b);
  }
  inline void Swap(Assign* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Assign* New() const final {
    return CreateMaybeMessage<Assign>(nullptr);
  }

  Assign* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Assign>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Assign& from);
  void MergeFrom(const Assign& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Assign* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Assign";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vehicle_5finteraction_2eproto);
    return ::descriptor_table_vehicle_5finteraction_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Assign_Cruise Cruise;

  // accessors -------------------------------------------------------

  enum : int {
    kControllerNameFieldNumber = 1,
    kNoneFieldNumber = 2,
    kCruiseFieldNumber = 3,
  };
  // string controller_name = 1;
  void clear_controller_name();
  const std::string& controller_name() const;
  void set_controller_name(const std::string& value);
  void set_controller_name(std::string&& value);
  void set_controller_name(const char* value);
  void set_controller_name(const char* value, size_t size);
  std::string* mutable_controller_name();
  std::string* release_controller_name();
  void set_allocated_controller_name(std::string* controller_name);

  // string none = 2;
  private:
  bool has_none() const;
  public:
  void clear_none();
  const std::string& none() const;
  void set_none(const std::string& value);
  void set_none(std::string&& value);
  void set_none(const char* value);
  void set_none(const char* value, size_t size);
  std::string* mutable_none();
  std::string* release_none();
  void set_allocated_none(std::string* none);

  // .sim_msg.Assign.Cruise cruise = 3;
  bool has_cruise() const;
  void clear_cruise();
  const ::sim_msg::Assign_Cruise& cruise() const;
  ::sim_msg::Assign_Cruise* release_cruise();
  ::sim_msg::Assign_Cruise* mutable_cruise();
  void set_allocated_cruise(::sim_msg::Assign_Cruise* cruise);

  void clear_properties();
  PropertiesCase properties_case() const;
  // @@protoc_insertion_point(class_scope:sim_msg.Assign)
 private:
  class _Internal;
  void set_has_none();
  void set_has_cruise();

  inline bool has_properties() const;
  inline void clear_has_properties();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr controller_name_;
  union PropertiesUnion {
    PropertiesUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr none_;
    ::sim_msg::Assign_Cruise* cruise_;
  } properties_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_vehicle_5finteraction_2eproto;
};
// -------------------------------------------------------------------

class Override_Throttle :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Override.Throttle) */ {
 public:
  Override_Throttle();
  virtual ~Override_Throttle();

  Override_Throttle(const Override_Throttle& from);
  Override_Throttle(Override_Throttle&& from) noexcept
    : Override_Throttle() {
    *this = ::std::move(from);
  }

  inline Override_Throttle& operator=(const Override_Throttle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Override_Throttle& operator=(Override_Throttle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Override_Throttle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Override_Throttle* internal_default_instance() {
    return reinterpret_cast<const Override_Throttle*>(
               &_Override_Throttle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Override_Throttle& a, Override_Throttle& b) {
    a.Swap(&b);
  }
  inline void Swap(Override_Throttle* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Override_Throttle* New() const final {
    return CreateMaybeMessage<Override_Throttle>(nullptr);
  }

  Override_Throttle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Override_Throttle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Override_Throttle& from);
  void MergeFrom(const Override_Throttle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Override_Throttle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Override.Throttle";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vehicle_5finteraction_2eproto);
    return ::descriptor_table_vehicle_5finteraction_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kActionFieldNumber = 1,
  };
  // double value = 2;
  void clear_value();
  double value() const;
  void set_value(double value);

  // .sim_msg.OnOff action = 1;
  void clear_action();
  ::sim_msg::OnOff action() const;
  void set_action(::sim_msg::OnOff value);

  // @@protoc_insertion_point(class_scope:sim_msg.Override.Throttle)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double value_;
  int action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vehicle_5finteraction_2eproto;
};
// -------------------------------------------------------------------

class Override_Brake :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Override.Brake) */ {
 public:
  Override_Brake();
  virtual ~Override_Brake();

  Override_Brake(const Override_Brake& from);
  Override_Brake(Override_Brake&& from) noexcept
    : Override_Brake() {
    *this = ::std::move(from);
  }

  inline Override_Brake& operator=(const Override_Brake& from) {
    CopyFrom(from);
    return *this;
  }
  inline Override_Brake& operator=(Override_Brake&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Override_Brake& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Override_Brake* internal_default_instance() {
    return reinterpret_cast<const Override_Brake*>(
               &_Override_Brake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Override_Brake& a, Override_Brake& b) {
    a.Swap(&b);
  }
  inline void Swap(Override_Brake* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Override_Brake* New() const final {
    return CreateMaybeMessage<Override_Brake>(nullptr);
  }

  Override_Brake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Override_Brake>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Override_Brake& from);
  void MergeFrom(const Override_Brake& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Override_Brake* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Override.Brake";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vehicle_5finteraction_2eproto);
    return ::descriptor_table_vehicle_5finteraction_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kActionFieldNumber = 1,
  };
  // double value = 2;
  void clear_value();
  double value() const;
  void set_value(double value);

  // .sim_msg.OnOff action = 1;
  void clear_action();
  ::sim_msg::OnOff action() const;
  void set_action(::sim_msg::OnOff value);

  // @@protoc_insertion_point(class_scope:sim_msg.Override.Brake)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double value_;
  int action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vehicle_5finteraction_2eproto;
};
// -------------------------------------------------------------------

class Override_SteeringWheel :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Override.SteeringWheel) */ {
 public:
  Override_SteeringWheel();
  virtual ~Override_SteeringWheel();

  Override_SteeringWheel(const Override_SteeringWheel& from);
  Override_SteeringWheel(Override_SteeringWheel&& from) noexcept
    : Override_SteeringWheel() {
    *this = ::std::move(from);
  }

  inline Override_SteeringWheel& operator=(const Override_SteeringWheel& from) {
    CopyFrom(from);
    return *this;
  }
  inline Override_SteeringWheel& operator=(Override_SteeringWheel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Override_SteeringWheel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Override_SteeringWheel* internal_default_instance() {
    return reinterpret_cast<const Override_SteeringWheel*>(
               &_Override_SteeringWheel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Override_SteeringWheel& a, Override_SteeringWheel& b) {
    a.Swap(&b);
  }
  inline void Swap(Override_SteeringWheel* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Override_SteeringWheel* New() const final {
    return CreateMaybeMessage<Override_SteeringWheel>(nullptr);
  }

  Override_SteeringWheel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Override_SteeringWheel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Override_SteeringWheel& from);
  void MergeFrom(const Override_SteeringWheel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Override_SteeringWheel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Override.SteeringWheel";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vehicle_5finteraction_2eproto);
    return ::descriptor_table_vehicle_5finteraction_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kActionFieldNumber = 1,
  };
  // double value = 2;
  void clear_value();
  double value() const;
  void set_value(double value);

  // .sim_msg.OnOff action = 1;
  void clear_action();
  ::sim_msg::OnOff action() const;
  void set_action(::sim_msg::OnOff value);

  // @@protoc_insertion_point(class_scope:sim_msg.Override.SteeringWheel)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double value_;
  int action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vehicle_5finteraction_2eproto;
};
// -------------------------------------------------------------------

class Override_ParkingBrake :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Override.ParkingBrake) */ {
 public:
  Override_ParkingBrake();
  virtual ~Override_ParkingBrake();

  Override_ParkingBrake(const Override_ParkingBrake& from);
  Override_ParkingBrake(Override_ParkingBrake&& from) noexcept
    : Override_ParkingBrake() {
    *this = ::std::move(from);
  }

  inline Override_ParkingBrake& operator=(const Override_ParkingBrake& from) {
    CopyFrom(from);
    return *this;
  }
  inline Override_ParkingBrake& operator=(Override_ParkingBrake&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Override_ParkingBrake& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Override_ParkingBrake* internal_default_instance() {
    return reinterpret_cast<const Override_ParkingBrake*>(
               &_Override_ParkingBrake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Override_ParkingBrake& a, Override_ParkingBrake& b) {
    a.Swap(&b);
  }
  inline void Swap(Override_ParkingBrake* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Override_ParkingBrake* New() const final {
    return CreateMaybeMessage<Override_ParkingBrake>(nullptr);
  }

  Override_ParkingBrake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Override_ParkingBrake>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Override_ParkingBrake& from);
  void MergeFrom(const Override_ParkingBrake& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Override_ParkingBrake* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Override.ParkingBrake";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vehicle_5finteraction_2eproto);
    return ::descriptor_table_vehicle_5finteraction_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // .sim_msg.OnOff action = 1;
  void clear_action();
  ::sim_msg::OnOff action() const;
  void set_action(::sim_msg::OnOff value);

  // .sim_msg.ParkingBrakeSts value = 2;
  void clear_value();
  ::sim_msg::ParkingBrakeSts value() const;
  void set_value(::sim_msg::ParkingBrakeSts value);

  // @@protoc_insertion_point(class_scope:sim_msg.Override.ParkingBrake)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int action_;
  int value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vehicle_5finteraction_2eproto;
};
// -------------------------------------------------------------------

class Override_Clutch :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Override.Clutch) */ {
 public:
  Override_Clutch();
  virtual ~Override_Clutch();

  Override_Clutch(const Override_Clutch& from);
  Override_Clutch(Override_Clutch&& from) noexcept
    : Override_Clutch() {
    *this = ::std::move(from);
  }

  inline Override_Clutch& operator=(const Override_Clutch& from) {
    CopyFrom(from);
    return *this;
  }
  inline Override_Clutch& operator=(Override_Clutch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Override_Clutch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Override_Clutch* internal_default_instance() {
    return reinterpret_cast<const Override_Clutch*>(
               &_Override_Clutch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Override_Clutch& a, Override_Clutch& b) {
    a.Swap(&b);
  }
  inline void Swap(Override_Clutch* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Override_Clutch* New() const final {
    return CreateMaybeMessage<Override_Clutch>(nullptr);
  }

  Override_Clutch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Override_Clutch>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Override_Clutch& from);
  void MergeFrom(const Override_Clutch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Override_Clutch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Override.Clutch";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vehicle_5finteraction_2eproto);
    return ::descriptor_table_vehicle_5finteraction_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kActionFieldNumber = 1,
  };
  // double value = 2;
  void clear_value();
  double value() const;
  void set_value(double value);

  // .sim_msg.OnOff action = 1;
  void clear_action();
  ::sim_msg::OnOff action() const;
  void set_action(::sim_msg::OnOff value);

  // @@protoc_insertion_point(class_scope:sim_msg.Override.Clutch)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double value_;
  int action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vehicle_5finteraction_2eproto;
};
// -------------------------------------------------------------------

class Override_Gear :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Override.Gear) */ {
 public:
  Override_Gear();
  virtual ~Override_Gear();

  Override_Gear(const Override_Gear& from);
  Override_Gear(Override_Gear&& from) noexcept
    : Override_Gear() {
    *this = ::std::move(from);
  }

  inline Override_Gear& operator=(const Override_Gear& from) {
    CopyFrom(from);
    return *this;
  }
  inline Override_Gear& operator=(Override_Gear&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Override_Gear& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Override_Gear* internal_default_instance() {
    return reinterpret_cast<const Override_Gear*>(
               &_Override_Gear_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Override_Gear& a, Override_Gear& b) {
    a.Swap(&b);
  }
  inline void Swap(Override_Gear* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Override_Gear* New() const final {
    return CreateMaybeMessage<Override_Gear>(nullptr);
  }

  Override_Gear* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Override_Gear>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Override_Gear& from);
  void MergeFrom(const Override_Gear& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Override_Gear* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Override.Gear";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vehicle_5finteraction_2eproto);
    return ::descriptor_table_vehicle_5finteraction_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // .sim_msg.OnOff action = 1;
  void clear_action();
  ::sim_msg::OnOff action() const;
  void set_action(::sim_msg::OnOff value);

  // .sim_msg.GearSts value = 2;
  void clear_value();
  ::sim_msg::GearSts value() const;
  void set_value(::sim_msg::GearSts value);

  // @@protoc_insertion_point(class_scope:sim_msg.Override.Gear)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int action_;
  int value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vehicle_5finteraction_2eproto;
};
// -------------------------------------------------------------------

class Override :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Override) */ {
 public:
  Override();
  virtual ~Override();

  Override(const Override& from);
  Override(Override&& from) noexcept
    : Override() {
    *this = ::std::move(from);
  }

  inline Override& operator=(const Override& from) {
    CopyFrom(from);
    return *this;
  }
  inline Override& operator=(Override&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Override& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Override* internal_default_instance() {
    return reinterpret_cast<const Override*>(
               &_Override_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Override& a, Override& b) {
    a.Swap(&b);
  }
  inline void Swap(Override* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Override* New() const final {
    return CreateMaybeMessage<Override>(nullptr);
  }

  Override* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Override>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Override& from);
  void MergeFrom(const Override& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Override* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Override";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vehicle_5finteraction_2eproto);
    return ::descriptor_table_vehicle_5finteraction_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Override_Throttle Throttle;
  typedef Override_Brake Brake;
  typedef Override_SteeringWheel SteeringWheel;
  typedef Override_ParkingBrake ParkingBrake;
  typedef Override_Clutch Clutch;
  typedef Override_Gear Gear;

  // accessors -------------------------------------------------------

  enum : int {
    kThrottleFieldNumber = 1,
    kBrakeFieldNumber = 2,
    kSteeringWheelFieldNumber = 3,
    kParkingBrakeFieldNumber = 4,
    kClutchFieldNumber = 5,
    kGearFieldNumber = 6,
  };
  // .sim_msg.Override.Throttle throttle = 1;
  bool has_throttle() const;
  void clear_throttle();
  const ::sim_msg::Override_Throttle& throttle() const;
  ::sim_msg::Override_Throttle* release_throttle();
  ::sim_msg::Override_Throttle* mutable_throttle();
  void set_allocated_throttle(::sim_msg::Override_Throttle* throttle);

  // .sim_msg.Override.Brake brake = 2;
  bool has_brake() const;
  void clear_brake();
  const ::sim_msg::Override_Brake& brake() const;
  ::sim_msg::Override_Brake* release_brake();
  ::sim_msg::Override_Brake* mutable_brake();
  void set_allocated_brake(::sim_msg::Override_Brake* brake);

  // .sim_msg.Override.SteeringWheel steering_wheel = 3;
  bool has_steering_wheel() const;
  void clear_steering_wheel();
  const ::sim_msg::Override_SteeringWheel& steering_wheel() const;
  ::sim_msg::Override_SteeringWheel* release_steering_wheel();
  ::sim_msg::Override_SteeringWheel* mutable_steering_wheel();
  void set_allocated_steering_wheel(::sim_msg::Override_SteeringWheel* steering_wheel);

  // .sim_msg.Override.ParkingBrake parking_brake = 4;
  bool has_parking_brake() const;
  void clear_parking_brake();
  const ::sim_msg::Override_ParkingBrake& parking_brake() const;
  ::sim_msg::Override_ParkingBrake* release_parking_brake();
  ::sim_msg::Override_ParkingBrake* mutable_parking_brake();
  void set_allocated_parking_brake(::sim_msg::Override_ParkingBrake* parking_brake);

  // .sim_msg.Override.Clutch clutch = 5;
  bool has_clutch() const;
  void clear_clutch();
  const ::sim_msg::Override_Clutch& clutch() const;
  ::sim_msg::Override_Clutch* release_clutch();
  ::sim_msg::Override_Clutch* mutable_clutch();
  void set_allocated_clutch(::sim_msg::Override_Clutch* clutch);

  // .sim_msg.Override.Gear gear = 6;
  bool has_gear() const;
  void clear_gear();
  const ::sim_msg::Override_Gear& gear() const;
  ::sim_msg::Override_Gear* release_gear();
  ::sim_msg::Override_Gear* mutable_gear();
  void set_allocated_gear(::sim_msg::Override_Gear* gear);

  // @@protoc_insertion_point(class_scope:sim_msg.Override)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::sim_msg::Override_Throttle* throttle_;
  ::sim_msg::Override_Brake* brake_;
  ::sim_msg::Override_SteeringWheel* steering_wheel_;
  ::sim_msg::Override_ParkingBrake* parking_brake_;
  ::sim_msg::Override_Clutch* clutch_;
  ::sim_msg::Override_Gear* gear_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vehicle_5finteraction_2eproto;
};
// -------------------------------------------------------------------

class Command_LaneChange :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Command.LaneChange) */ {
 public:
  Command_LaneChange();
  virtual ~Command_LaneChange();

  Command_LaneChange(const Command_LaneChange& from);
  Command_LaneChange(Command_LaneChange&& from) noexcept
    : Command_LaneChange() {
    *this = ::std::move(from);
  }

  inline Command_LaneChange& operator=(const Command_LaneChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline Command_LaneChange& operator=(Command_LaneChange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Command_LaneChange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command_LaneChange* internal_default_instance() {
    return reinterpret_cast<const Command_LaneChange*>(
               &_Command_LaneChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Command_LaneChange& a, Command_LaneChange& b) {
    a.Swap(&b);
  }
  inline void Swap(Command_LaneChange* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Command_LaneChange* New() const final {
    return CreateMaybeMessage<Command_LaneChange>(nullptr);
  }

  Command_LaneChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Command_LaneChange>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Command_LaneChange& from);
  void MergeFrom(const Command_LaneChange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command_LaneChange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Command.LaneChange";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vehicle_5finteraction_2eproto);
    return ::descriptor_table_vehicle_5finteraction_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // .sim_msg.OnOff action = 1;
  void clear_action();
  ::sim_msg::OnOff action() const;
  void set_action(::sim_msg::OnOff value);

  // .sim_msg.Dir value = 2;
  void clear_value();
  ::sim_msg::Dir value() const;
  void set_value(::sim_msg::Dir value);

  // @@protoc_insertion_point(class_scope:sim_msg.Command.LaneChange)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int action_;
  int value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vehicle_5finteraction_2eproto;
};
// -------------------------------------------------------------------

class Command_Overtaking :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Command.Overtaking) */ {
 public:
  Command_Overtaking();
  virtual ~Command_Overtaking();

  Command_Overtaking(const Command_Overtaking& from);
  Command_Overtaking(Command_Overtaking&& from) noexcept
    : Command_Overtaking() {
    *this = ::std::move(from);
  }

  inline Command_Overtaking& operator=(const Command_Overtaking& from) {
    CopyFrom(from);
    return *this;
  }
  inline Command_Overtaking& operator=(Command_Overtaking&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Command_Overtaking& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command_Overtaking* internal_default_instance() {
    return reinterpret_cast<const Command_Overtaking*>(
               &_Command_Overtaking_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Command_Overtaking& a, Command_Overtaking& b) {
    a.Swap(&b);
  }
  inline void Swap(Command_Overtaking* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Command_Overtaking* New() const final {
    return CreateMaybeMessage<Command_Overtaking>(nullptr);
  }

  Command_Overtaking* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Command_Overtaking>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Command_Overtaking& from);
  void MergeFrom(const Command_Overtaking& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command_Overtaking* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Command.Overtaking";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vehicle_5finteraction_2eproto);
    return ::descriptor_table_vehicle_5finteraction_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // .sim_msg.OnOff action = 1;
  void clear_action();
  ::sim_msg::OnOff action() const;
  void set_action(::sim_msg::OnOff value);

  // .sim_msg.Dir value = 2;
  void clear_value();
  ::sim_msg::Dir value() const;
  void set_value(::sim_msg::Dir value);

  // @@protoc_insertion_point(class_scope:sim_msg.Command.Overtaking)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int action_;
  int value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vehicle_5finteraction_2eproto;
};
// -------------------------------------------------------------------

class Command :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  inline Command& operator=(Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Command& default_instance();

  enum TypeCase {
    kUserDefine = 1,
    kLaneChange = 2,
    kOvertaking = 3,
    kPullOver = 4,
    kEmergencyStop = 5,
    kLateralSpeedToLeft = 6,
    kLateralSpeedToRight = 7,
    kLateralAccelToLeft = 8,
    kLateralAccelToRight = 9,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }
  inline void Swap(Command* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return CreateMaybeMessage<Command>(nullptr);
  }

  Command* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Command";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vehicle_5finteraction_2eproto);
    return ::descriptor_table_vehicle_5finteraction_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Command_LaneChange LaneChange;
  typedef Command_Overtaking Overtaking;

  // accessors -------------------------------------------------------

  enum : int {
    kUserDefineFieldNumber = 1,
    kLaneChangeFieldNumber = 2,
    kOvertakingFieldNumber = 3,
    kPullOverFieldNumber = 4,
    kEmergencyStopFieldNumber = 5,
    kLateralSpeedToLeftFieldNumber = 6,
    kLateralSpeedToRightFieldNumber = 7,
    kLateralAccelToLeftFieldNumber = 8,
    kLateralAccelToRightFieldNumber = 9,
  };
  // bytes user_define = 1;
  private:
  bool has_user_define() const;
  public:
  void clear_user_define();
  const std::string& user_define() const;
  void set_user_define(const std::string& value);
  void set_user_define(std::string&& value);
  void set_user_define(const char* value);
  void set_user_define(const void* value, size_t size);
  std::string* mutable_user_define();
  std::string* release_user_define();
  void set_allocated_user_define(std::string* user_define);

  // .sim_msg.Command.LaneChange lane_change = 2;
  bool has_lane_change() const;
  void clear_lane_change();
  const ::sim_msg::Command_LaneChange& lane_change() const;
  ::sim_msg::Command_LaneChange* release_lane_change();
  ::sim_msg::Command_LaneChange* mutable_lane_change();
  void set_allocated_lane_change(::sim_msg::Command_LaneChange* lane_change);

  // .sim_msg.Command.Overtaking overtaking = 3;
  bool has_overtaking() const;
  void clear_overtaking();
  const ::sim_msg::Command_Overtaking& overtaking() const;
  ::sim_msg::Command_Overtaking* release_overtaking();
  ::sim_msg::Command_Overtaking* mutable_overtaking();
  void set_allocated_overtaking(::sim_msg::Command_Overtaking* overtaking);

  // .sim_msg.OnOff pull_over = 4;
  private:
  bool has_pull_over() const;
  public:
  void clear_pull_over();
  ::sim_msg::OnOff pull_over() const;
  void set_pull_over(::sim_msg::OnOff value);

  // .sim_msg.OnOff emergency_stop = 5;
  private:
  bool has_emergency_stop() const;
  public:
  void clear_emergency_stop();
  ::sim_msg::OnOff emergency_stop() const;
  void set_emergency_stop(::sim_msg::OnOff value);

  // double lateral_speed_to_left = 6;
  private:
  bool has_lateral_speed_to_left() const;
  public:
  void clear_lateral_speed_to_left();
  double lateral_speed_to_left() const;
  void set_lateral_speed_to_left(double value);

  // double lateral_speed_to_right = 7;
  private:
  bool has_lateral_speed_to_right() const;
  public:
  void clear_lateral_speed_to_right();
  double lateral_speed_to_right() const;
  void set_lateral_speed_to_right(double value);

  // double lateral_accel_to_left = 8;
  private:
  bool has_lateral_accel_to_left() const;
  public:
  void clear_lateral_accel_to_left();
  double lateral_accel_to_left() const;
  void set_lateral_accel_to_left(double value);

  // double lateral_accel_to_right = 9;
  private:
  bool has_lateral_accel_to_right() const;
  public:
  void clear_lateral_accel_to_right();
  double lateral_accel_to_right() const;
  void set_lateral_accel_to_right(double value);

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:sim_msg.Command)
 private:
  class _Internal;
  void set_has_user_define();
  void set_has_lane_change();
  void set_has_overtaking();
  void set_has_pull_over();
  void set_has_emergency_stop();
  void set_has_lateral_speed_to_left();
  void set_has_lateral_speed_to_right();
  void set_has_lateral_accel_to_left();
  void set_has_lateral_accel_to_right();

  inline bool has_type() const;
  inline void clear_has_type();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union TypeUnion {
    TypeUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_define_;
    ::sim_msg::Command_LaneChange* lane_change_;
    ::sim_msg::Command_Overtaking* overtaking_;
    int pull_over_;
    int emergency_stop_;
    double lateral_speed_to_left_;
    double lateral_speed_to_right_;
    double lateral_accel_to_left_;
    double lateral_accel_to_right_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_vehicle_5finteraction_2eproto;
};
// -------------------------------------------------------------------

class Status :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Status) */ {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Status& default_instance();

  enum TypeCase {
    kUserDefine = 1,
    kEmergencyBrake = 2,
    kVehicleLostControl = 3,
    kHandsOnSteeringwheel = 4,
    kEyesOnRoad = 5,
    kLidar = 6,
    kRadar = 7,
    kUltrasonic = 8,
    kCamera = 9,
    kGnss = 10,
    kImu = 11,
    kLocalization = 12,
    kBeam = 13,
    kBrakeLight = 14,
    kHazardLight = 15,
    kLeftTurnLight = 16,
    kRightTurnLight = 17,
    kDriverSeatbelt = 18,
    kPassengerSeatbelt = 19,
    kDriverDoor = 20,
    kPassengerDoor = 21,
    kHood = 22,
    kTrunk = 23,
    kParkingbrake = 24,
    kWiper = 25,
    kGear = 26,
    kKey = 27,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Status* New() const final {
    return CreateMaybeMessage<Status>(nullptr);
  }

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Status";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vehicle_5finteraction_2eproto);
    return ::descriptor_table_vehicle_5finteraction_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserDefineFieldNumber = 1,
    kEmergencyBrakeFieldNumber = 2,
    kVehicleLostControlFieldNumber = 3,
    kHandsOnSteeringwheelFieldNumber = 4,
    kEyesOnRoadFieldNumber = 5,
    kLidarFieldNumber = 6,
    kRadarFieldNumber = 7,
    kUltrasonicFieldNumber = 8,
    kCameraFieldNumber = 9,
    kGnssFieldNumber = 10,
    kImuFieldNumber = 11,
    kLocalizationFieldNumber = 12,
    kBeamFieldNumber = 13,
    kBrakeLightFieldNumber = 14,
    kHazardLightFieldNumber = 15,
    kLeftTurnLightFieldNumber = 16,
    kRightTurnLightFieldNumber = 17,
    kDriverSeatbeltFieldNumber = 18,
    kPassengerSeatbeltFieldNumber = 19,
    kDriverDoorFieldNumber = 20,
    kPassengerDoorFieldNumber = 21,
    kHoodFieldNumber = 22,
    kTrunkFieldNumber = 23,
    kParkingbrakeFieldNumber = 24,
    kWiperFieldNumber = 25,
    kGearFieldNumber = 26,
    kKeyFieldNumber = 27,
  };
  // bytes user_define = 1;
  private:
  bool has_user_define() const;
  public:
  void clear_user_define();
  const std::string& user_define() const;
  void set_user_define(const std::string& value);
  void set_user_define(std::string&& value);
  void set_user_define(const char* value);
  void set_user_define(const void* value, size_t size);
  std::string* mutable_user_define();
  std::string* release_user_define();
  void set_allocated_user_define(std::string* user_define);

  // .sim_msg.OnOff emergency_brake = 2;
  private:
  bool has_emergency_brake() const;
  public:
  void clear_emergency_brake();
  ::sim_msg::OnOff emergency_brake() const;
  void set_emergency_brake(::sim_msg::OnOff value);

  // .sim_msg.OnOff vehicle_lost_control = 3;
  private:
  bool has_vehicle_lost_control() const;
  public:
  void clear_vehicle_lost_control();
  ::sim_msg::OnOff vehicle_lost_control() const;
  void set_vehicle_lost_control(::sim_msg::OnOff value);

  // .sim_msg.OnOff hands_on_steeringwheel = 4;
  private:
  bool has_hands_on_steeringwheel() const;
  public:
  void clear_hands_on_steeringwheel();
  ::sim_msg::OnOff hands_on_steeringwheel() const;
  void set_hands_on_steeringwheel(::sim_msg::OnOff value);

  // .sim_msg.OnOff eyes_on_road = 5;
  private:
  bool has_eyes_on_road() const;
  public:
  void clear_eyes_on_road();
  ::sim_msg::OnOff eyes_on_road() const;
  void set_eyes_on_road(::sim_msg::OnOff value);

  // .sim_msg.OnOff lidar = 6;
  private:
  bool has_lidar() const;
  public:
  void clear_lidar();
  ::sim_msg::OnOff lidar() const;
  void set_lidar(::sim_msg::OnOff value);

  // .sim_msg.OnOff radar = 7;
  private:
  bool has_radar() const;
  public:
  void clear_radar();
  ::sim_msg::OnOff radar() const;
  void set_radar(::sim_msg::OnOff value);

  // .sim_msg.OnOff ultrasonic = 8;
  private:
  bool has_ultrasonic() const;
  public:
  void clear_ultrasonic();
  ::sim_msg::OnOff ultrasonic() const;
  void set_ultrasonic(::sim_msg::OnOff value);

  // .sim_msg.OnOff camera = 9;
  private:
  bool has_camera() const;
  public:
  void clear_camera();
  ::sim_msg::OnOff camera() const;
  void set_camera(::sim_msg::OnOff value);

  // .sim_msg.OnOff gnss = 10;
  private:
  bool has_gnss() const;
  public:
  void clear_gnss();
  ::sim_msg::OnOff gnss() const;
  void set_gnss(::sim_msg::OnOff value);

  // .sim_msg.OnOff imu = 11;
  private:
  bool has_imu() const;
  public:
  void clear_imu();
  ::sim_msg::OnOff imu() const;
  void set_imu(::sim_msg::OnOff value);

  // .sim_msg.OnOff localization = 12;
  private:
  bool has_localization() const;
  public:
  void clear_localization();
  ::sim_msg::OnOff localization() const;
  void set_localization(::sim_msg::OnOff value);

  // .sim_msg.BeamSts beam = 13;
  private:
  bool has_beam() const;
  public:
  void clear_beam();
  ::sim_msg::BeamSts beam() const;
  void set_beam(::sim_msg::BeamSts value);

  // .sim_msg.OnOff brake_light = 14;
  private:
  bool has_brake_light() const;
  public:
  void clear_brake_light();
  ::sim_msg::OnOff brake_light() const;
  void set_brake_light(::sim_msg::OnOff value);

  // .sim_msg.OnOff hazard_light = 15;
  private:
  bool has_hazard_light() const;
  public:
  void clear_hazard_light();
  ::sim_msg::OnOff hazard_light() const;
  void set_hazard_light(::sim_msg::OnOff value);

  // .sim_msg.OnOff left_turn_light = 16;
  private:
  bool has_left_turn_light() const;
  public:
  void clear_left_turn_light();
  ::sim_msg::OnOff left_turn_light() const;
  void set_left_turn_light(::sim_msg::OnOff value);

  // .sim_msg.OnOff right_turn_light = 17;
  private:
  bool has_right_turn_light() const;
  public:
  void clear_right_turn_light();
  ::sim_msg::OnOff right_turn_light() const;
  void set_right_turn_light(::sim_msg::OnOff value);

  // .sim_msg.OnOff driver_seatbelt = 18;
  private:
  bool has_driver_seatbelt() const;
  public:
  void clear_driver_seatbelt();
  ::sim_msg::OnOff driver_seatbelt() const;
  void set_driver_seatbelt(::sim_msg::OnOff value);

  // .sim_msg.OnOff passenger_seatbelt = 19;
  private:
  bool has_passenger_seatbelt() const;
  public:
  void clear_passenger_seatbelt();
  ::sim_msg::OnOff passenger_seatbelt() const;
  void set_passenger_seatbelt(::sim_msg::OnOff value);

  // .sim_msg.OnOff driver_door = 20;
  private:
  bool has_driver_door() const;
  public:
  void clear_driver_door();
  ::sim_msg::OnOff driver_door() const;
  void set_driver_door(::sim_msg::OnOff value);

  // .sim_msg.OnOff passenger_door = 21;
  private:
  bool has_passenger_door() const;
  public:
  void clear_passenger_door();
  ::sim_msg::OnOff passenger_door() const;
  void set_passenger_door(::sim_msg::OnOff value);

  // .sim_msg.OnOff hood = 22;
  private:
  bool has_hood() const;
  public:
  void clear_hood();
  ::sim_msg::OnOff hood() const;
  void set_hood(::sim_msg::OnOff value);

  // .sim_msg.OnOff trunk = 23;
  private:
  bool has_trunk() const;
  public:
  void clear_trunk();
  ::sim_msg::OnOff trunk() const;
  void set_trunk(::sim_msg::OnOff value);

  // .sim_msg.ParkingBrakeSts parkingbrake = 24;
  private:
  bool has_parkingbrake() const;
  public:
  void clear_parkingbrake();
  ::sim_msg::ParkingBrakeSts parkingbrake() const;
  void set_parkingbrake(::sim_msg::ParkingBrakeSts value);

  // .sim_msg.WiperSts wiper = 25;
  private:
  bool has_wiper() const;
  public:
  void clear_wiper();
  ::sim_msg::WiperSts wiper() const;
  void set_wiper(::sim_msg::WiperSts value);

  // .sim_msg.GearSts gear = 26;
  private:
  bool has_gear() const;
  public:
  void clear_gear();
  ::sim_msg::GearSts gear() const;
  void set_gear(::sim_msg::GearSts value);

  // .sim_msg.KeySts key = 27;
  private:
  bool has_key() const;
  public:
  void clear_key();
  ::sim_msg::KeySts key() const;
  void set_key(::sim_msg::KeySts value);

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:sim_msg.Status)
 private:
  class _Internal;
  void set_has_user_define();
  void set_has_emergency_brake();
  void set_has_vehicle_lost_control();
  void set_has_hands_on_steeringwheel();
  void set_has_eyes_on_road();
  void set_has_lidar();
  void set_has_radar();
  void set_has_ultrasonic();
  void set_has_camera();
  void set_has_gnss();
  void set_has_imu();
  void set_has_localization();
  void set_has_beam();
  void set_has_brake_light();
  void set_has_hazard_light();
  void set_has_left_turn_light();
  void set_has_right_turn_light();
  void set_has_driver_seatbelt();
  void set_has_passenger_seatbelt();
  void set_has_driver_door();
  void set_has_passenger_door();
  void set_has_hood();
  void set_has_trunk();
  void set_has_parkingbrake();
  void set_has_wiper();
  void set_has_gear();
  void set_has_key();

  inline bool has_type() const;
  inline void clear_has_type();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union TypeUnion {
    TypeUnion() {}
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_define_;
    int emergency_brake_;
    int vehicle_lost_control_;
    int hands_on_steeringwheel_;
    int eyes_on_road_;
    int lidar_;
    int radar_;
    int ultrasonic_;
    int camera_;
    int gnss_;
    int imu_;
    int localization_;
    int beam_;
    int brake_light_;
    int hazard_light_;
    int left_turn_light_;
    int right_turn_light_;
    int driver_seatbelt_;
    int passenger_seatbelt_;
    int driver_door_;
    int passenger_door_;
    int hood_;
    int trunk_;
    int parkingbrake_;
    int wiper_;
    int gear_;
    int key_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_vehicle_5finteraction_2eproto;
};
// -------------------------------------------------------------------

class VehicleInteraction :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.VehicleInteraction) */ {
 public:
  VehicleInteraction();
  virtual ~VehicleInteraction();

  VehicleInteraction(const VehicleInteraction& from);
  VehicleInteraction(VehicleInteraction&& from) noexcept
    : VehicleInteraction() {
    *this = ::std::move(from);
  }

  inline VehicleInteraction& operator=(const VehicleInteraction& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleInteraction& operator=(VehicleInteraction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VehicleInteraction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleInteraction* internal_default_instance() {
    return reinterpret_cast<const VehicleInteraction*>(
               &_VehicleInteraction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(VehicleInteraction& a, VehicleInteraction& b) {
    a.Swap(&b);
  }
  inline void Swap(VehicleInteraction* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VehicleInteraction* New() const final {
    return CreateMaybeMessage<VehicleInteraction>(nullptr);
  }

  VehicleInteraction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VehicleInteraction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VehicleInteraction& from);
  void MergeFrom(const VehicleInteraction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleInteraction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.VehicleInteraction";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_vehicle_5finteraction_2eproto);
    return ::descriptor_table_vehicle_5finteraction_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActivateFieldNumber = 1,
    kAssignFieldNumber = 2,
    kOverrideFieldNumber = 3,
    kCommandFieldNumber = 4,
    kStatusFieldNumber = 5,
  };
  // .sim_msg.Activate activate = 1;
  bool has_activate() const;
  void clear_activate();
  const ::sim_msg::Activate& activate() const;
  ::sim_msg::Activate* release_activate();
  ::sim_msg::Activate* mutable_activate();
  void set_allocated_activate(::sim_msg::Activate* activate);

  // .sim_msg.Assign assign = 2;
  bool has_assign() const;
  void clear_assign();
  const ::sim_msg::Assign& assign() const;
  ::sim_msg::Assign* release_assign();
  ::sim_msg::Assign* mutable_assign();
  void set_allocated_assign(::sim_msg::Assign* assign);

  // .sim_msg.Override override = 3;
  bool has_override() const;
  void clear_override();
  const ::sim_msg::Override& override() const;
  ::sim_msg::Override* release_override();
  ::sim_msg::Override* mutable_override();
  void set_allocated_override(::sim_msg::Override* override);

  // .sim_msg.Command command = 4;
  bool has_command() const;
  void clear_command();
  const ::sim_msg::Command& command() const;
  ::sim_msg::Command* release_command();
  ::sim_msg::Command* mutable_command();
  void set_allocated_command(::sim_msg::Command* command);

  // .sim_msg.Status status = 5;
  bool has_status() const;
  void clear_status();
  const ::sim_msg::Status& status() const;
  ::sim_msg::Status* release_status();
  ::sim_msg::Status* mutable_status();
  void set_allocated_status(::sim_msg::Status* status);

  // @@protoc_insertion_point(class_scope:sim_msg.VehicleInteraction)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::sim_msg::Activate* activate_;
  ::sim_msg::Assign* assign_;
  ::sim_msg::Override* override_;
  ::sim_msg::Command* command_;
  ::sim_msg::Status* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vehicle_5finteraction_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Activate

// .sim_msg.Activate.Automode automode = 1;
inline void Activate::clear_automode() {
  automode_ = 0;
}
inline ::sim_msg::Activate_Automode Activate::automode() const {
  // @@protoc_insertion_point(field_get:sim_msg.Activate.automode)
  return static_cast< ::sim_msg::Activate_Automode >(automode_);
}
inline void Activate::set_automode(::sim_msg::Activate_Automode value) {
  
  automode_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Activate.automode)
}

// -------------------------------------------------------------------

// Assign_Cruise

// .sim_msg.OnOff resume_sw = 1;
inline void Assign_Cruise::clear_resume_sw() {
  resume_sw_ = 0;
}
inline ::sim_msg::OnOff Assign_Cruise::resume_sw() const {
  // @@protoc_insertion_point(field_get:sim_msg.Assign.Cruise.resume_sw)
  return static_cast< ::sim_msg::OnOff >(resume_sw_);
}
inline void Assign_Cruise::set_resume_sw(::sim_msg::OnOff value) {
  
  resume_sw_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Assign.Cruise.resume_sw)
}

// .sim_msg.OnOff cancel_sw = 2;
inline void Assign_Cruise::clear_cancel_sw() {
  cancel_sw_ = 0;
}
inline ::sim_msg::OnOff Assign_Cruise::cancel_sw() const {
  // @@protoc_insertion_point(field_get:sim_msg.Assign.Cruise.cancel_sw)
  return static_cast< ::sim_msg::OnOff >(cancel_sw_);
}
inline void Assign_Cruise::set_cancel_sw(::sim_msg::OnOff value) {
  
  cancel_sw_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Assign.Cruise.cancel_sw)
}

// .sim_msg.OnOff speed_inc_sw = 3;
inline void Assign_Cruise::clear_speed_inc_sw() {
  speed_inc_sw_ = 0;
}
inline ::sim_msg::OnOff Assign_Cruise::speed_inc_sw() const {
  // @@protoc_insertion_point(field_get:sim_msg.Assign.Cruise.speed_inc_sw)
  return static_cast< ::sim_msg::OnOff >(speed_inc_sw_);
}
inline void Assign_Cruise::set_speed_inc_sw(::sim_msg::OnOff value) {
  
  speed_inc_sw_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Assign.Cruise.speed_inc_sw)
}

// .sim_msg.OnOff speed_dec_sw = 4;
inline void Assign_Cruise::clear_speed_dec_sw() {
  speed_dec_sw_ = 0;
}
inline ::sim_msg::OnOff Assign_Cruise::speed_dec_sw() const {
  // @@protoc_insertion_point(field_get:sim_msg.Assign.Cruise.speed_dec_sw)
  return static_cast< ::sim_msg::OnOff >(speed_dec_sw_);
}
inline void Assign_Cruise::set_speed_dec_sw(::sim_msg::OnOff value) {
  
  speed_dec_sw_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Assign.Cruise.speed_dec_sw)
}

// double set_timegap = 5;
inline void Assign_Cruise::clear_set_timegap() {
  set_timegap_ = 0;
}
inline double Assign_Cruise::set_timegap() const {
  // @@protoc_insertion_point(field_get:sim_msg.Assign.Cruise.set_timegap)
  return set_timegap_;
}
inline void Assign_Cruise::set_set_timegap(double value) {
  
  set_timegap_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Assign.Cruise.set_timegap)
}

// double set_speed = 6;
inline void Assign_Cruise::clear_set_speed() {
  set_speed_ = 0;
}
inline double Assign_Cruise::set_speed() const {
  // @@protoc_insertion_point(field_get:sim_msg.Assign.Cruise.set_speed)
  return set_speed_;
}
inline void Assign_Cruise::set_set_speed(double value) {
  
  set_speed_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Assign.Cruise.set_speed)
}

// -------------------------------------------------------------------

// Assign

// string controller_name = 1;
inline void Assign::clear_controller_name() {
  controller_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Assign::controller_name() const {
  // @@protoc_insertion_point(field_get:sim_msg.Assign.controller_name)
  return controller_name_.GetNoArena();
}
inline void Assign::set_controller_name(const std::string& value) {
  
  controller_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.Assign.controller_name)
}
inline void Assign::set_controller_name(std::string&& value) {
  
  controller_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.Assign.controller_name)
}
inline void Assign::set_controller_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  controller_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.Assign.controller_name)
}
inline void Assign::set_controller_name(const char* value, size_t size) {
  
  controller_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.Assign.controller_name)
}
inline std::string* Assign::mutable_controller_name() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.Assign.controller_name)
  return controller_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Assign::release_controller_name() {
  // @@protoc_insertion_point(field_release:sim_msg.Assign.controller_name)
  
  return controller_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Assign::set_allocated_controller_name(std::string* controller_name) {
  if (controller_name != nullptr) {
    
  } else {
    
  }
  controller_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), controller_name);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Assign.controller_name)
}

// string none = 2;
inline bool Assign::has_none() const {
  return properties_case() == kNone;
}
inline void Assign::set_has_none() {
  _oneof_case_[0] = kNone;
}
inline void Assign::clear_none() {
  if (has_none()) {
    properties_.none_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_properties();
  }
}
inline const std::string& Assign::none() const {
  // @@protoc_insertion_point(field_get:sim_msg.Assign.none)
  if (has_none()) {
    return properties_.none_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Assign::set_none(const std::string& value) {
  // @@protoc_insertion_point(field_set:sim_msg.Assign.none)
  if (!has_none()) {
    clear_properties();
    set_has_none();
    properties_.none_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  properties_.none_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.Assign.none)
}
inline void Assign::set_none(std::string&& value) {
  // @@protoc_insertion_point(field_set:sim_msg.Assign.none)
  if (!has_none()) {
    clear_properties();
    set_has_none();
    properties_.none_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  properties_.none_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.Assign.none)
}
inline void Assign::set_none(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_none()) {
    clear_properties();
    set_has_none();
    properties_.none_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  properties_.none_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.Assign.none)
}
inline void Assign::set_none(const char* value, size_t size) {
  if (!has_none()) {
    clear_properties();
    set_has_none();
    properties_.none_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  properties_.none_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.Assign.none)
}
inline std::string* Assign::mutable_none() {
  if (!has_none()) {
    clear_properties();
    set_has_none();
    properties_.none_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Assign.none)
  return properties_.none_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Assign::release_none() {
  // @@protoc_insertion_point(field_release:sim_msg.Assign.none)
  if (has_none()) {
    clear_has_properties();
    return properties_.none_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void Assign::set_allocated_none(std::string* none) {
  if (has_properties()) {
    clear_properties();
  }
  if (none != nullptr) {
    set_has_none();
    properties_.none_.UnsafeSetDefault(none);
  }
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Assign.none)
}

// .sim_msg.Assign.Cruise cruise = 3;
inline bool Assign::has_cruise() const {
  return properties_case() == kCruise;
}
inline void Assign::set_has_cruise() {
  _oneof_case_[0] = kCruise;
}
inline void Assign::clear_cruise() {
  if (has_cruise()) {
    delete properties_.cruise_;
    clear_has_properties();
  }
}
inline ::sim_msg::Assign_Cruise* Assign::release_cruise() {
  // @@protoc_insertion_point(field_release:sim_msg.Assign.cruise)
  if (has_cruise()) {
    clear_has_properties();
      ::sim_msg::Assign_Cruise* temp = properties_.cruise_;
    properties_.cruise_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sim_msg::Assign_Cruise& Assign::cruise() const {
  // @@protoc_insertion_point(field_get:sim_msg.Assign.cruise)
  return has_cruise()
      ? *properties_.cruise_
      : *reinterpret_cast< ::sim_msg::Assign_Cruise*>(&::sim_msg::_Assign_Cruise_default_instance_);
}
inline ::sim_msg::Assign_Cruise* Assign::mutable_cruise() {
  if (!has_cruise()) {
    clear_properties();
    set_has_cruise();
    properties_.cruise_ = CreateMaybeMessage< ::sim_msg::Assign_Cruise >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Assign.cruise)
  return properties_.cruise_;
}

inline bool Assign::has_properties() const {
  return properties_case() != PROPERTIES_NOT_SET;
}
inline void Assign::clear_has_properties() {
  _oneof_case_[0] = PROPERTIES_NOT_SET;
}
inline Assign::PropertiesCase Assign::properties_case() const {
  return Assign::PropertiesCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Override_Throttle

// .sim_msg.OnOff action = 1;
inline void Override_Throttle::clear_action() {
  action_ = 0;
}
inline ::sim_msg::OnOff Override_Throttle::action() const {
  // @@protoc_insertion_point(field_get:sim_msg.Override.Throttle.action)
  return static_cast< ::sim_msg::OnOff >(action_);
}
inline void Override_Throttle::set_action(::sim_msg::OnOff value) {
  
  action_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Override.Throttle.action)
}

// double value = 2;
inline void Override_Throttle::clear_value() {
  value_ = 0;
}
inline double Override_Throttle::value() const {
  // @@protoc_insertion_point(field_get:sim_msg.Override.Throttle.value)
  return value_;
}
inline void Override_Throttle::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Override.Throttle.value)
}

// -------------------------------------------------------------------

// Override_Brake

// .sim_msg.OnOff action = 1;
inline void Override_Brake::clear_action() {
  action_ = 0;
}
inline ::sim_msg::OnOff Override_Brake::action() const {
  // @@protoc_insertion_point(field_get:sim_msg.Override.Brake.action)
  return static_cast< ::sim_msg::OnOff >(action_);
}
inline void Override_Brake::set_action(::sim_msg::OnOff value) {
  
  action_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Override.Brake.action)
}

// double value = 2;
inline void Override_Brake::clear_value() {
  value_ = 0;
}
inline double Override_Brake::value() const {
  // @@protoc_insertion_point(field_get:sim_msg.Override.Brake.value)
  return value_;
}
inline void Override_Brake::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Override.Brake.value)
}

// -------------------------------------------------------------------

// Override_SteeringWheel

// .sim_msg.OnOff action = 1;
inline void Override_SteeringWheel::clear_action() {
  action_ = 0;
}
inline ::sim_msg::OnOff Override_SteeringWheel::action() const {
  // @@protoc_insertion_point(field_get:sim_msg.Override.SteeringWheel.action)
  return static_cast< ::sim_msg::OnOff >(action_);
}
inline void Override_SteeringWheel::set_action(::sim_msg::OnOff value) {
  
  action_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Override.SteeringWheel.action)
}

// double value = 2;
inline void Override_SteeringWheel::clear_value() {
  value_ = 0;
}
inline double Override_SteeringWheel::value() const {
  // @@protoc_insertion_point(field_get:sim_msg.Override.SteeringWheel.value)
  return value_;
}
inline void Override_SteeringWheel::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Override.SteeringWheel.value)
}

// -------------------------------------------------------------------

// Override_ParkingBrake

// .sim_msg.OnOff action = 1;
inline void Override_ParkingBrake::clear_action() {
  action_ = 0;
}
inline ::sim_msg::OnOff Override_ParkingBrake::action() const {
  // @@protoc_insertion_point(field_get:sim_msg.Override.ParkingBrake.action)
  return static_cast< ::sim_msg::OnOff >(action_);
}
inline void Override_ParkingBrake::set_action(::sim_msg::OnOff value) {
  
  action_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Override.ParkingBrake.action)
}

// .sim_msg.ParkingBrakeSts value = 2;
inline void Override_ParkingBrake::clear_value() {
  value_ = 0;
}
inline ::sim_msg::ParkingBrakeSts Override_ParkingBrake::value() const {
  // @@protoc_insertion_point(field_get:sim_msg.Override.ParkingBrake.value)
  return static_cast< ::sim_msg::ParkingBrakeSts >(value_);
}
inline void Override_ParkingBrake::set_value(::sim_msg::ParkingBrakeSts value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Override.ParkingBrake.value)
}

// -------------------------------------------------------------------

// Override_Clutch

// .sim_msg.OnOff action = 1;
inline void Override_Clutch::clear_action() {
  action_ = 0;
}
inline ::sim_msg::OnOff Override_Clutch::action() const {
  // @@protoc_insertion_point(field_get:sim_msg.Override.Clutch.action)
  return static_cast< ::sim_msg::OnOff >(action_);
}
inline void Override_Clutch::set_action(::sim_msg::OnOff value) {
  
  action_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Override.Clutch.action)
}

// double value = 2;
inline void Override_Clutch::clear_value() {
  value_ = 0;
}
inline double Override_Clutch::value() const {
  // @@protoc_insertion_point(field_get:sim_msg.Override.Clutch.value)
  return value_;
}
inline void Override_Clutch::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Override.Clutch.value)
}

// -------------------------------------------------------------------

// Override_Gear

// .sim_msg.OnOff action = 1;
inline void Override_Gear::clear_action() {
  action_ = 0;
}
inline ::sim_msg::OnOff Override_Gear::action() const {
  // @@protoc_insertion_point(field_get:sim_msg.Override.Gear.action)
  return static_cast< ::sim_msg::OnOff >(action_);
}
inline void Override_Gear::set_action(::sim_msg::OnOff value) {
  
  action_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Override.Gear.action)
}

// .sim_msg.GearSts value = 2;
inline void Override_Gear::clear_value() {
  value_ = 0;
}
inline ::sim_msg::GearSts Override_Gear::value() const {
  // @@protoc_insertion_point(field_get:sim_msg.Override.Gear.value)
  return static_cast< ::sim_msg::GearSts >(value_);
}
inline void Override_Gear::set_value(::sim_msg::GearSts value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Override.Gear.value)
}

// -------------------------------------------------------------------

// Override

// .sim_msg.Override.Throttle throttle = 1;
inline bool Override::has_throttle() const {
  return this != internal_default_instance() && throttle_ != nullptr;
}
inline void Override::clear_throttle() {
  if (GetArenaNoVirtual() == nullptr && throttle_ != nullptr) {
    delete throttle_;
  }
  throttle_ = nullptr;
}
inline const ::sim_msg::Override_Throttle& Override::throttle() const {
  const ::sim_msg::Override_Throttle* p = throttle_;
  // @@protoc_insertion_point(field_get:sim_msg.Override.throttle)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Override_Throttle*>(
      &::sim_msg::_Override_Throttle_default_instance_);
}
inline ::sim_msg::Override_Throttle* Override::release_throttle() {
  // @@protoc_insertion_point(field_release:sim_msg.Override.throttle)
  
  ::sim_msg::Override_Throttle* temp = throttle_;
  throttle_ = nullptr;
  return temp;
}
inline ::sim_msg::Override_Throttle* Override::mutable_throttle() {
  
  if (throttle_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Override_Throttle>(GetArenaNoVirtual());
    throttle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Override.throttle)
  return throttle_;
}
inline void Override::set_allocated_throttle(::sim_msg::Override_Throttle* throttle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete throttle_;
  }
  if (throttle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      throttle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, throttle, submessage_arena);
    }
    
  } else {
    
  }
  throttle_ = throttle;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Override.throttle)
}

// .sim_msg.Override.Brake brake = 2;
inline bool Override::has_brake() const {
  return this != internal_default_instance() && brake_ != nullptr;
}
inline void Override::clear_brake() {
  if (GetArenaNoVirtual() == nullptr && brake_ != nullptr) {
    delete brake_;
  }
  brake_ = nullptr;
}
inline const ::sim_msg::Override_Brake& Override::brake() const {
  const ::sim_msg::Override_Brake* p = brake_;
  // @@protoc_insertion_point(field_get:sim_msg.Override.brake)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Override_Brake*>(
      &::sim_msg::_Override_Brake_default_instance_);
}
inline ::sim_msg::Override_Brake* Override::release_brake() {
  // @@protoc_insertion_point(field_release:sim_msg.Override.brake)
  
  ::sim_msg::Override_Brake* temp = brake_;
  brake_ = nullptr;
  return temp;
}
inline ::sim_msg::Override_Brake* Override::mutable_brake() {
  
  if (brake_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Override_Brake>(GetArenaNoVirtual());
    brake_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Override.brake)
  return brake_;
}
inline void Override::set_allocated_brake(::sim_msg::Override_Brake* brake) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete brake_;
  }
  if (brake) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      brake = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, brake, submessage_arena);
    }
    
  } else {
    
  }
  brake_ = brake;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Override.brake)
}

// .sim_msg.Override.SteeringWheel steering_wheel = 3;
inline bool Override::has_steering_wheel() const {
  return this != internal_default_instance() && steering_wheel_ != nullptr;
}
inline void Override::clear_steering_wheel() {
  if (GetArenaNoVirtual() == nullptr && steering_wheel_ != nullptr) {
    delete steering_wheel_;
  }
  steering_wheel_ = nullptr;
}
inline const ::sim_msg::Override_SteeringWheel& Override::steering_wheel() const {
  const ::sim_msg::Override_SteeringWheel* p = steering_wheel_;
  // @@protoc_insertion_point(field_get:sim_msg.Override.steering_wheel)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Override_SteeringWheel*>(
      &::sim_msg::_Override_SteeringWheel_default_instance_);
}
inline ::sim_msg::Override_SteeringWheel* Override::release_steering_wheel() {
  // @@protoc_insertion_point(field_release:sim_msg.Override.steering_wheel)
  
  ::sim_msg::Override_SteeringWheel* temp = steering_wheel_;
  steering_wheel_ = nullptr;
  return temp;
}
inline ::sim_msg::Override_SteeringWheel* Override::mutable_steering_wheel() {
  
  if (steering_wheel_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Override_SteeringWheel>(GetArenaNoVirtual());
    steering_wheel_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Override.steering_wheel)
  return steering_wheel_;
}
inline void Override::set_allocated_steering_wheel(::sim_msg::Override_SteeringWheel* steering_wheel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete steering_wheel_;
  }
  if (steering_wheel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      steering_wheel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, steering_wheel, submessage_arena);
    }
    
  } else {
    
  }
  steering_wheel_ = steering_wheel;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Override.steering_wheel)
}

// .sim_msg.Override.ParkingBrake parking_brake = 4;
inline bool Override::has_parking_brake() const {
  return this != internal_default_instance() && parking_brake_ != nullptr;
}
inline void Override::clear_parking_brake() {
  if (GetArenaNoVirtual() == nullptr && parking_brake_ != nullptr) {
    delete parking_brake_;
  }
  parking_brake_ = nullptr;
}
inline const ::sim_msg::Override_ParkingBrake& Override::parking_brake() const {
  const ::sim_msg::Override_ParkingBrake* p = parking_brake_;
  // @@protoc_insertion_point(field_get:sim_msg.Override.parking_brake)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Override_ParkingBrake*>(
      &::sim_msg::_Override_ParkingBrake_default_instance_);
}
inline ::sim_msg::Override_ParkingBrake* Override::release_parking_brake() {
  // @@protoc_insertion_point(field_release:sim_msg.Override.parking_brake)
  
  ::sim_msg::Override_ParkingBrake* temp = parking_brake_;
  parking_brake_ = nullptr;
  return temp;
}
inline ::sim_msg::Override_ParkingBrake* Override::mutable_parking_brake() {
  
  if (parking_brake_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Override_ParkingBrake>(GetArenaNoVirtual());
    parking_brake_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Override.parking_brake)
  return parking_brake_;
}
inline void Override::set_allocated_parking_brake(::sim_msg::Override_ParkingBrake* parking_brake) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete parking_brake_;
  }
  if (parking_brake) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      parking_brake = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parking_brake, submessage_arena);
    }
    
  } else {
    
  }
  parking_brake_ = parking_brake;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Override.parking_brake)
}

// .sim_msg.Override.Clutch clutch = 5;
inline bool Override::has_clutch() const {
  return this != internal_default_instance() && clutch_ != nullptr;
}
inline void Override::clear_clutch() {
  if (GetArenaNoVirtual() == nullptr && clutch_ != nullptr) {
    delete clutch_;
  }
  clutch_ = nullptr;
}
inline const ::sim_msg::Override_Clutch& Override::clutch() const {
  const ::sim_msg::Override_Clutch* p = clutch_;
  // @@protoc_insertion_point(field_get:sim_msg.Override.clutch)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Override_Clutch*>(
      &::sim_msg::_Override_Clutch_default_instance_);
}
inline ::sim_msg::Override_Clutch* Override::release_clutch() {
  // @@protoc_insertion_point(field_release:sim_msg.Override.clutch)
  
  ::sim_msg::Override_Clutch* temp = clutch_;
  clutch_ = nullptr;
  return temp;
}
inline ::sim_msg::Override_Clutch* Override::mutable_clutch() {
  
  if (clutch_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Override_Clutch>(GetArenaNoVirtual());
    clutch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Override.clutch)
  return clutch_;
}
inline void Override::set_allocated_clutch(::sim_msg::Override_Clutch* clutch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete clutch_;
  }
  if (clutch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      clutch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clutch, submessage_arena);
    }
    
  } else {
    
  }
  clutch_ = clutch;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Override.clutch)
}

// .sim_msg.Override.Gear gear = 6;
inline bool Override::has_gear() const {
  return this != internal_default_instance() && gear_ != nullptr;
}
inline void Override::clear_gear() {
  if (GetArenaNoVirtual() == nullptr && gear_ != nullptr) {
    delete gear_;
  }
  gear_ = nullptr;
}
inline const ::sim_msg::Override_Gear& Override::gear() const {
  const ::sim_msg::Override_Gear* p = gear_;
  // @@protoc_insertion_point(field_get:sim_msg.Override.gear)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Override_Gear*>(
      &::sim_msg::_Override_Gear_default_instance_);
}
inline ::sim_msg::Override_Gear* Override::release_gear() {
  // @@protoc_insertion_point(field_release:sim_msg.Override.gear)
  
  ::sim_msg::Override_Gear* temp = gear_;
  gear_ = nullptr;
  return temp;
}
inline ::sim_msg::Override_Gear* Override::mutable_gear() {
  
  if (gear_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Override_Gear>(GetArenaNoVirtual());
    gear_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Override.gear)
  return gear_;
}
inline void Override::set_allocated_gear(::sim_msg::Override_Gear* gear) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gear_;
  }
  if (gear) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gear = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gear, submessage_arena);
    }
    
  } else {
    
  }
  gear_ = gear;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Override.gear)
}

// -------------------------------------------------------------------

// Command_LaneChange

// .sim_msg.OnOff action = 1;
inline void Command_LaneChange::clear_action() {
  action_ = 0;
}
inline ::sim_msg::OnOff Command_LaneChange::action() const {
  // @@protoc_insertion_point(field_get:sim_msg.Command.LaneChange.action)
  return static_cast< ::sim_msg::OnOff >(action_);
}
inline void Command_LaneChange::set_action(::sim_msg::OnOff value) {
  
  action_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Command.LaneChange.action)
}

// .sim_msg.Dir value = 2;
inline void Command_LaneChange::clear_value() {
  value_ = 0;
}
inline ::sim_msg::Dir Command_LaneChange::value() const {
  // @@protoc_insertion_point(field_get:sim_msg.Command.LaneChange.value)
  return static_cast< ::sim_msg::Dir >(value_);
}
inline void Command_LaneChange::set_value(::sim_msg::Dir value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Command.LaneChange.value)
}

// -------------------------------------------------------------------

// Command_Overtaking

// .sim_msg.OnOff action = 1;
inline void Command_Overtaking::clear_action() {
  action_ = 0;
}
inline ::sim_msg::OnOff Command_Overtaking::action() const {
  // @@protoc_insertion_point(field_get:sim_msg.Command.Overtaking.action)
  return static_cast< ::sim_msg::OnOff >(action_);
}
inline void Command_Overtaking::set_action(::sim_msg::OnOff value) {
  
  action_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Command.Overtaking.action)
}

// .sim_msg.Dir value = 2;
inline void Command_Overtaking::clear_value() {
  value_ = 0;
}
inline ::sim_msg::Dir Command_Overtaking::value() const {
  // @@protoc_insertion_point(field_get:sim_msg.Command.Overtaking.value)
  return static_cast< ::sim_msg::Dir >(value_);
}
inline void Command_Overtaking::set_value(::sim_msg::Dir value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Command.Overtaking.value)
}

// -------------------------------------------------------------------

// Command

// bytes user_define = 1;
inline bool Command::has_user_define() const {
  return type_case() == kUserDefine;
}
inline void Command::set_has_user_define() {
  _oneof_case_[0] = kUserDefine;
}
inline void Command::clear_user_define() {
  if (has_user_define()) {
    type_.user_define_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_type();
  }
}
inline const std::string& Command::user_define() const {
  // @@protoc_insertion_point(field_get:sim_msg.Command.user_define)
  if (has_user_define()) {
    return type_.user_define_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Command::set_user_define(const std::string& value) {
  // @@protoc_insertion_point(field_set:sim_msg.Command.user_define)
  if (!has_user_define()) {
    clear_type();
    set_has_user_define();
    type_.user_define_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  type_.user_define_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.Command.user_define)
}
inline void Command::set_user_define(std::string&& value) {
  // @@protoc_insertion_point(field_set:sim_msg.Command.user_define)
  if (!has_user_define()) {
    clear_type();
    set_has_user_define();
    type_.user_define_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  type_.user_define_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.Command.user_define)
}
inline void Command::set_user_define(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_user_define()) {
    clear_type();
    set_has_user_define();
    type_.user_define_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  type_.user_define_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.Command.user_define)
}
inline void Command::set_user_define(const void* value, size_t size) {
  if (!has_user_define()) {
    clear_type();
    set_has_user_define();
    type_.user_define_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  type_.user_define_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.Command.user_define)
}
inline std::string* Command::mutable_user_define() {
  if (!has_user_define()) {
    clear_type();
    set_has_user_define();
    type_.user_define_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Command.user_define)
  return type_.user_define_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Command::release_user_define() {
  // @@protoc_insertion_point(field_release:sim_msg.Command.user_define)
  if (has_user_define()) {
    clear_has_type();
    return type_.user_define_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void Command::set_allocated_user_define(std::string* user_define) {
  if (has_type()) {
    clear_type();
  }
  if (user_define != nullptr) {
    set_has_user_define();
    type_.user_define_.UnsafeSetDefault(user_define);
  }
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Command.user_define)
}

// .sim_msg.Command.LaneChange lane_change = 2;
inline bool Command::has_lane_change() const {
  return type_case() == kLaneChange;
}
inline void Command::set_has_lane_change() {
  _oneof_case_[0] = kLaneChange;
}
inline void Command::clear_lane_change() {
  if (has_lane_change()) {
    delete type_.lane_change_;
    clear_has_type();
  }
}
inline ::sim_msg::Command_LaneChange* Command::release_lane_change() {
  // @@protoc_insertion_point(field_release:sim_msg.Command.lane_change)
  if (has_lane_change()) {
    clear_has_type();
      ::sim_msg::Command_LaneChange* temp = type_.lane_change_;
    type_.lane_change_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sim_msg::Command_LaneChange& Command::lane_change() const {
  // @@protoc_insertion_point(field_get:sim_msg.Command.lane_change)
  return has_lane_change()
      ? *type_.lane_change_
      : *reinterpret_cast< ::sim_msg::Command_LaneChange*>(&::sim_msg::_Command_LaneChange_default_instance_);
}
inline ::sim_msg::Command_LaneChange* Command::mutable_lane_change() {
  if (!has_lane_change()) {
    clear_type();
    set_has_lane_change();
    type_.lane_change_ = CreateMaybeMessage< ::sim_msg::Command_LaneChange >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Command.lane_change)
  return type_.lane_change_;
}

// .sim_msg.Command.Overtaking overtaking = 3;
inline bool Command::has_overtaking() const {
  return type_case() == kOvertaking;
}
inline void Command::set_has_overtaking() {
  _oneof_case_[0] = kOvertaking;
}
inline void Command::clear_overtaking() {
  if (has_overtaking()) {
    delete type_.overtaking_;
    clear_has_type();
  }
}
inline ::sim_msg::Command_Overtaking* Command::release_overtaking() {
  // @@protoc_insertion_point(field_release:sim_msg.Command.overtaking)
  if (has_overtaking()) {
    clear_has_type();
      ::sim_msg::Command_Overtaking* temp = type_.overtaking_;
    type_.overtaking_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sim_msg::Command_Overtaking& Command::overtaking() const {
  // @@protoc_insertion_point(field_get:sim_msg.Command.overtaking)
  return has_overtaking()
      ? *type_.overtaking_
      : *reinterpret_cast< ::sim_msg::Command_Overtaking*>(&::sim_msg::_Command_Overtaking_default_instance_);
}
inline ::sim_msg::Command_Overtaking* Command::mutable_overtaking() {
  if (!has_overtaking()) {
    clear_type();
    set_has_overtaking();
    type_.overtaking_ = CreateMaybeMessage< ::sim_msg::Command_Overtaking >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Command.overtaking)
  return type_.overtaking_;
}

// .sim_msg.OnOff pull_over = 4;
inline bool Command::has_pull_over() const {
  return type_case() == kPullOver;
}
inline void Command::set_has_pull_over() {
  _oneof_case_[0] = kPullOver;
}
inline void Command::clear_pull_over() {
  if (has_pull_over()) {
    type_.pull_over_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Command::pull_over() const {
  // @@protoc_insertion_point(field_get:sim_msg.Command.pull_over)
  if (has_pull_over()) {
    return static_cast< ::sim_msg::OnOff >(type_.pull_over_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Command::set_pull_over(::sim_msg::OnOff value) {
  if (!has_pull_over()) {
    clear_type();
    set_has_pull_over();
  }
  type_.pull_over_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Command.pull_over)
}

// .sim_msg.OnOff emergency_stop = 5;
inline bool Command::has_emergency_stop() const {
  return type_case() == kEmergencyStop;
}
inline void Command::set_has_emergency_stop() {
  _oneof_case_[0] = kEmergencyStop;
}
inline void Command::clear_emergency_stop() {
  if (has_emergency_stop()) {
    type_.emergency_stop_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Command::emergency_stop() const {
  // @@protoc_insertion_point(field_get:sim_msg.Command.emergency_stop)
  if (has_emergency_stop()) {
    return static_cast< ::sim_msg::OnOff >(type_.emergency_stop_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Command::set_emergency_stop(::sim_msg::OnOff value) {
  if (!has_emergency_stop()) {
    clear_type();
    set_has_emergency_stop();
  }
  type_.emergency_stop_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Command.emergency_stop)
}

// double lateral_speed_to_left = 6;
inline bool Command::has_lateral_speed_to_left() const {
  return type_case() == kLateralSpeedToLeft;
}
inline void Command::set_has_lateral_speed_to_left() {
  _oneof_case_[0] = kLateralSpeedToLeft;
}
inline void Command::clear_lateral_speed_to_left() {
  if (has_lateral_speed_to_left()) {
    type_.lateral_speed_to_left_ = 0;
    clear_has_type();
  }
}
inline double Command::lateral_speed_to_left() const {
  // @@protoc_insertion_point(field_get:sim_msg.Command.lateral_speed_to_left)
  if (has_lateral_speed_to_left()) {
    return type_.lateral_speed_to_left_;
  }
  return 0;
}
inline void Command::set_lateral_speed_to_left(double value) {
  if (!has_lateral_speed_to_left()) {
    clear_type();
    set_has_lateral_speed_to_left();
  }
  type_.lateral_speed_to_left_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Command.lateral_speed_to_left)
}

// double lateral_speed_to_right = 7;
inline bool Command::has_lateral_speed_to_right() const {
  return type_case() == kLateralSpeedToRight;
}
inline void Command::set_has_lateral_speed_to_right() {
  _oneof_case_[0] = kLateralSpeedToRight;
}
inline void Command::clear_lateral_speed_to_right() {
  if (has_lateral_speed_to_right()) {
    type_.lateral_speed_to_right_ = 0;
    clear_has_type();
  }
}
inline double Command::lateral_speed_to_right() const {
  // @@protoc_insertion_point(field_get:sim_msg.Command.lateral_speed_to_right)
  if (has_lateral_speed_to_right()) {
    return type_.lateral_speed_to_right_;
  }
  return 0;
}
inline void Command::set_lateral_speed_to_right(double value) {
  if (!has_lateral_speed_to_right()) {
    clear_type();
    set_has_lateral_speed_to_right();
  }
  type_.lateral_speed_to_right_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Command.lateral_speed_to_right)
}

// double lateral_accel_to_left = 8;
inline bool Command::has_lateral_accel_to_left() const {
  return type_case() == kLateralAccelToLeft;
}
inline void Command::set_has_lateral_accel_to_left() {
  _oneof_case_[0] = kLateralAccelToLeft;
}
inline void Command::clear_lateral_accel_to_left() {
  if (has_lateral_accel_to_left()) {
    type_.lateral_accel_to_left_ = 0;
    clear_has_type();
  }
}
inline double Command::lateral_accel_to_left() const {
  // @@protoc_insertion_point(field_get:sim_msg.Command.lateral_accel_to_left)
  if (has_lateral_accel_to_left()) {
    return type_.lateral_accel_to_left_;
  }
  return 0;
}
inline void Command::set_lateral_accel_to_left(double value) {
  if (!has_lateral_accel_to_left()) {
    clear_type();
    set_has_lateral_accel_to_left();
  }
  type_.lateral_accel_to_left_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Command.lateral_accel_to_left)
}

// double lateral_accel_to_right = 9;
inline bool Command::has_lateral_accel_to_right() const {
  return type_case() == kLateralAccelToRight;
}
inline void Command::set_has_lateral_accel_to_right() {
  _oneof_case_[0] = kLateralAccelToRight;
}
inline void Command::clear_lateral_accel_to_right() {
  if (has_lateral_accel_to_right()) {
    type_.lateral_accel_to_right_ = 0;
    clear_has_type();
  }
}
inline double Command::lateral_accel_to_right() const {
  // @@protoc_insertion_point(field_get:sim_msg.Command.lateral_accel_to_right)
  if (has_lateral_accel_to_right()) {
    return type_.lateral_accel_to_right_;
  }
  return 0;
}
inline void Command::set_lateral_accel_to_right(double value) {
  if (!has_lateral_accel_to_right()) {
    clear_type();
    set_has_lateral_accel_to_right();
  }
  type_.lateral_accel_to_right_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Command.lateral_accel_to_right)
}

inline bool Command::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Command::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Command::TypeCase Command::type_case() const {
  return Command::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Status

// bytes user_define = 1;
inline bool Status::has_user_define() const {
  return type_case() == kUserDefine;
}
inline void Status::set_has_user_define() {
  _oneof_case_[0] = kUserDefine;
}
inline void Status::clear_user_define() {
  if (has_user_define()) {
    type_.user_define_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_type();
  }
}
inline const std::string& Status::user_define() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.user_define)
  if (has_user_define()) {
    return type_.user_define_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Status::set_user_define(const std::string& value) {
  // @@protoc_insertion_point(field_set:sim_msg.Status.user_define)
  if (!has_user_define()) {
    clear_type();
    set_has_user_define();
    type_.user_define_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  type_.user_define_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.Status.user_define)
}
inline void Status::set_user_define(std::string&& value) {
  // @@protoc_insertion_point(field_set:sim_msg.Status.user_define)
  if (!has_user_define()) {
    clear_type();
    set_has_user_define();
    type_.user_define_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  type_.user_define_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.Status.user_define)
}
inline void Status::set_user_define(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_user_define()) {
    clear_type();
    set_has_user_define();
    type_.user_define_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  type_.user_define_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.Status.user_define)
}
inline void Status::set_user_define(const void* value, size_t size) {
  if (!has_user_define()) {
    clear_type();
    set_has_user_define();
    type_.user_define_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  type_.user_define_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.Status.user_define)
}
inline std::string* Status::mutable_user_define() {
  if (!has_user_define()) {
    clear_type();
    set_has_user_define();
    type_.user_define_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Status.user_define)
  return type_.user_define_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Status::release_user_define() {
  // @@protoc_insertion_point(field_release:sim_msg.Status.user_define)
  if (has_user_define()) {
    clear_has_type();
    return type_.user_define_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void Status::set_allocated_user_define(std::string* user_define) {
  if (has_type()) {
    clear_type();
  }
  if (user_define != nullptr) {
    set_has_user_define();
    type_.user_define_.UnsafeSetDefault(user_define);
  }
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Status.user_define)
}

// .sim_msg.OnOff emergency_brake = 2;
inline bool Status::has_emergency_brake() const {
  return type_case() == kEmergencyBrake;
}
inline void Status::set_has_emergency_brake() {
  _oneof_case_[0] = kEmergencyBrake;
}
inline void Status::clear_emergency_brake() {
  if (has_emergency_brake()) {
    type_.emergency_brake_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Status::emergency_brake() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.emergency_brake)
  if (has_emergency_brake()) {
    return static_cast< ::sim_msg::OnOff >(type_.emergency_brake_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Status::set_emergency_brake(::sim_msg::OnOff value) {
  if (!has_emergency_brake()) {
    clear_type();
    set_has_emergency_brake();
  }
  type_.emergency_brake_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.emergency_brake)
}

// .sim_msg.OnOff vehicle_lost_control = 3;
inline bool Status::has_vehicle_lost_control() const {
  return type_case() == kVehicleLostControl;
}
inline void Status::set_has_vehicle_lost_control() {
  _oneof_case_[0] = kVehicleLostControl;
}
inline void Status::clear_vehicle_lost_control() {
  if (has_vehicle_lost_control()) {
    type_.vehicle_lost_control_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Status::vehicle_lost_control() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.vehicle_lost_control)
  if (has_vehicle_lost_control()) {
    return static_cast< ::sim_msg::OnOff >(type_.vehicle_lost_control_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Status::set_vehicle_lost_control(::sim_msg::OnOff value) {
  if (!has_vehicle_lost_control()) {
    clear_type();
    set_has_vehicle_lost_control();
  }
  type_.vehicle_lost_control_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.vehicle_lost_control)
}

// .sim_msg.OnOff hands_on_steeringwheel = 4;
inline bool Status::has_hands_on_steeringwheel() const {
  return type_case() == kHandsOnSteeringwheel;
}
inline void Status::set_has_hands_on_steeringwheel() {
  _oneof_case_[0] = kHandsOnSteeringwheel;
}
inline void Status::clear_hands_on_steeringwheel() {
  if (has_hands_on_steeringwheel()) {
    type_.hands_on_steeringwheel_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Status::hands_on_steeringwheel() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.hands_on_steeringwheel)
  if (has_hands_on_steeringwheel()) {
    return static_cast< ::sim_msg::OnOff >(type_.hands_on_steeringwheel_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Status::set_hands_on_steeringwheel(::sim_msg::OnOff value) {
  if (!has_hands_on_steeringwheel()) {
    clear_type();
    set_has_hands_on_steeringwheel();
  }
  type_.hands_on_steeringwheel_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.hands_on_steeringwheel)
}

// .sim_msg.OnOff eyes_on_road = 5;
inline bool Status::has_eyes_on_road() const {
  return type_case() == kEyesOnRoad;
}
inline void Status::set_has_eyes_on_road() {
  _oneof_case_[0] = kEyesOnRoad;
}
inline void Status::clear_eyes_on_road() {
  if (has_eyes_on_road()) {
    type_.eyes_on_road_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Status::eyes_on_road() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.eyes_on_road)
  if (has_eyes_on_road()) {
    return static_cast< ::sim_msg::OnOff >(type_.eyes_on_road_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Status::set_eyes_on_road(::sim_msg::OnOff value) {
  if (!has_eyes_on_road()) {
    clear_type();
    set_has_eyes_on_road();
  }
  type_.eyes_on_road_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.eyes_on_road)
}

// .sim_msg.OnOff lidar = 6;
inline bool Status::has_lidar() const {
  return type_case() == kLidar;
}
inline void Status::set_has_lidar() {
  _oneof_case_[0] = kLidar;
}
inline void Status::clear_lidar() {
  if (has_lidar()) {
    type_.lidar_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Status::lidar() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.lidar)
  if (has_lidar()) {
    return static_cast< ::sim_msg::OnOff >(type_.lidar_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Status::set_lidar(::sim_msg::OnOff value) {
  if (!has_lidar()) {
    clear_type();
    set_has_lidar();
  }
  type_.lidar_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.lidar)
}

// .sim_msg.OnOff radar = 7;
inline bool Status::has_radar() const {
  return type_case() == kRadar;
}
inline void Status::set_has_radar() {
  _oneof_case_[0] = kRadar;
}
inline void Status::clear_radar() {
  if (has_radar()) {
    type_.radar_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Status::radar() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.radar)
  if (has_radar()) {
    return static_cast< ::sim_msg::OnOff >(type_.radar_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Status::set_radar(::sim_msg::OnOff value) {
  if (!has_radar()) {
    clear_type();
    set_has_radar();
  }
  type_.radar_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.radar)
}

// .sim_msg.OnOff ultrasonic = 8;
inline bool Status::has_ultrasonic() const {
  return type_case() == kUltrasonic;
}
inline void Status::set_has_ultrasonic() {
  _oneof_case_[0] = kUltrasonic;
}
inline void Status::clear_ultrasonic() {
  if (has_ultrasonic()) {
    type_.ultrasonic_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Status::ultrasonic() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.ultrasonic)
  if (has_ultrasonic()) {
    return static_cast< ::sim_msg::OnOff >(type_.ultrasonic_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Status::set_ultrasonic(::sim_msg::OnOff value) {
  if (!has_ultrasonic()) {
    clear_type();
    set_has_ultrasonic();
  }
  type_.ultrasonic_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.ultrasonic)
}

// .sim_msg.OnOff camera = 9;
inline bool Status::has_camera() const {
  return type_case() == kCamera;
}
inline void Status::set_has_camera() {
  _oneof_case_[0] = kCamera;
}
inline void Status::clear_camera() {
  if (has_camera()) {
    type_.camera_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Status::camera() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.camera)
  if (has_camera()) {
    return static_cast< ::sim_msg::OnOff >(type_.camera_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Status::set_camera(::sim_msg::OnOff value) {
  if (!has_camera()) {
    clear_type();
    set_has_camera();
  }
  type_.camera_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.camera)
}

// .sim_msg.OnOff gnss = 10;
inline bool Status::has_gnss() const {
  return type_case() == kGnss;
}
inline void Status::set_has_gnss() {
  _oneof_case_[0] = kGnss;
}
inline void Status::clear_gnss() {
  if (has_gnss()) {
    type_.gnss_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Status::gnss() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.gnss)
  if (has_gnss()) {
    return static_cast< ::sim_msg::OnOff >(type_.gnss_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Status::set_gnss(::sim_msg::OnOff value) {
  if (!has_gnss()) {
    clear_type();
    set_has_gnss();
  }
  type_.gnss_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.gnss)
}

// .sim_msg.OnOff imu = 11;
inline bool Status::has_imu() const {
  return type_case() == kImu;
}
inline void Status::set_has_imu() {
  _oneof_case_[0] = kImu;
}
inline void Status::clear_imu() {
  if (has_imu()) {
    type_.imu_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Status::imu() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.imu)
  if (has_imu()) {
    return static_cast< ::sim_msg::OnOff >(type_.imu_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Status::set_imu(::sim_msg::OnOff value) {
  if (!has_imu()) {
    clear_type();
    set_has_imu();
  }
  type_.imu_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.imu)
}

// .sim_msg.OnOff localization = 12;
inline bool Status::has_localization() const {
  return type_case() == kLocalization;
}
inline void Status::set_has_localization() {
  _oneof_case_[0] = kLocalization;
}
inline void Status::clear_localization() {
  if (has_localization()) {
    type_.localization_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Status::localization() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.localization)
  if (has_localization()) {
    return static_cast< ::sim_msg::OnOff >(type_.localization_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Status::set_localization(::sim_msg::OnOff value) {
  if (!has_localization()) {
    clear_type();
    set_has_localization();
  }
  type_.localization_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.localization)
}

// .sim_msg.BeamSts beam = 13;
inline bool Status::has_beam() const {
  return type_case() == kBeam;
}
inline void Status::set_has_beam() {
  _oneof_case_[0] = kBeam;
}
inline void Status::clear_beam() {
  if (has_beam()) {
    type_.beam_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::BeamSts Status::beam() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.beam)
  if (has_beam()) {
    return static_cast< ::sim_msg::BeamSts >(type_.beam_);
  }
  return static_cast< ::sim_msg::BeamSts >(0);
}
inline void Status::set_beam(::sim_msg::BeamSts value) {
  if (!has_beam()) {
    clear_type();
    set_has_beam();
  }
  type_.beam_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.beam)
}

// .sim_msg.OnOff brake_light = 14;
inline bool Status::has_brake_light() const {
  return type_case() == kBrakeLight;
}
inline void Status::set_has_brake_light() {
  _oneof_case_[0] = kBrakeLight;
}
inline void Status::clear_brake_light() {
  if (has_brake_light()) {
    type_.brake_light_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Status::brake_light() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.brake_light)
  if (has_brake_light()) {
    return static_cast< ::sim_msg::OnOff >(type_.brake_light_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Status::set_brake_light(::sim_msg::OnOff value) {
  if (!has_brake_light()) {
    clear_type();
    set_has_brake_light();
  }
  type_.brake_light_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.brake_light)
}

// .sim_msg.OnOff hazard_light = 15;
inline bool Status::has_hazard_light() const {
  return type_case() == kHazardLight;
}
inline void Status::set_has_hazard_light() {
  _oneof_case_[0] = kHazardLight;
}
inline void Status::clear_hazard_light() {
  if (has_hazard_light()) {
    type_.hazard_light_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Status::hazard_light() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.hazard_light)
  if (has_hazard_light()) {
    return static_cast< ::sim_msg::OnOff >(type_.hazard_light_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Status::set_hazard_light(::sim_msg::OnOff value) {
  if (!has_hazard_light()) {
    clear_type();
    set_has_hazard_light();
  }
  type_.hazard_light_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.hazard_light)
}

// .sim_msg.OnOff left_turn_light = 16;
inline bool Status::has_left_turn_light() const {
  return type_case() == kLeftTurnLight;
}
inline void Status::set_has_left_turn_light() {
  _oneof_case_[0] = kLeftTurnLight;
}
inline void Status::clear_left_turn_light() {
  if (has_left_turn_light()) {
    type_.left_turn_light_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Status::left_turn_light() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.left_turn_light)
  if (has_left_turn_light()) {
    return static_cast< ::sim_msg::OnOff >(type_.left_turn_light_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Status::set_left_turn_light(::sim_msg::OnOff value) {
  if (!has_left_turn_light()) {
    clear_type();
    set_has_left_turn_light();
  }
  type_.left_turn_light_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.left_turn_light)
}

// .sim_msg.OnOff right_turn_light = 17;
inline bool Status::has_right_turn_light() const {
  return type_case() == kRightTurnLight;
}
inline void Status::set_has_right_turn_light() {
  _oneof_case_[0] = kRightTurnLight;
}
inline void Status::clear_right_turn_light() {
  if (has_right_turn_light()) {
    type_.right_turn_light_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Status::right_turn_light() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.right_turn_light)
  if (has_right_turn_light()) {
    return static_cast< ::sim_msg::OnOff >(type_.right_turn_light_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Status::set_right_turn_light(::sim_msg::OnOff value) {
  if (!has_right_turn_light()) {
    clear_type();
    set_has_right_turn_light();
  }
  type_.right_turn_light_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.right_turn_light)
}

// .sim_msg.OnOff driver_seatbelt = 18;
inline bool Status::has_driver_seatbelt() const {
  return type_case() == kDriverSeatbelt;
}
inline void Status::set_has_driver_seatbelt() {
  _oneof_case_[0] = kDriverSeatbelt;
}
inline void Status::clear_driver_seatbelt() {
  if (has_driver_seatbelt()) {
    type_.driver_seatbelt_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Status::driver_seatbelt() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.driver_seatbelt)
  if (has_driver_seatbelt()) {
    return static_cast< ::sim_msg::OnOff >(type_.driver_seatbelt_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Status::set_driver_seatbelt(::sim_msg::OnOff value) {
  if (!has_driver_seatbelt()) {
    clear_type();
    set_has_driver_seatbelt();
  }
  type_.driver_seatbelt_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.driver_seatbelt)
}

// .sim_msg.OnOff passenger_seatbelt = 19;
inline bool Status::has_passenger_seatbelt() const {
  return type_case() == kPassengerSeatbelt;
}
inline void Status::set_has_passenger_seatbelt() {
  _oneof_case_[0] = kPassengerSeatbelt;
}
inline void Status::clear_passenger_seatbelt() {
  if (has_passenger_seatbelt()) {
    type_.passenger_seatbelt_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Status::passenger_seatbelt() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.passenger_seatbelt)
  if (has_passenger_seatbelt()) {
    return static_cast< ::sim_msg::OnOff >(type_.passenger_seatbelt_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Status::set_passenger_seatbelt(::sim_msg::OnOff value) {
  if (!has_passenger_seatbelt()) {
    clear_type();
    set_has_passenger_seatbelt();
  }
  type_.passenger_seatbelt_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.passenger_seatbelt)
}

// .sim_msg.OnOff driver_door = 20;
inline bool Status::has_driver_door() const {
  return type_case() == kDriverDoor;
}
inline void Status::set_has_driver_door() {
  _oneof_case_[0] = kDriverDoor;
}
inline void Status::clear_driver_door() {
  if (has_driver_door()) {
    type_.driver_door_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Status::driver_door() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.driver_door)
  if (has_driver_door()) {
    return static_cast< ::sim_msg::OnOff >(type_.driver_door_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Status::set_driver_door(::sim_msg::OnOff value) {
  if (!has_driver_door()) {
    clear_type();
    set_has_driver_door();
  }
  type_.driver_door_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.driver_door)
}

// .sim_msg.OnOff passenger_door = 21;
inline bool Status::has_passenger_door() const {
  return type_case() == kPassengerDoor;
}
inline void Status::set_has_passenger_door() {
  _oneof_case_[0] = kPassengerDoor;
}
inline void Status::clear_passenger_door() {
  if (has_passenger_door()) {
    type_.passenger_door_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Status::passenger_door() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.passenger_door)
  if (has_passenger_door()) {
    return static_cast< ::sim_msg::OnOff >(type_.passenger_door_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Status::set_passenger_door(::sim_msg::OnOff value) {
  if (!has_passenger_door()) {
    clear_type();
    set_has_passenger_door();
  }
  type_.passenger_door_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.passenger_door)
}

// .sim_msg.OnOff hood = 22;
inline bool Status::has_hood() const {
  return type_case() == kHood;
}
inline void Status::set_has_hood() {
  _oneof_case_[0] = kHood;
}
inline void Status::clear_hood() {
  if (has_hood()) {
    type_.hood_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Status::hood() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.hood)
  if (has_hood()) {
    return static_cast< ::sim_msg::OnOff >(type_.hood_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Status::set_hood(::sim_msg::OnOff value) {
  if (!has_hood()) {
    clear_type();
    set_has_hood();
  }
  type_.hood_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.hood)
}

// .sim_msg.OnOff trunk = 23;
inline bool Status::has_trunk() const {
  return type_case() == kTrunk;
}
inline void Status::set_has_trunk() {
  _oneof_case_[0] = kTrunk;
}
inline void Status::clear_trunk() {
  if (has_trunk()) {
    type_.trunk_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::OnOff Status::trunk() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.trunk)
  if (has_trunk()) {
    return static_cast< ::sim_msg::OnOff >(type_.trunk_);
  }
  return static_cast< ::sim_msg::OnOff >(0);
}
inline void Status::set_trunk(::sim_msg::OnOff value) {
  if (!has_trunk()) {
    clear_type();
    set_has_trunk();
  }
  type_.trunk_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.trunk)
}

// .sim_msg.ParkingBrakeSts parkingbrake = 24;
inline bool Status::has_parkingbrake() const {
  return type_case() == kParkingbrake;
}
inline void Status::set_has_parkingbrake() {
  _oneof_case_[0] = kParkingbrake;
}
inline void Status::clear_parkingbrake() {
  if (has_parkingbrake()) {
    type_.parkingbrake_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::ParkingBrakeSts Status::parkingbrake() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.parkingbrake)
  if (has_parkingbrake()) {
    return static_cast< ::sim_msg::ParkingBrakeSts >(type_.parkingbrake_);
  }
  return static_cast< ::sim_msg::ParkingBrakeSts >(0);
}
inline void Status::set_parkingbrake(::sim_msg::ParkingBrakeSts value) {
  if (!has_parkingbrake()) {
    clear_type();
    set_has_parkingbrake();
  }
  type_.parkingbrake_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.parkingbrake)
}

// .sim_msg.WiperSts wiper = 25;
inline bool Status::has_wiper() const {
  return type_case() == kWiper;
}
inline void Status::set_has_wiper() {
  _oneof_case_[0] = kWiper;
}
inline void Status::clear_wiper() {
  if (has_wiper()) {
    type_.wiper_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::WiperSts Status::wiper() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.wiper)
  if (has_wiper()) {
    return static_cast< ::sim_msg::WiperSts >(type_.wiper_);
  }
  return static_cast< ::sim_msg::WiperSts >(0);
}
inline void Status::set_wiper(::sim_msg::WiperSts value) {
  if (!has_wiper()) {
    clear_type();
    set_has_wiper();
  }
  type_.wiper_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.wiper)
}

// .sim_msg.GearSts gear = 26;
inline bool Status::has_gear() const {
  return type_case() == kGear;
}
inline void Status::set_has_gear() {
  _oneof_case_[0] = kGear;
}
inline void Status::clear_gear() {
  if (has_gear()) {
    type_.gear_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::GearSts Status::gear() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.gear)
  if (has_gear()) {
    return static_cast< ::sim_msg::GearSts >(type_.gear_);
  }
  return static_cast< ::sim_msg::GearSts >(0);
}
inline void Status::set_gear(::sim_msg::GearSts value) {
  if (!has_gear()) {
    clear_type();
    set_has_gear();
  }
  type_.gear_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.gear)
}

// .sim_msg.KeySts key = 27;
inline bool Status::has_key() const {
  return type_case() == kKey;
}
inline void Status::set_has_key() {
  _oneof_case_[0] = kKey;
}
inline void Status::clear_key() {
  if (has_key()) {
    type_.key_ = 0;
    clear_has_type();
  }
}
inline ::sim_msg::KeySts Status::key() const {
  // @@protoc_insertion_point(field_get:sim_msg.Status.key)
  if (has_key()) {
    return static_cast< ::sim_msg::KeySts >(type_.key_);
  }
  return static_cast< ::sim_msg::KeySts >(0);
}
inline void Status::set_key(::sim_msg::KeySts value) {
  if (!has_key()) {
    clear_type();
    set_has_key();
  }
  type_.key_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Status.key)
}

inline bool Status::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Status::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Status::TypeCase Status::type_case() const {
  return Status::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// VehicleInteraction

// .sim_msg.Activate activate = 1;
inline bool VehicleInteraction::has_activate() const {
  return this != internal_default_instance() && activate_ != nullptr;
}
inline void VehicleInteraction::clear_activate() {
  if (GetArenaNoVirtual() == nullptr && activate_ != nullptr) {
    delete activate_;
  }
  activate_ = nullptr;
}
inline const ::sim_msg::Activate& VehicleInteraction::activate() const {
  const ::sim_msg::Activate* p = activate_;
  // @@protoc_insertion_point(field_get:sim_msg.VehicleInteraction.activate)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Activate*>(
      &::sim_msg::_Activate_default_instance_);
}
inline ::sim_msg::Activate* VehicleInteraction::release_activate() {
  // @@protoc_insertion_point(field_release:sim_msg.VehicleInteraction.activate)
  
  ::sim_msg::Activate* temp = activate_;
  activate_ = nullptr;
  return temp;
}
inline ::sim_msg::Activate* VehicleInteraction::mutable_activate() {
  
  if (activate_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Activate>(GetArenaNoVirtual());
    activate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.VehicleInteraction.activate)
  return activate_;
}
inline void VehicleInteraction::set_allocated_activate(::sim_msg::Activate* activate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete activate_;
  }
  if (activate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      activate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activate, submessage_arena);
    }
    
  } else {
    
  }
  activate_ = activate;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.VehicleInteraction.activate)
}

// .sim_msg.Assign assign = 2;
inline bool VehicleInteraction::has_assign() const {
  return this != internal_default_instance() && assign_ != nullptr;
}
inline void VehicleInteraction::clear_assign() {
  if (GetArenaNoVirtual() == nullptr && assign_ != nullptr) {
    delete assign_;
  }
  assign_ = nullptr;
}
inline const ::sim_msg::Assign& VehicleInteraction::assign() const {
  const ::sim_msg::Assign* p = assign_;
  // @@protoc_insertion_point(field_get:sim_msg.VehicleInteraction.assign)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Assign*>(
      &::sim_msg::_Assign_default_instance_);
}
inline ::sim_msg::Assign* VehicleInteraction::release_assign() {
  // @@protoc_insertion_point(field_release:sim_msg.VehicleInteraction.assign)
  
  ::sim_msg::Assign* temp = assign_;
  assign_ = nullptr;
  return temp;
}
inline ::sim_msg::Assign* VehicleInteraction::mutable_assign() {
  
  if (assign_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Assign>(GetArenaNoVirtual());
    assign_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.VehicleInteraction.assign)
  return assign_;
}
inline void VehicleInteraction::set_allocated_assign(::sim_msg::Assign* assign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete assign_;
  }
  if (assign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      assign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, assign, submessage_arena);
    }
    
  } else {
    
  }
  assign_ = assign;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.VehicleInteraction.assign)
}

// .sim_msg.Override override = 3;
inline bool VehicleInteraction::has_override() const {
  return this != internal_default_instance() && override_ != nullptr;
}
inline void VehicleInteraction::clear_override() {
  if (GetArenaNoVirtual() == nullptr && override_ != nullptr) {
    delete override_;
  }
  override_ = nullptr;
}
inline const ::sim_msg::Override& VehicleInteraction::override() const {
  const ::sim_msg::Override* p = override_;
  // @@protoc_insertion_point(field_get:sim_msg.VehicleInteraction.override)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Override*>(
      &::sim_msg::_Override_default_instance_);
}
inline ::sim_msg::Override* VehicleInteraction::release_override() {
  // @@protoc_insertion_point(field_release:sim_msg.VehicleInteraction.override)
  
  ::sim_msg::Override* temp = override_;
  override_ = nullptr;
  return temp;
}
inline ::sim_msg::Override* VehicleInteraction::mutable_override() {
  
  if (override_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Override>(GetArenaNoVirtual());
    override_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.VehicleInteraction.override)
  return override_;
}
inline void VehicleInteraction::set_allocated_override(::sim_msg::Override* override) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete override_;
  }
  if (override) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      override = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, override, submessage_arena);
    }
    
  } else {
    
  }
  override_ = override;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.VehicleInteraction.override)
}

// .sim_msg.Command command = 4;
inline bool VehicleInteraction::has_command() const {
  return this != internal_default_instance() && command_ != nullptr;
}
inline void VehicleInteraction::clear_command() {
  if (GetArenaNoVirtual() == nullptr && command_ != nullptr) {
    delete command_;
  }
  command_ = nullptr;
}
inline const ::sim_msg::Command& VehicleInteraction::command() const {
  const ::sim_msg::Command* p = command_;
  // @@protoc_insertion_point(field_get:sim_msg.VehicleInteraction.command)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Command*>(
      &::sim_msg::_Command_default_instance_);
}
inline ::sim_msg::Command* VehicleInteraction::release_command() {
  // @@protoc_insertion_point(field_release:sim_msg.VehicleInteraction.command)
  
  ::sim_msg::Command* temp = command_;
  command_ = nullptr;
  return temp;
}
inline ::sim_msg::Command* VehicleInteraction::mutable_command() {
  
  if (command_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Command>(GetArenaNoVirtual());
    command_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.VehicleInteraction.command)
  return command_;
}
inline void VehicleInteraction::set_allocated_command(::sim_msg::Command* command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete command_;
  }
  if (command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    
  } else {
    
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.VehicleInteraction.command)
}

// .sim_msg.Status status = 5;
inline bool VehicleInteraction::has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline void VehicleInteraction::clear_status() {
  if (GetArenaNoVirtual() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::sim_msg::Status& VehicleInteraction::status() const {
  const ::sim_msg::Status* p = status_;
  // @@protoc_insertion_point(field_get:sim_msg.VehicleInteraction.status)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Status*>(
      &::sim_msg::_Status_default_instance_);
}
inline ::sim_msg::Status* VehicleInteraction::release_status() {
  // @@protoc_insertion_point(field_release:sim_msg.VehicleInteraction.status)
  
  ::sim_msg::Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::sim_msg::Status* VehicleInteraction::mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Status>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.VehicleInteraction.status)
  return status_;
}
inline void VehicleInteraction::set_allocated_status(::sim_msg::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.VehicleInteraction.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sim_msg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sim_msg::Activate_Automode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::Activate_Automode>() {
  return ::sim_msg::Activate_Automode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_vehicle_5finteraction_2eproto
