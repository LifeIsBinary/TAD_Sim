// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scene.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_scene_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_scene_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "basic.pb.h"
#include "settings.pb.h"
#include "waypoint.pb.h"
#include "environment.pb.h"
#include "vehicle_interaction.pb.h"
#include "vehicle_geometry.pb.h"
#include "scene_sensor_group.pb.h"
#include "scene_infrastructure_group.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_scene_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_scene_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[37]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_scene_2eproto;
namespace sim_msg {
class Action;
class ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class ActionAccel;
class ActionAccelDefaultTypeInternal;
extern ActionAccelDefaultTypeInternal _ActionAccel_default_instance_;
class ActionLaneChange;
class ActionLaneChangeDefaultTypeInternal;
extern ActionLaneChangeDefaultTypeInternal _ActionLaneChange_default_instance_;
class ActionLateralDistance;
class ActionLateralDistanceDefaultTypeInternal;
extern ActionLateralDistanceDefaultTypeInternal _ActionLateralDistance_default_instance_;
class ActionSpeed;
class ActionSpeedDefaultTypeInternal;
extern ActionSpeedDefaultTypeInternal _ActionSpeed_default_instance_;
class BoundingBox;
class BoundingBoxDefaultTypeInternal;
extern BoundingBoxDefaultTypeInternal _BoundingBox_default_instance_;
class Condition;
class ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class ConditionEgoAttachLaneidCustom;
class ConditionEgoAttachLaneidCustomDefaultTypeInternal;
extern ConditionEgoAttachLaneidCustomDefaultTypeInternal _ConditionEgoAttachLaneidCustom_default_instance_;
class ConditionReachDistance;
class ConditionReachDistanceDefaultTypeInternal;
extern ConditionReachDistanceDefaultTypeInternal _ConditionReachDistance_default_instance_;
class ConditionReachPosition;
class ConditionReachPositionDefaultTypeInternal;
extern ConditionReachPositionDefaultTypeInternal _ConditionReachPosition_default_instance_;
class ConditionRelativeDistance;
class ConditionRelativeDistanceDefaultTypeInternal;
extern ConditionRelativeDistanceDefaultTypeInternal _ConditionRelativeDistance_default_instance_;
class ConditionRelativeSpeed;
class ConditionRelativeSpeedDefaultTypeInternal;
extern ConditionRelativeSpeedDefaultTypeInternal _ConditionRelativeSpeed_default_instance_;
class ConditionSimulationTime;
class ConditionSimulationTimeDefaultTypeInternal;
extern ConditionSimulationTimeDefaultTypeInternal _ConditionSimulationTime_default_instance_;
class ConditionSpeed;
class ConditionSpeedDefaultTypeInternal;
extern ConditionSpeedDefaultTypeInternal _ConditionSpeed_default_instance_;
class ConditionStoryboardElementState;
class ConditionStoryboardElementStateDefaultTypeInternal;
extern ConditionStoryboardElementStateDefaultTypeInternal _ConditionStoryboardElementState_default_instance_;
class ConditionTimeHeadway;
class ConditionTimeHeadwayDefaultTypeInternal;
extern ConditionTimeHeadwayDefaultTypeInternal _ConditionTimeHeadway_default_instance_;
class ConditionTimeToCollision;
class ConditionTimeToCollisionDefaultTypeInternal;
extern ConditionTimeToCollisionDefaultTypeInternal _ConditionTimeToCollision_default_instance_;
class Dynamic;
class DynamicDefaultTypeInternal;
extern DynamicDefaultTypeInternal _Dynamic_default_instance_;
class DynamicConstraints;
class DynamicConstraintsDefaultTypeInternal;
extern DynamicConstraintsDefaultTypeInternal _DynamicConstraints_default_instance_;
class Ego;
class EgoDefaultTypeInternal;
extern EgoDefaultTypeInternal _Ego_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class InitialCommon;
class InitialCommonDefaultTypeInternal;
extern InitialCommonDefaultTypeInternal _InitialCommon_default_instance_;
class InitialEgo;
class InitialEgoDefaultTypeInternal;
extern InitialEgoDefaultTypeInternal _InitialEgo_default_instance_;
class InitialVehicle;
class InitialVehicleDefaultTypeInternal;
extern InitialVehicleDefaultTypeInternal _InitialVehicle_default_instance_;
class InitialVru;
class InitialVruDefaultTypeInternal;
extern InitialVruDefaultTypeInternal _InitialVru_default_instance_;
class MapModel;
class MapModelDefaultTypeInternal;
extern MapModelDefaultTypeInternal _MapModel_default_instance_;
class MiscellaneousObject;
class MiscellaneousObjectDefaultTypeInternal;
extern MiscellaneousObjectDefaultTypeInternal _MiscellaneousObject_default_instance_;
class Performance;
class PerformanceDefaultTypeInternal;
extern PerformanceDefaultTypeInternal _Performance_default_instance_;
class PhysicleCommon;
class PhysicleCommonDefaultTypeInternal;
extern PhysicleCommonDefaultTypeInternal _PhysicleCommon_default_instance_;
class PhysicleEgo;
class PhysicleEgoDefaultTypeInternal;
extern PhysicleEgoDefaultTypeInternal _PhysicleEgo_default_instance_;
class PhysicleVehicle;
class PhysicleVehicleDefaultTypeInternal;
extern PhysicleVehicleDefaultTypeInternal _PhysicleVehicle_default_instance_;
class PhysicleVru;
class PhysicleVruDefaultTypeInternal;
extern PhysicleVruDefaultTypeInternal _PhysicleVru_default_instance_;
class Scene;
class SceneDefaultTypeInternal;
extern SceneDefaultTypeInternal _Scene_default_instance_;
class Scene_EnvironmentEntry_DoNotUse;
class Scene_EnvironmentEntry_DoNotUseDefaultTypeInternal;
extern Scene_EnvironmentEntry_DoNotUseDefaultTypeInternal _Scene_EnvironmentEntry_DoNotUse_default_instance_;
class Trigger;
class TriggerDefaultTypeInternal;
extern TriggerDefaultTypeInternal _Trigger_default_instance_;
class Vehicle;
class VehicleDefaultTypeInternal;
extern VehicleDefaultTypeInternal _Vehicle_default_instance_;
class VulnerableRoadUser;
class VulnerableRoadUserDefaultTypeInternal;
extern VulnerableRoadUserDefaultTypeInternal _VulnerableRoadUser_default_instance_;
}  // namespace sim_msg
PROTOBUF_NAMESPACE_OPEN
template<> ::sim_msg::Action* Arena::CreateMaybeMessage<::sim_msg::Action>(Arena*);
template<> ::sim_msg::ActionAccel* Arena::CreateMaybeMessage<::sim_msg::ActionAccel>(Arena*);
template<> ::sim_msg::ActionLaneChange* Arena::CreateMaybeMessage<::sim_msg::ActionLaneChange>(Arena*);
template<> ::sim_msg::ActionLateralDistance* Arena::CreateMaybeMessage<::sim_msg::ActionLateralDistance>(Arena*);
template<> ::sim_msg::ActionSpeed* Arena::CreateMaybeMessage<::sim_msg::ActionSpeed>(Arena*);
template<> ::sim_msg::BoundingBox* Arena::CreateMaybeMessage<::sim_msg::BoundingBox>(Arena*);
template<> ::sim_msg::Condition* Arena::CreateMaybeMessage<::sim_msg::Condition>(Arena*);
template<> ::sim_msg::ConditionEgoAttachLaneidCustom* Arena::CreateMaybeMessage<::sim_msg::ConditionEgoAttachLaneidCustom>(Arena*);
template<> ::sim_msg::ConditionReachDistance* Arena::CreateMaybeMessage<::sim_msg::ConditionReachDistance>(Arena*);
template<> ::sim_msg::ConditionReachPosition* Arena::CreateMaybeMessage<::sim_msg::ConditionReachPosition>(Arena*);
template<> ::sim_msg::ConditionRelativeDistance* Arena::CreateMaybeMessage<::sim_msg::ConditionRelativeDistance>(Arena*);
template<> ::sim_msg::ConditionRelativeSpeed* Arena::CreateMaybeMessage<::sim_msg::ConditionRelativeSpeed>(Arena*);
template<> ::sim_msg::ConditionSimulationTime* Arena::CreateMaybeMessage<::sim_msg::ConditionSimulationTime>(Arena*);
template<> ::sim_msg::ConditionSpeed* Arena::CreateMaybeMessage<::sim_msg::ConditionSpeed>(Arena*);
template<> ::sim_msg::ConditionStoryboardElementState* Arena::CreateMaybeMessage<::sim_msg::ConditionStoryboardElementState>(Arena*);
template<> ::sim_msg::ConditionTimeHeadway* Arena::CreateMaybeMessage<::sim_msg::ConditionTimeHeadway>(Arena*);
template<> ::sim_msg::ConditionTimeToCollision* Arena::CreateMaybeMessage<::sim_msg::ConditionTimeToCollision>(Arena*);
template<> ::sim_msg::Dynamic* Arena::CreateMaybeMessage<::sim_msg::Dynamic>(Arena*);
template<> ::sim_msg::DynamicConstraints* Arena::CreateMaybeMessage<::sim_msg::DynamicConstraints>(Arena*);
template<> ::sim_msg::Ego* Arena::CreateMaybeMessage<::sim_msg::Ego>(Arena*);
template<> ::sim_msg::Event* Arena::CreateMaybeMessage<::sim_msg::Event>(Arena*);
template<> ::sim_msg::InitialCommon* Arena::CreateMaybeMessage<::sim_msg::InitialCommon>(Arena*);
template<> ::sim_msg::InitialEgo* Arena::CreateMaybeMessage<::sim_msg::InitialEgo>(Arena*);
template<> ::sim_msg::InitialVehicle* Arena::CreateMaybeMessage<::sim_msg::InitialVehicle>(Arena*);
template<> ::sim_msg::InitialVru* Arena::CreateMaybeMessage<::sim_msg::InitialVru>(Arena*);
template<> ::sim_msg::MapModel* Arena::CreateMaybeMessage<::sim_msg::MapModel>(Arena*);
template<> ::sim_msg::MiscellaneousObject* Arena::CreateMaybeMessage<::sim_msg::MiscellaneousObject>(Arena*);
template<> ::sim_msg::Performance* Arena::CreateMaybeMessage<::sim_msg::Performance>(Arena*);
template<> ::sim_msg::PhysicleCommon* Arena::CreateMaybeMessage<::sim_msg::PhysicleCommon>(Arena*);
template<> ::sim_msg::PhysicleEgo* Arena::CreateMaybeMessage<::sim_msg::PhysicleEgo>(Arena*);
template<> ::sim_msg::PhysicleVehicle* Arena::CreateMaybeMessage<::sim_msg::PhysicleVehicle>(Arena*);
template<> ::sim_msg::PhysicleVru* Arena::CreateMaybeMessage<::sim_msg::PhysicleVru>(Arena*);
template<> ::sim_msg::Scene* Arena::CreateMaybeMessage<::sim_msg::Scene>(Arena*);
template<> ::sim_msg::Scene_EnvironmentEntry_DoNotUse* Arena::CreateMaybeMessage<::sim_msg::Scene_EnvironmentEntry_DoNotUse>(Arena*);
template<> ::sim_msg::Trigger* Arena::CreateMaybeMessage<::sim_msg::Trigger>(Arena*);
template<> ::sim_msg::Vehicle* Arena::CreateMaybeMessage<::sim_msg::Vehicle>(Arena*);
template<> ::sim_msg::VulnerableRoadUser* Arena::CreateMaybeMessage<::sim_msg::VulnerableRoadUser>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sim_msg {

enum ActionAccel_EndType : int {
  ActionAccel_EndType_END_TYPE_NONE = 0,
  ActionAccel_EndType_END_TYPE_TIME = 1,
  ActionAccel_EndType_END_TYPE_SPEED = 2,
  ActionAccel_EndType_ActionAccel_EndType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ActionAccel_EndType_ActionAccel_EndType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ActionAccel_EndType_IsValid(int value);
constexpr ActionAccel_EndType ActionAccel_EndType_EndType_MIN = ActionAccel_EndType_END_TYPE_NONE;
constexpr ActionAccel_EndType ActionAccel_EndType_EndType_MAX = ActionAccel_EndType_END_TYPE_SPEED;
constexpr int ActionAccel_EndType_EndType_ARRAYSIZE = ActionAccel_EndType_EndType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActionAccel_EndType_descriptor();
template<typename T>
inline const std::string& ActionAccel_EndType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActionAccel_EndType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActionAccel_EndType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActionAccel_EndType_descriptor(), enum_t_value);
}
inline bool ActionAccel_EndType_Parse(
    const std::string& name, ActionAccel_EndType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActionAccel_EndType>(
    ActionAccel_EndType_descriptor(), name, value);
}
enum ActionLaneChange_Dir : int {
  ActionLaneChange_Dir_DIR_LEFT = 0,
  ActionLaneChange_Dir_DIR_RIGHT = 1,
  ActionLaneChange_Dir_DIR_LEFT_IN_LANE = 2,
  ActionLaneChange_Dir_DIR_RIGHT_IN_LANE = 3,
  ActionLaneChange_Dir_ActionLaneChange_Dir_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ActionLaneChange_Dir_ActionLaneChange_Dir_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ActionLaneChange_Dir_IsValid(int value);
constexpr ActionLaneChange_Dir ActionLaneChange_Dir_Dir_MIN = ActionLaneChange_Dir_DIR_LEFT;
constexpr ActionLaneChange_Dir ActionLaneChange_Dir_Dir_MAX = ActionLaneChange_Dir_DIR_RIGHT_IN_LANE;
constexpr int ActionLaneChange_Dir_Dir_ARRAYSIZE = ActionLaneChange_Dir_Dir_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActionLaneChange_Dir_descriptor();
template<typename T>
inline const std::string& ActionLaneChange_Dir_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActionLaneChange_Dir>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActionLaneChange_Dir_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActionLaneChange_Dir_descriptor(), enum_t_value);
}
inline bool ActionLaneChange_Dir_Parse(
    const std::string& name, ActionLaneChange_Dir* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActionLaneChange_Dir>(
    ActionLaneChange_Dir_descriptor(), name, value);
}
enum CategoryVehicle : int {
  CATEGORY_VEHICLE_CAR = 0,
  CATEGORY_VEHICLE_BUS = 1,
  CATEGORY_VEHICLE_TRUCK = 2,
  CATEGORY_VEHICLE_TRALLER = 3,
  CATEGORY_VEHICLE_BIKE = 4,
  CATEGORY_VEHICLE_ELECTRIC_BIKE = 5,
  CATEGORY_VEHICLE_MOTORBIKE = 6,
  CATEGORY_VEHICLE_ELECTRIC_MOTORBIKE = 7,
  CATEGORY_VEHICLE_ELECTRIC_SEMITRAILER = 8,
  CATEGORY_VEHICLE_ELECTRIC_CRANE = 9,
  CategoryVehicle_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CategoryVehicle_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CategoryVehicle_IsValid(int value);
constexpr CategoryVehicle CategoryVehicle_MIN = CATEGORY_VEHICLE_CAR;
constexpr CategoryVehicle CategoryVehicle_MAX = CATEGORY_VEHICLE_ELECTRIC_CRANE;
constexpr int CategoryVehicle_ARRAYSIZE = CategoryVehicle_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CategoryVehicle_descriptor();
template<typename T>
inline const std::string& CategoryVehicle_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CategoryVehicle>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CategoryVehicle_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CategoryVehicle_descriptor(), enum_t_value);
}
inline bool CategoryVehicle_Parse(
    const std::string& name, CategoryVehicle* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CategoryVehicle>(
    CategoryVehicle_descriptor(), name, value);
}
enum CategoryVru : int {
  CATEGORY_VRU_ANIMAL = 0,
  CATEGORY_VRU_PEDESTRIAN = 1,
  CATEGORY_VRU_WHEELCHAIR = 2,
  CategoryVru_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CategoryVru_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CategoryVru_IsValid(int value);
constexpr CategoryVru CategoryVru_MIN = CATEGORY_VRU_ANIMAL;
constexpr CategoryVru CategoryVru_MAX = CATEGORY_VRU_WHEELCHAIR;
constexpr int CategoryVru_ARRAYSIZE = CategoryVru_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CategoryVru_descriptor();
template<typename T>
inline const std::string& CategoryVru_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CategoryVru>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CategoryVru_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CategoryVru_descriptor(), enum_t_value);
}
inline bool CategoryVru_Parse(
    const std::string& name, CategoryVru* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CategoryVru>(
    CategoryVru_descriptor(), name, value);
}
enum CategoryMisc : int {
  CATEGORY_MISC_BARRIER = 0,
  CATEGORY_MISC_BUILDING = 1,
  CATEGORY_MISC_CROSSING = 2,
  CATEGORY_MISC_GANTRY = 3,
  CATEGORY_MISC_OBSTACLE = 4,
  CATEGORY_MISC_PARKING_SPACE = 5,
  CATEGORY_MISC_PATCH = 6,
  CATEGORY_MISC_POLE = 7,
  CATEGORY_MISC_RAILING = 8,
  CATEGORY_MISC_ROADMARK = 9,
  CATEGORY_MISC_SOUND_BARRIER = 10,
  CATEGORY_MISC_STREET_LAMP = 11,
  CATEGORY_MISC_TRAFFIC_IS_LAND = 12,
  CATEGORY_MISC_TREE = 13,
  CATEGORY_MISC_VEGETATION = 14,
  CATEGORY_MISC_NONE = 15,
  CategoryMisc_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CategoryMisc_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CategoryMisc_IsValid(int value);
constexpr CategoryMisc CategoryMisc_MIN = CATEGORY_MISC_BARRIER;
constexpr CategoryMisc CategoryMisc_MAX = CATEGORY_MISC_NONE;
constexpr int CategoryMisc_ARRAYSIZE = CategoryMisc_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CategoryMisc_descriptor();
template<typename T>
inline const std::string& CategoryMisc_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CategoryMisc>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CategoryMisc_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CategoryMisc_descriptor(), enum_t_value);
}
inline bool CategoryMisc_Parse(
    const std::string& name, CategoryMisc* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CategoryMisc>(
    CategoryMisc_descriptor(), name, value);
}
enum Color : int {
  COLOR_WHITE = 0,
  COLOR_SILVER = 1,
  COLOR_GRAY = 2,
  COLOR_BLACK = 3,
  COLOR_RED = 4,
  COLOR_MAROON = 5,
  COLOR_YELLOW = 6,
  COLOR_OLIVE = 7,
  COLOR_LIME = 8,
  COLOR_GREEN = 9,
  COLOR_AQUA = 10,
  COLOR_TEAL = 11,
  COLOR_BLUE = 12,
  COLOR_NAVY = 13,
  COLOR_FUCHSIA = 14,
  COLOR_PURPLE = 15,
  Color_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Color_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Color_IsValid(int value);
constexpr Color Color_MIN = COLOR_WHITE;
constexpr Color Color_MAX = COLOR_PURPLE;
constexpr int Color_ARRAYSIZE = Color_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Color_descriptor();
template<typename T>
inline const std::string& Color_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Color>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Color_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Color_descriptor(), enum_t_value);
}
inline bool Color_Parse(
    const std::string& name, Color* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Color>(
    Color_descriptor(), name, value);
}
enum BehaviorType : int {
  BEHAVIOR_TYPE_USER_DEFINE = 0,
  BEHAVIOR_TYPE_TRAFFIC_VEHICLE = 1,
  BEHAVIOR_TYPE_TRAFFIC_VEHICLE_ARTERIAL = 2,
  BEHAVIOR_TYPE_TRAJECTORY_FOLLOW = 3,
  BehaviorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BehaviorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BehaviorType_IsValid(int value);
constexpr BehaviorType BehaviorType_MIN = BEHAVIOR_TYPE_USER_DEFINE;
constexpr BehaviorType BehaviorType_MAX = BEHAVIOR_TYPE_TRAJECTORY_FOLLOW;
constexpr int BehaviorType_ARRAYSIZE = BehaviorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BehaviorType_descriptor();
template<typename T>
inline const std::string& BehaviorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BehaviorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BehaviorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BehaviorType_descriptor(), enum_t_value);
}
inline bool BehaviorType_Parse(
    const std::string& name, BehaviorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BehaviorType>(
    BehaviorType_descriptor(), name, value);
}
enum Rule : int {
  RULE_EQUAL_TO = 0,
  RULE_GREATER_THEN = 1,
  RULE_GREATER_THEN_EQUAL = 2,
  RULE_LESS_THEN = 3,
  RULE_LESS_THEN_EQUAL = 4,
  RULE_NOT_EQUAL_TO = 5,
  Rule_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Rule_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Rule_IsValid(int value);
constexpr Rule Rule_MIN = RULE_EQUAL_TO;
constexpr Rule Rule_MAX = RULE_NOT_EQUAL_TO;
constexpr int Rule_ARRAYSIZE = Rule_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Rule_descriptor();
template<typename T>
inline const std::string& Rule_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Rule>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Rule_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Rule_descriptor(), enum_t_value);
}
inline bool Rule_Parse(
    const std::string& name, Rule* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Rule>(
    Rule_descriptor(), name, value);
}
enum DirDimension : int {
  DIR_DIMENSION_LONGITUDINAL = 0,
  DIR_DIMENSION_LATERAL = 1,
  DIR_DIMENSION_VERTICAL = 2,
  DirDimension_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DirDimension_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DirDimension_IsValid(int value);
constexpr DirDimension DirDimension_MIN = DIR_DIMENSION_LONGITUDINAL;
constexpr DirDimension DirDimension_MAX = DIR_DIMENSION_VERTICAL;
constexpr int DirDimension_ARRAYSIZE = DirDimension_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DirDimension_descriptor();
template<typename T>
inline const std::string& DirDimension_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirDimension>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirDimension_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DirDimension_descriptor(), enum_t_value);
}
inline bool DirDimension_Parse(
    const std::string& name, DirDimension* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DirDimension>(
    DirDimension_descriptor(), name, value);
}
enum ConditionEdge : int {
  CONDITION_EDGE_NONE = 0,
  CONDITION_EDGE_RISING = 1,
  CONDITION_EDGE_FALLING = 2,
  CONDITION_EDGE_BOTH = 3,
  ConditionEdge_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ConditionEdge_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ConditionEdge_IsValid(int value);
constexpr ConditionEdge ConditionEdge_MIN = CONDITION_EDGE_NONE;
constexpr ConditionEdge ConditionEdge_MAX = CONDITION_EDGE_BOTH;
constexpr int ConditionEdge_ARRAYSIZE = ConditionEdge_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConditionEdge_descriptor();
template<typename T>
inline const std::string& ConditionEdge_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConditionEdge>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConditionEdge_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConditionEdge_descriptor(), enum_t_value);
}
inline bool ConditionEdge_Parse(
    const std::string& name, ConditionEdge* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConditionEdge>(
    ConditionEdge_descriptor(), name, value);
}
enum DistanceType : int {
  DISTANCE_TYPE_EUCLIDEAN = 0,
  DISTANCE_TYPE_LANEPROJECTION = 1,
  DistanceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DistanceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DistanceType_IsValid(int value);
constexpr DistanceType DistanceType_MIN = DISTANCE_TYPE_EUCLIDEAN;
constexpr DistanceType DistanceType_MAX = DISTANCE_TYPE_LANEPROJECTION;
constexpr int DistanceType_ARRAYSIZE = DistanceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DistanceType_descriptor();
template<typename T>
inline const std::string& DistanceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DistanceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DistanceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DistanceType_descriptor(), enum_t_value);
}
inline bool DistanceType_Parse(
    const std::string& name, DistanceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DistanceType>(
    DistanceType_descriptor(), name, value);
}
enum StoryboardElementType : int {
  STORYBOARD_ELEMENT_TYPE_STORY = 0,
  STORYBOARD_ELEMENT_TYPE_ACT = 1,
  STORYBOARD_ELEMENT_TYPE_MANEUVER = 2,
  STORYBOARD_ELEMENT_TYPE_EVENT = 3,
  STORYBOARD_ELEMENT_TYPE_ACTION = 4,
  STORYBOARD_ELEMENT_TYPE_MANEUVER_GROUP = 5,
  StoryboardElementType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StoryboardElementType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StoryboardElementType_IsValid(int value);
constexpr StoryboardElementType StoryboardElementType_MIN = STORYBOARD_ELEMENT_TYPE_STORY;
constexpr StoryboardElementType StoryboardElementType_MAX = STORYBOARD_ELEMENT_TYPE_MANEUVER_GROUP;
constexpr int StoryboardElementType_ARRAYSIZE = StoryboardElementType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StoryboardElementType_descriptor();
template<typename T>
inline const std::string& StoryboardElementType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StoryboardElementType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StoryboardElementType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StoryboardElementType_descriptor(), enum_t_value);
}
inline bool StoryboardElementType_Parse(
    const std::string& name, StoryboardElementType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StoryboardElementType>(
    StoryboardElementType_descriptor(), name, value);
}
enum StoryboardElementState : int {
  STORYBOARD_ELEMENT_STATE_START_TRANSITION = 0,
  STORYBOARD_ELEMENT_STATE_END_TRANSITION = 1,
  STORYBOARD_ELEMENT_STATE_STOP_TRANSITION = 2,
  STORYBOARD_ELEMENT_STATE_SKIP_TRANSITION = 3,
  STORYBOARD_ELEMENT_STATE_COMPLETE_STATE = 4,
  STORYBOARD_ELEMENT_STATE_RUNNING_STATE = 5,
  STORYBOARD_ELEMENT_STATE_STANDBY_STATE = 6,
  StoryboardElementState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StoryboardElementState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StoryboardElementState_IsValid(int value);
constexpr StoryboardElementState StoryboardElementState_MIN = STORYBOARD_ELEMENT_STATE_START_TRANSITION;
constexpr StoryboardElementState StoryboardElementState_MAX = STORYBOARD_ELEMENT_STATE_STANDBY_STATE;
constexpr int StoryboardElementState_ARRAYSIZE = StoryboardElementState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StoryboardElementState_descriptor();
template<typename T>
inline const std::string& StoryboardElementState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StoryboardElementState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StoryboardElementState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StoryboardElementState_descriptor(), enum_t_value);
}
inline bool StoryboardElementState_Parse(
    const std::string& name, StoryboardElementState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StoryboardElementState>(
    StoryboardElementState_descriptor(), name, value);
}
// ===================================================================

class DynamicConstraints :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.DynamicConstraints) */ {
 public:
  DynamicConstraints();
  virtual ~DynamicConstraints();

  DynamicConstraints(const DynamicConstraints& from);
  DynamicConstraints(DynamicConstraints&& from) noexcept
    : DynamicConstraints() {
    *this = ::std::move(from);
  }

  inline DynamicConstraints& operator=(const DynamicConstraints& from) {
    CopyFrom(from);
    return *this;
  }
  inline DynamicConstraints& operator=(DynamicConstraints&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DynamicConstraints& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DynamicConstraints* internal_default_instance() {
    return reinterpret_cast<const DynamicConstraints*>(
               &_DynamicConstraints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DynamicConstraints& a, DynamicConstraints& b) {
    a.Swap(&b);
  }
  inline void Swap(DynamicConstraints* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DynamicConstraints* New() const final {
    return CreateMaybeMessage<DynamicConstraints>(nullptr);
  }

  DynamicConstraints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DynamicConstraints>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DynamicConstraints& from);
  void MergeFrom(const DynamicConstraints& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DynamicConstraints* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.DynamicConstraints";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxAccelerationFieldNumber = 1,
    kMaxDecelerationFieldNumber = 2,
    kMaxSpeedFieldNumber = 3,
  };
  // double max_acceleration = 1;
  void clear_max_acceleration();
  double max_acceleration() const;
  void set_max_acceleration(double value);

  // double max_deceleration = 2;
  void clear_max_deceleration();
  double max_deceleration() const;
  void set_max_deceleration(double value);

  // double max_speed = 3;
  void clear_max_speed();
  double max_speed() const;
  void set_max_speed(double value);

  // @@protoc_insertion_point(class_scope:sim_msg.DynamicConstraints)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double max_acceleration_;
  double max_deceleration_;
  double max_speed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class BoundingBox :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.BoundingBox) */ {
 public:
  BoundingBox();
  virtual ~BoundingBox();

  BoundingBox(const BoundingBox& from);
  BoundingBox(BoundingBox&& from) noexcept
    : BoundingBox() {
    *this = ::std::move(from);
  }

  inline BoundingBox& operator=(const BoundingBox& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoundingBox& operator=(BoundingBox&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BoundingBox& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BoundingBox* internal_default_instance() {
    return reinterpret_cast<const BoundingBox*>(
               &_BoundingBox_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BoundingBox& a, BoundingBox& b) {
    a.Swap(&b);
  }
  inline void Swap(BoundingBox* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BoundingBox* New() const final {
    return CreateMaybeMessage<BoundingBox>(nullptr);
  }

  BoundingBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BoundingBox>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BoundingBox& from);
  void MergeFrom(const BoundingBox& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoundingBox* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.BoundingBox";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterFieldNumber = 1,
    kLengthFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHigthFieldNumber = 4,
  };
  // .sim_msg.Vec3 center = 1;
  bool has_center() const;
  void clear_center();
  const ::sim_msg::Vec3& center() const;
  ::sim_msg::Vec3* release_center();
  ::sim_msg::Vec3* mutable_center();
  void set_allocated_center(::sim_msg::Vec3* center);

  // double length = 2;
  void clear_length();
  double length() const;
  void set_length(double value);

  // double width = 3;
  void clear_width();
  double width() const;
  void set_width(double value);

  // double higth = 4;
  void clear_higth();
  double higth() const;
  void set_higth(double value);

  // @@protoc_insertion_point(class_scope:sim_msg.BoundingBox)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::sim_msg::Vec3* center_;
  double length_;
  double width_;
  double higth_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class Performance :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Performance) */ {
 public:
  Performance();
  virtual ~Performance();

  Performance(const Performance& from);
  Performance(Performance&& from) noexcept
    : Performance() {
    *this = ::std::move(from);
  }

  inline Performance& operator=(const Performance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Performance& operator=(Performance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Performance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Performance* internal_default_instance() {
    return reinterpret_cast<const Performance*>(
               &_Performance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Performance& a, Performance& b) {
    a.Swap(&b);
  }
  inline void Swap(Performance* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Performance* New() const final {
    return CreateMaybeMessage<Performance>(nullptr);
  }

  Performance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Performance>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Performance& from);
  void MergeFrom(const Performance& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Performance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Performance";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxSpeedFieldNumber = 1,
    kMaxAccelFieldNumber = 2,
    kMaxDecelFieldNumber = 3,
  };
  // double max_speed = 1;
  void clear_max_speed();
  double max_speed() const;
  void set_max_speed(double value);

  // double max_accel = 2;
  void clear_max_accel();
  double max_accel() const;
  void set_max_accel(double value);

  // double max_decel = 3;
  void clear_max_decel();
  double max_decel() const;
  void set_max_decel(double value);

  // @@protoc_insertion_point(class_scope:sim_msg.Performance)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double max_speed_;
  double max_accel_;
  double max_decel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class ConditionTimeToCollision :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.ConditionTimeToCollision) */ {
 public:
  ConditionTimeToCollision();
  virtual ~ConditionTimeToCollision();

  ConditionTimeToCollision(const ConditionTimeToCollision& from);
  ConditionTimeToCollision(ConditionTimeToCollision&& from) noexcept
    : ConditionTimeToCollision() {
    *this = ::std::move(from);
  }

  inline ConditionTimeToCollision& operator=(const ConditionTimeToCollision& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConditionTimeToCollision& operator=(ConditionTimeToCollision&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConditionTimeToCollision& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionTimeToCollision* internal_default_instance() {
    return reinterpret_cast<const ConditionTimeToCollision*>(
               &_ConditionTimeToCollision_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ConditionTimeToCollision& a, ConditionTimeToCollision& b) {
    a.Swap(&b);
  }
  inline void Swap(ConditionTimeToCollision* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConditionTimeToCollision* New() const final {
    return CreateMaybeMessage<ConditionTimeToCollision>(nullptr);
  }

  ConditionTimeToCollision* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConditionTimeToCollision>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConditionTimeToCollision& from);
  void MergeFrom(const ConditionTimeToCollision& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionTimeToCollision* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.ConditionTimeToCollision";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityRefFieldNumber = 1,
    kDistanceTypeFieldNumber = 2,
    kRuleFieldNumber = 3,
    kValueFieldNumber = 4,
  };
  // string entity_ref = 1;
  void clear_entity_ref();
  const std::string& entity_ref() const;
  void set_entity_ref(const std::string& value);
  void set_entity_ref(std::string&& value);
  void set_entity_ref(const char* value);
  void set_entity_ref(const char* value, size_t size);
  std::string* mutable_entity_ref();
  std::string* release_entity_ref();
  void set_allocated_entity_ref(std::string* entity_ref);

  // .sim_msg.DistanceType distance_type = 2;
  void clear_distance_type();
  ::sim_msg::DistanceType distance_type() const;
  void set_distance_type(::sim_msg::DistanceType value);

  // .sim_msg.Rule rule = 3;
  void clear_rule();
  ::sim_msg::Rule rule() const;
  void set_rule(::sim_msg::Rule value);

  // double value = 4;
  void clear_value();
  double value() const;
  void set_value(double value);

  // @@protoc_insertion_point(class_scope:sim_msg.ConditionTimeToCollision)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entity_ref_;
  int distance_type_;
  int rule_;
  double value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class ConditionSpeed :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.ConditionSpeed) */ {
 public:
  ConditionSpeed();
  virtual ~ConditionSpeed();

  ConditionSpeed(const ConditionSpeed& from);
  ConditionSpeed(ConditionSpeed&& from) noexcept
    : ConditionSpeed() {
    *this = ::std::move(from);
  }

  inline ConditionSpeed& operator=(const ConditionSpeed& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConditionSpeed& operator=(ConditionSpeed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConditionSpeed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionSpeed* internal_default_instance() {
    return reinterpret_cast<const ConditionSpeed*>(
               &_ConditionSpeed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ConditionSpeed& a, ConditionSpeed& b) {
    a.Swap(&b);
  }
  inline void Swap(ConditionSpeed* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConditionSpeed* New() const final {
    return CreateMaybeMessage<ConditionSpeed>(nullptr);
  }

  ConditionSpeed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConditionSpeed>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConditionSpeed& from);
  void MergeFrom(const ConditionSpeed& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionSpeed* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.ConditionSpeed";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectionFieldNumber = 1,
    kRuleFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // .sim_msg.DirDimension direction = 1;
  void clear_direction();
  ::sim_msg::DirDimension direction() const;
  void set_direction(::sim_msg::DirDimension value);

  // .sim_msg.Rule rule = 2;
  void clear_rule();
  ::sim_msg::Rule rule() const;
  void set_rule(::sim_msg::Rule value);

  // double value = 3;
  void clear_value();
  double value() const;
  void set_value(double value);

  // @@protoc_insertion_point(class_scope:sim_msg.ConditionSpeed)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int direction_;
  int rule_;
  double value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class ConditionRelativeSpeed :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.ConditionRelativeSpeed) */ {
 public:
  ConditionRelativeSpeed();
  virtual ~ConditionRelativeSpeed();

  ConditionRelativeSpeed(const ConditionRelativeSpeed& from);
  ConditionRelativeSpeed(ConditionRelativeSpeed&& from) noexcept
    : ConditionRelativeSpeed() {
    *this = ::std::move(from);
  }

  inline ConditionRelativeSpeed& operator=(const ConditionRelativeSpeed& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConditionRelativeSpeed& operator=(ConditionRelativeSpeed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConditionRelativeSpeed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionRelativeSpeed* internal_default_instance() {
    return reinterpret_cast<const ConditionRelativeSpeed*>(
               &_ConditionRelativeSpeed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ConditionRelativeSpeed& a, ConditionRelativeSpeed& b) {
    a.Swap(&b);
  }
  inline void Swap(ConditionRelativeSpeed* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConditionRelativeSpeed* New() const final {
    return CreateMaybeMessage<ConditionRelativeSpeed>(nullptr);
  }

  ConditionRelativeSpeed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConditionRelativeSpeed>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConditionRelativeSpeed& from);
  void MergeFrom(const ConditionRelativeSpeed& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionRelativeSpeed* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.ConditionRelativeSpeed";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityRefFieldNumber = 1,
    kDirectionFieldNumber = 2,
    kRuleFieldNumber = 3,
    kValueFieldNumber = 4,
  };
  // string entity_ref = 1;
  void clear_entity_ref();
  const std::string& entity_ref() const;
  void set_entity_ref(const std::string& value);
  void set_entity_ref(std::string&& value);
  void set_entity_ref(const char* value);
  void set_entity_ref(const char* value, size_t size);
  std::string* mutable_entity_ref();
  std::string* release_entity_ref();
  void set_allocated_entity_ref(std::string* entity_ref);

  // .sim_msg.DirDimension direction = 2;
  void clear_direction();
  ::sim_msg::DirDimension direction() const;
  void set_direction(::sim_msg::DirDimension value);

  // .sim_msg.Rule rule = 3;
  void clear_rule();
  ::sim_msg::Rule rule() const;
  void set_rule(::sim_msg::Rule value);

  // double value = 4;
  void clear_value();
  double value() const;
  void set_value(double value);

  // @@protoc_insertion_point(class_scope:sim_msg.ConditionRelativeSpeed)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entity_ref_;
  int direction_;
  int rule_;
  double value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class ConditionReachPosition :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.ConditionReachPosition) */ {
 public:
  ConditionReachPosition();
  virtual ~ConditionReachPosition();

  ConditionReachPosition(const ConditionReachPosition& from);
  ConditionReachPosition(ConditionReachPosition&& from) noexcept
    : ConditionReachPosition() {
    *this = ::std::move(from);
  }

  inline ConditionReachPosition& operator=(const ConditionReachPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConditionReachPosition& operator=(ConditionReachPosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConditionReachPosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionReachPosition* internal_default_instance() {
    return reinterpret_cast<const ConditionReachPosition*>(
               &_ConditionReachPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ConditionReachPosition& a, ConditionReachPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(ConditionReachPosition* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConditionReachPosition* New() const final {
    return CreateMaybeMessage<ConditionReachPosition>(nullptr);
  }

  ConditionReachPosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConditionReachPosition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConditionReachPosition& from);
  void MergeFrom(const ConditionReachPosition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionReachPosition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.ConditionReachPosition";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kRadiusFieldNumber = 1,
  };
  // .sim_msg.Position position = 2;
  bool has_position() const;
  void clear_position();
  const ::sim_msg::Position& position() const;
  ::sim_msg::Position* release_position();
  ::sim_msg::Position* mutable_position();
  void set_allocated_position(::sim_msg::Position* position);

  // double radius = 1;
  void clear_radius();
  double radius() const;
  void set_radius(double value);

  // @@protoc_insertion_point(class_scope:sim_msg.ConditionReachPosition)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::sim_msg::Position* position_;
  double radius_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class ConditionRelativeDistance :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.ConditionRelativeDistance) */ {
 public:
  ConditionRelativeDistance();
  virtual ~ConditionRelativeDistance();

  ConditionRelativeDistance(const ConditionRelativeDistance& from);
  ConditionRelativeDistance(ConditionRelativeDistance&& from) noexcept
    : ConditionRelativeDistance() {
    *this = ::std::move(from);
  }

  inline ConditionRelativeDistance& operator=(const ConditionRelativeDistance& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConditionRelativeDistance& operator=(ConditionRelativeDistance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConditionRelativeDistance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionRelativeDistance* internal_default_instance() {
    return reinterpret_cast<const ConditionRelativeDistance*>(
               &_ConditionRelativeDistance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ConditionRelativeDistance& a, ConditionRelativeDistance& b) {
    a.Swap(&b);
  }
  inline void Swap(ConditionRelativeDistance* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConditionRelativeDistance* New() const final {
    return CreateMaybeMessage<ConditionRelativeDistance>(nullptr);
  }

  ConditionRelativeDistance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConditionRelativeDistance>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConditionRelativeDistance& from);
  void MergeFrom(const ConditionRelativeDistance& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionRelativeDistance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.ConditionRelativeDistance";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityRefFieldNumber = 1,
    kDistanceTypeFieldNumber = 2,
    kRuleFieldNumber = 3,
    kValueFieldNumber = 4,
  };
  // string entity_ref = 1;
  void clear_entity_ref();
  const std::string& entity_ref() const;
  void set_entity_ref(const std::string& value);
  void set_entity_ref(std::string&& value);
  void set_entity_ref(const char* value);
  void set_entity_ref(const char* value, size_t size);
  std::string* mutable_entity_ref();
  std::string* release_entity_ref();
  void set_allocated_entity_ref(std::string* entity_ref);

  // .sim_msg.DistanceType distance_type = 2;
  void clear_distance_type();
  ::sim_msg::DistanceType distance_type() const;
  void set_distance_type(::sim_msg::DistanceType value);

  // .sim_msg.Rule rule = 3;
  void clear_rule();
  ::sim_msg::Rule rule() const;
  void set_rule(::sim_msg::Rule value);

  // double value = 4;
  void clear_value();
  double value() const;
  void set_value(double value);

  // @@protoc_insertion_point(class_scope:sim_msg.ConditionRelativeDistance)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entity_ref_;
  int distance_type_;
  int rule_;
  double value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class ConditionEgoAttachLaneidCustom :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.ConditionEgoAttachLaneidCustom) */ {
 public:
  ConditionEgoAttachLaneidCustom();
  virtual ~ConditionEgoAttachLaneidCustom();

  ConditionEgoAttachLaneidCustom(const ConditionEgoAttachLaneidCustom& from);
  ConditionEgoAttachLaneidCustom(ConditionEgoAttachLaneidCustom&& from) noexcept
    : ConditionEgoAttachLaneidCustom() {
    *this = ::std::move(from);
  }

  inline ConditionEgoAttachLaneidCustom& operator=(const ConditionEgoAttachLaneidCustom& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConditionEgoAttachLaneidCustom& operator=(ConditionEgoAttachLaneidCustom&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConditionEgoAttachLaneidCustom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionEgoAttachLaneidCustom* internal_default_instance() {
    return reinterpret_cast<const ConditionEgoAttachLaneidCustom*>(
               &_ConditionEgoAttachLaneidCustom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ConditionEgoAttachLaneidCustom& a, ConditionEgoAttachLaneidCustom& b) {
    a.Swap(&b);
  }
  inline void Swap(ConditionEgoAttachLaneidCustom* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConditionEgoAttachLaneidCustom* New() const final {
    return CreateMaybeMessage<ConditionEgoAttachLaneidCustom>(nullptr);
  }

  ConditionEgoAttachLaneidCustom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConditionEgoAttachLaneidCustom>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConditionEgoAttachLaneidCustom& from);
  void MergeFrom(const ConditionEgoAttachLaneidCustom& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionEgoAttachLaneidCustom* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.ConditionEgoAttachLaneidCustom";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoadIdFieldNumber = 1,
    kSectionIdFieldNumber = 2,
    kLaneIdFieldNumber = 3,
  };
  // uint64 road_id = 1;
  void clear_road_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 road_id() const;
  void set_road_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // uint64 section_id = 2;
  void clear_section_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 section_id() const;
  void set_section_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // int64 lane_id = 3;
  void clear_lane_id();
  ::PROTOBUF_NAMESPACE_ID::int64 lane_id() const;
  void set_lane_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:sim_msg.ConditionEgoAttachLaneidCustom)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint64 road_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 section_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 lane_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class ConditionSimulationTime :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.ConditionSimulationTime) */ {
 public:
  ConditionSimulationTime();
  virtual ~ConditionSimulationTime();

  ConditionSimulationTime(const ConditionSimulationTime& from);
  ConditionSimulationTime(ConditionSimulationTime&& from) noexcept
    : ConditionSimulationTime() {
    *this = ::std::move(from);
  }

  inline ConditionSimulationTime& operator=(const ConditionSimulationTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConditionSimulationTime& operator=(ConditionSimulationTime&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConditionSimulationTime& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionSimulationTime* internal_default_instance() {
    return reinterpret_cast<const ConditionSimulationTime*>(
               &_ConditionSimulationTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ConditionSimulationTime& a, ConditionSimulationTime& b) {
    a.Swap(&b);
  }
  inline void Swap(ConditionSimulationTime* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConditionSimulationTime* New() const final {
    return CreateMaybeMessage<ConditionSimulationTime>(nullptr);
  }

  ConditionSimulationTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConditionSimulationTime>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConditionSimulationTime& from);
  void MergeFrom(const ConditionSimulationTime& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionSimulationTime* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.ConditionSimulationTime";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kRuleFieldNumber = 1,
  };
  // double value = 2;
  void clear_value();
  double value() const;
  void set_value(double value);

  // .sim_msg.Rule rule = 1;
  void clear_rule();
  ::sim_msg::Rule rule() const;
  void set_rule(::sim_msg::Rule value);

  // @@protoc_insertion_point(class_scope:sim_msg.ConditionSimulationTime)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double value_;
  int rule_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class ConditionTimeHeadway :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.ConditionTimeHeadway) */ {
 public:
  ConditionTimeHeadway();
  virtual ~ConditionTimeHeadway();

  ConditionTimeHeadway(const ConditionTimeHeadway& from);
  ConditionTimeHeadway(ConditionTimeHeadway&& from) noexcept
    : ConditionTimeHeadway() {
    *this = ::std::move(from);
  }

  inline ConditionTimeHeadway& operator=(const ConditionTimeHeadway& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConditionTimeHeadway& operator=(ConditionTimeHeadway&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConditionTimeHeadway& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionTimeHeadway* internal_default_instance() {
    return reinterpret_cast<const ConditionTimeHeadway*>(
               &_ConditionTimeHeadway_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ConditionTimeHeadway& a, ConditionTimeHeadway& b) {
    a.Swap(&b);
  }
  inline void Swap(ConditionTimeHeadway* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConditionTimeHeadway* New() const final {
    return CreateMaybeMessage<ConditionTimeHeadway>(nullptr);
  }

  ConditionTimeHeadway* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConditionTimeHeadway>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConditionTimeHeadway& from);
  void MergeFrom(const ConditionTimeHeadway& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionTimeHeadway* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.ConditionTimeHeadway";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityRefFieldNumber = 1,
    kValueFieldNumber = 2,
    kFreespaceFieldNumber = 3,
    kAlongRouteFieldNumber = 4,
    kRuleFieldNumber = 5,
  };
  // string entity_ref = 1;
  void clear_entity_ref();
  const std::string& entity_ref() const;
  void set_entity_ref(const std::string& value);
  void set_entity_ref(std::string&& value);
  void set_entity_ref(const char* value);
  void set_entity_ref(const char* value, size_t size);
  std::string* mutable_entity_ref();
  std::string* release_entity_ref();
  void set_allocated_entity_ref(std::string* entity_ref);

  // double value = 2;
  void clear_value();
  double value() const;
  void set_value(double value);

  // bool freespace = 3;
  void clear_freespace();
  bool freespace() const;
  void set_freespace(bool value);

  // bool along_route = 4;
  void clear_along_route();
  bool along_route() const;
  void set_along_route(bool value);

  // .sim_msg.Rule rule = 5;
  void clear_rule();
  ::sim_msg::Rule rule() const;
  void set_rule(::sim_msg::Rule value);

  // @@protoc_insertion_point(class_scope:sim_msg.ConditionTimeHeadway)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entity_ref_;
  double value_;
  bool freespace_;
  bool along_route_;
  int rule_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class ConditionReachDistance :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.ConditionReachDistance) */ {
 public:
  ConditionReachDistance();
  virtual ~ConditionReachDistance();

  ConditionReachDistance(const ConditionReachDistance& from);
  ConditionReachDistance(ConditionReachDistance&& from) noexcept
    : ConditionReachDistance() {
    *this = ::std::move(from);
  }

  inline ConditionReachDistance& operator=(const ConditionReachDistance& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConditionReachDistance& operator=(ConditionReachDistance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConditionReachDistance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionReachDistance* internal_default_instance() {
    return reinterpret_cast<const ConditionReachDistance*>(
               &_ConditionReachDistance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ConditionReachDistance& a, ConditionReachDistance& b) {
    a.Swap(&b);
  }
  inline void Swap(ConditionReachDistance* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConditionReachDistance* New() const final {
    return CreateMaybeMessage<ConditionReachDistance>(nullptr);
  }

  ConditionReachDistance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConditionReachDistance>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConditionReachDistance& from);
  void MergeFrom(const ConditionReachDistance& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionReachDistance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.ConditionReachDistance";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityRefFieldNumber = 1,
    kValueFieldNumber = 2,
    kFreespaceFieldNumber = 3,
    kAlongRouteFieldNumber = 4,
    kRuleFieldNumber = 5,
  };
  // string entity_ref = 1;
  void clear_entity_ref();
  const std::string& entity_ref() const;
  void set_entity_ref(const std::string& value);
  void set_entity_ref(std::string&& value);
  void set_entity_ref(const char* value);
  void set_entity_ref(const char* value, size_t size);
  std::string* mutable_entity_ref();
  std::string* release_entity_ref();
  void set_allocated_entity_ref(std::string* entity_ref);

  // double value = 2;
  void clear_value();
  double value() const;
  void set_value(double value);

  // bool freespace = 3;
  void clear_freespace();
  bool freespace() const;
  void set_freespace(bool value);

  // bool along_route = 4;
  void clear_along_route();
  bool along_route() const;
  void set_along_route(bool value);

  // .sim_msg.Rule rule = 5;
  void clear_rule();
  ::sim_msg::Rule rule() const;
  void set_rule(::sim_msg::Rule value);

  // @@protoc_insertion_point(class_scope:sim_msg.ConditionReachDistance)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entity_ref_;
  double value_;
  bool freespace_;
  bool along_route_;
  int rule_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class ConditionStoryboardElementState :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.ConditionStoryboardElementState) */ {
 public:
  ConditionStoryboardElementState();
  virtual ~ConditionStoryboardElementState();

  ConditionStoryboardElementState(const ConditionStoryboardElementState& from);
  ConditionStoryboardElementState(ConditionStoryboardElementState&& from) noexcept
    : ConditionStoryboardElementState() {
    *this = ::std::move(from);
  }

  inline ConditionStoryboardElementState& operator=(const ConditionStoryboardElementState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConditionStoryboardElementState& operator=(ConditionStoryboardElementState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConditionStoryboardElementState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionStoryboardElementState* internal_default_instance() {
    return reinterpret_cast<const ConditionStoryboardElementState*>(
               &_ConditionStoryboardElementState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ConditionStoryboardElementState& a, ConditionStoryboardElementState& b) {
    a.Swap(&b);
  }
  inline void Swap(ConditionStoryboardElementState* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConditionStoryboardElementState* New() const final {
    return CreateMaybeMessage<ConditionStoryboardElementState>(nullptr);
  }

  ConditionStoryboardElementState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConditionStoryboardElementState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConditionStoryboardElementState& from);
  void MergeFrom(const ConditionStoryboardElementState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionStoryboardElementState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.ConditionStoryboardElementState";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoryboardRefFieldNumber = 2,
    kTypeFieldNumber = 1,
    kStateFieldNumber = 3,
  };
  // string storyboard_ref = 2;
  void clear_storyboard_ref();
  const std::string& storyboard_ref() const;
  void set_storyboard_ref(const std::string& value);
  void set_storyboard_ref(std::string&& value);
  void set_storyboard_ref(const char* value);
  void set_storyboard_ref(const char* value, size_t size);
  std::string* mutable_storyboard_ref();
  std::string* release_storyboard_ref();
  void set_allocated_storyboard_ref(std::string* storyboard_ref);

  // .sim_msg.StoryboardElementType type = 1;
  void clear_type();
  ::sim_msg::StoryboardElementType type() const;
  void set_type(::sim_msg::StoryboardElementType value);

  // .sim_msg.StoryboardElementState state = 3;
  void clear_state();
  ::sim_msg::StoryboardElementState state() const;
  void set_state(::sim_msg::StoryboardElementState value);

  // @@protoc_insertion_point(class_scope:sim_msg.ConditionStoryboardElementState)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr storyboard_ref_;
  int type_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class Condition :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Condition) */ {
 public:
  Condition();
  virtual ~Condition();

  Condition(const Condition& from);
  Condition(Condition&& from) noexcept
    : Condition() {
    *this = ::std::move(from);
  }

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Condition& operator=(Condition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Condition& default_instance();

  enum TypeCase {
    kTtc = 4,
    kSpeed = 5,
    kRelativeSpeed = 6,
    kReachPosition = 7,
    kRelativeDistance = 8,
    kEgoAttachLaneidCustom = 9,
    kTimeHeadway = 10,
    kStoryboardElementState = 11,
    kSimulationTime = 12,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Condition* internal_default_instance() {
    return reinterpret_cast<const Condition*>(
               &_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Condition& a, Condition& b) {
    a.Swap(&b);
  }
  inline void Swap(Condition* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Condition* New() const final {
    return CreateMaybeMessage<Condition>(nullptr);
  }

  Condition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Condition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Condition& from);
  void MergeFrom(const Condition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Condition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Condition";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDelayFieldNumber = 2,
    kEdgeFieldNumber = 1,
    kCountFieldNumber = 3,
    kTtcFieldNumber = 4,
    kSpeedFieldNumber = 5,
    kRelativeSpeedFieldNumber = 6,
    kReachPositionFieldNumber = 7,
    kRelativeDistanceFieldNumber = 8,
    kEgoAttachLaneidCustomFieldNumber = 9,
    kTimeHeadwayFieldNumber = 10,
    kStoryboardElementStateFieldNumber = 11,
    kSimulationTimeFieldNumber = 12,
  };
  // double delay = 2;
  void clear_delay();
  double delay() const;
  void set_delay(double value);

  // .sim_msg.ConditionEdge edge = 1;
  void clear_edge();
  ::sim_msg::ConditionEdge edge() const;
  void set_edge(::sim_msg::ConditionEdge value);

  // uint32 count = 3;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // .sim_msg.ConditionTimeToCollision ttc = 4;
  bool has_ttc() const;
  void clear_ttc();
  const ::sim_msg::ConditionTimeToCollision& ttc() const;
  ::sim_msg::ConditionTimeToCollision* release_ttc();
  ::sim_msg::ConditionTimeToCollision* mutable_ttc();
  void set_allocated_ttc(::sim_msg::ConditionTimeToCollision* ttc);

  // .sim_msg.ConditionSpeed speed = 5;
  bool has_speed() const;
  void clear_speed();
  const ::sim_msg::ConditionSpeed& speed() const;
  ::sim_msg::ConditionSpeed* release_speed();
  ::sim_msg::ConditionSpeed* mutable_speed();
  void set_allocated_speed(::sim_msg::ConditionSpeed* speed);

  // .sim_msg.ConditionRelativeSpeed relative_speed = 6;
  bool has_relative_speed() const;
  void clear_relative_speed();
  const ::sim_msg::ConditionRelativeSpeed& relative_speed() const;
  ::sim_msg::ConditionRelativeSpeed* release_relative_speed();
  ::sim_msg::ConditionRelativeSpeed* mutable_relative_speed();
  void set_allocated_relative_speed(::sim_msg::ConditionRelativeSpeed* relative_speed);

  // .sim_msg.ConditionReachPosition reach_position = 7;
  bool has_reach_position() const;
  void clear_reach_position();
  const ::sim_msg::ConditionReachPosition& reach_position() const;
  ::sim_msg::ConditionReachPosition* release_reach_position();
  ::sim_msg::ConditionReachPosition* mutable_reach_position();
  void set_allocated_reach_position(::sim_msg::ConditionReachPosition* reach_position);

  // .sim_msg.ConditionRelativeDistance relative_distance = 8;
  bool has_relative_distance() const;
  void clear_relative_distance();
  const ::sim_msg::ConditionRelativeDistance& relative_distance() const;
  ::sim_msg::ConditionRelativeDistance* release_relative_distance();
  ::sim_msg::ConditionRelativeDistance* mutable_relative_distance();
  void set_allocated_relative_distance(::sim_msg::ConditionRelativeDistance* relative_distance);

  // .sim_msg.ConditionEgoAttachLaneidCustom ego_attach_laneid_custom = 9;
  bool has_ego_attach_laneid_custom() const;
  void clear_ego_attach_laneid_custom();
  const ::sim_msg::ConditionEgoAttachLaneidCustom& ego_attach_laneid_custom() const;
  ::sim_msg::ConditionEgoAttachLaneidCustom* release_ego_attach_laneid_custom();
  ::sim_msg::ConditionEgoAttachLaneidCustom* mutable_ego_attach_laneid_custom();
  void set_allocated_ego_attach_laneid_custom(::sim_msg::ConditionEgoAttachLaneidCustom* ego_attach_laneid_custom);

  // .sim_msg.ConditionTimeHeadway time_headway = 10;
  bool has_time_headway() const;
  void clear_time_headway();
  const ::sim_msg::ConditionTimeHeadway& time_headway() const;
  ::sim_msg::ConditionTimeHeadway* release_time_headway();
  ::sim_msg::ConditionTimeHeadway* mutable_time_headway();
  void set_allocated_time_headway(::sim_msg::ConditionTimeHeadway* time_headway);

  // .sim_msg.ConditionStoryboardElementState storyboard_element_state = 11;
  bool has_storyboard_element_state() const;
  void clear_storyboard_element_state();
  const ::sim_msg::ConditionStoryboardElementState& storyboard_element_state() const;
  ::sim_msg::ConditionStoryboardElementState* release_storyboard_element_state();
  ::sim_msg::ConditionStoryboardElementState* mutable_storyboard_element_state();
  void set_allocated_storyboard_element_state(::sim_msg::ConditionStoryboardElementState* storyboard_element_state);

  // .sim_msg.ConditionSimulationTime simulation_time = 12;
  bool has_simulation_time() const;
  void clear_simulation_time();
  const ::sim_msg::ConditionSimulationTime& simulation_time() const;
  ::sim_msg::ConditionSimulationTime* release_simulation_time();
  ::sim_msg::ConditionSimulationTime* mutable_simulation_time();
  void set_allocated_simulation_time(::sim_msg::ConditionSimulationTime* simulation_time);

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:sim_msg.Condition)
 private:
  class _Internal;
  void set_has_ttc();
  void set_has_speed();
  void set_has_relative_speed();
  void set_has_reach_position();
  void set_has_relative_distance();
  void set_has_ego_attach_laneid_custom();
  void set_has_time_headway();
  void set_has_storyboard_element_state();
  void set_has_simulation_time();

  inline bool has_type() const;
  inline void clear_has_type();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double delay_;
  int edge_;
  ::PROTOBUF_NAMESPACE_ID::uint32 count_;
  union TypeUnion {
    TypeUnion() {}
    ::sim_msg::ConditionTimeToCollision* ttc_;
    ::sim_msg::ConditionSpeed* speed_;
    ::sim_msg::ConditionRelativeSpeed* relative_speed_;
    ::sim_msg::ConditionReachPosition* reach_position_;
    ::sim_msg::ConditionRelativeDistance* relative_distance_;
    ::sim_msg::ConditionEgoAttachLaneidCustom* ego_attach_laneid_custom_;
    ::sim_msg::ConditionTimeHeadway* time_headway_;
    ::sim_msg::ConditionStoryboardElementState* storyboard_element_state_;
    ::sim_msg::ConditionSimulationTime* simulation_time_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class ActionSpeed :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.ActionSpeed) */ {
 public:
  ActionSpeed();
  virtual ~ActionSpeed();

  ActionSpeed(const ActionSpeed& from);
  ActionSpeed(ActionSpeed&& from) noexcept
    : ActionSpeed() {
    *this = ::std::move(from);
  }

  inline ActionSpeed& operator=(const ActionSpeed& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionSpeed& operator=(ActionSpeed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActionSpeed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionSpeed* internal_default_instance() {
    return reinterpret_cast<const ActionSpeed*>(
               &_ActionSpeed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ActionSpeed& a, ActionSpeed& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionSpeed* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionSpeed* New() const final {
    return CreateMaybeMessage<ActionSpeed>(nullptr);
  }

  ActionSpeed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionSpeed>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActionSpeed& from);
  void MergeFrom(const ActionSpeed& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionSpeed* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.ActionSpeed";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kAngleFieldNumber = 2,
  };
  // double value = 1;
  void clear_value();
  double value() const;
  void set_value(double value);

  // double angle = 2;
  void clear_angle();
  double angle() const;
  void set_angle(double value);

  // @@protoc_insertion_point(class_scope:sim_msg.ActionSpeed)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double value_;
  double angle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class ActionAccel :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.ActionAccel) */ {
 public:
  ActionAccel();
  virtual ~ActionAccel();

  ActionAccel(const ActionAccel& from);
  ActionAccel(ActionAccel&& from) noexcept
    : ActionAccel() {
    *this = ::std::move(from);
  }

  inline ActionAccel& operator=(const ActionAccel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionAccel& operator=(ActionAccel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActionAccel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionAccel* internal_default_instance() {
    return reinterpret_cast<const ActionAccel*>(
               &_ActionAccel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ActionAccel& a, ActionAccel& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionAccel* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionAccel* New() const final {
    return CreateMaybeMessage<ActionAccel>(nullptr);
  }

  ActionAccel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionAccel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActionAccel& from);
  void MergeFrom(const ActionAccel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionAccel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.ActionAccel";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ActionAccel_EndType EndType;
  static constexpr EndType END_TYPE_NONE =
    ActionAccel_EndType_END_TYPE_NONE;
  static constexpr EndType END_TYPE_TIME =
    ActionAccel_EndType_END_TYPE_TIME;
  static constexpr EndType END_TYPE_SPEED =
    ActionAccel_EndType_END_TYPE_SPEED;
  static inline bool EndType_IsValid(int value) {
    return ActionAccel_EndType_IsValid(value);
  }
  static constexpr EndType EndType_MIN =
    ActionAccel_EndType_EndType_MIN;
  static constexpr EndType EndType_MAX =
    ActionAccel_EndType_EndType_MAX;
  static constexpr int EndType_ARRAYSIZE =
    ActionAccel_EndType_EndType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EndType_descriptor() {
    return ActionAccel_EndType_descriptor();
  }
  template<typename T>
  static inline const std::string& EndType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EndType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EndType_Name.");
    return ActionAccel_EndType_Name(enum_t_value);
  }
  static inline bool EndType_Parse(const std::string& name,
      EndType* value) {
    return ActionAccel_EndType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kAngleFieldNumber = 2,
    kEndValueFieldNumber = 4,
    kEndTypeFieldNumber = 3,
  };
  // double value = 1;
  void clear_value();
  double value() const;
  void set_value(double value);

  // double angle = 2;
  void clear_angle();
  double angle() const;
  void set_angle(double value);

  // double end_value = 4;
  void clear_end_value();
  double end_value() const;
  void set_end_value(double value);

  // .sim_msg.ActionAccel.EndType end_type = 3;
  void clear_end_type();
  ::sim_msg::ActionAccel_EndType end_type() const;
  void set_end_type(::sim_msg::ActionAccel_EndType value);

  // @@protoc_insertion_point(class_scope:sim_msg.ActionAccel)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double value_;
  double angle_;
  double end_value_;
  int end_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class ActionLaneChange :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.ActionLaneChange) */ {
 public:
  ActionLaneChange();
  virtual ~ActionLaneChange();

  ActionLaneChange(const ActionLaneChange& from);
  ActionLaneChange(ActionLaneChange&& from) noexcept
    : ActionLaneChange() {
    *this = ::std::move(from);
  }

  inline ActionLaneChange& operator=(const ActionLaneChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionLaneChange& operator=(ActionLaneChange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActionLaneChange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionLaneChange* internal_default_instance() {
    return reinterpret_cast<const ActionLaneChange*>(
               &_ActionLaneChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ActionLaneChange& a, ActionLaneChange& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionLaneChange* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionLaneChange* New() const final {
    return CreateMaybeMessage<ActionLaneChange>(nullptr);
  }

  ActionLaneChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionLaneChange>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActionLaneChange& from);
  void MergeFrom(const ActionLaneChange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionLaneChange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.ActionLaneChange";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ActionLaneChange_Dir Dir;
  static constexpr Dir DIR_LEFT =
    ActionLaneChange_Dir_DIR_LEFT;
  static constexpr Dir DIR_RIGHT =
    ActionLaneChange_Dir_DIR_RIGHT;
  static constexpr Dir DIR_LEFT_IN_LANE =
    ActionLaneChange_Dir_DIR_LEFT_IN_LANE;
  static constexpr Dir DIR_RIGHT_IN_LANE =
    ActionLaneChange_Dir_DIR_RIGHT_IN_LANE;
  static inline bool Dir_IsValid(int value) {
    return ActionLaneChange_Dir_IsValid(value);
  }
  static constexpr Dir Dir_MIN =
    ActionLaneChange_Dir_Dir_MIN;
  static constexpr Dir Dir_MAX =
    ActionLaneChange_Dir_Dir_MAX;
  static constexpr int Dir_ARRAYSIZE =
    ActionLaneChange_Dir_Dir_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Dir_descriptor() {
    return ActionLaneChange_Dir_descriptor();
  }
  template<typename T>
  static inline const std::string& Dir_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Dir>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Dir_Name.");
    return ActionLaneChange_Dir_Name(enum_t_value);
  }
  static inline bool Dir_Parse(const std::string& name,
      Dir* value) {
    return ActionLaneChange_Dir_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDurationFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kDirFieldNumber = 1,
  };
  // double duration = 2;
  void clear_duration();
  double duration() const;
  void set_duration(double value);

  // double offset = 3;
  void clear_offset();
  double offset() const;
  void set_offset(double value);

  // .sim_msg.ActionLaneChange.Dir dir = 1;
  void clear_dir();
  ::sim_msg::ActionLaneChange_Dir dir() const;
  void set_dir(::sim_msg::ActionLaneChange_Dir value);

  // @@protoc_insertion_point(class_scope:sim_msg.ActionLaneChange)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double duration_;
  double offset_;
  int dir_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class ActionLateralDistance :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.ActionLateralDistance) */ {
 public:
  ActionLateralDistance();
  virtual ~ActionLateralDistance();

  ActionLateralDistance(const ActionLateralDistance& from);
  ActionLateralDistance(ActionLateralDistance&& from) noexcept
    : ActionLateralDistance() {
    *this = ::std::move(from);
  }

  inline ActionLateralDistance& operator=(const ActionLateralDistance& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionLateralDistance& operator=(ActionLateralDistance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActionLateralDistance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActionLateralDistance* internal_default_instance() {
    return reinterpret_cast<const ActionLateralDistance*>(
               &_ActionLateralDistance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ActionLateralDistance& a, ActionLateralDistance& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionLateralDistance* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActionLateralDistance* New() const final {
    return CreateMaybeMessage<ActionLateralDistance>(nullptr);
  }

  ActionLateralDistance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActionLateralDistance>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActionLateralDistance& from);
  void MergeFrom(const ActionLateralDistance& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionLateralDistance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.ActionLateralDistance";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDynamicConstraintsFieldNumber = 4,
    kDistanceFieldNumber = 1,
    kFreespaceFieldNumber = 2,
    kContinuousFieldNumber = 3,
  };
  // .sim_msg.DynamicConstraints dynamic_constraints = 4;
  bool has_dynamic_constraints() const;
  void clear_dynamic_constraints();
  const ::sim_msg::DynamicConstraints& dynamic_constraints() const;
  ::sim_msg::DynamicConstraints* release_dynamic_constraints();
  ::sim_msg::DynamicConstraints* mutable_dynamic_constraints();
  void set_allocated_dynamic_constraints(::sim_msg::DynamicConstraints* dynamic_constraints);

  // double distance = 1;
  void clear_distance();
  double distance() const;
  void set_distance(double value);

  // bool freespace = 2;
  void clear_freespace();
  bool freespace() const;
  void set_freespace(bool value);

  // bool continuous = 3;
  void clear_continuous();
  bool continuous() const;
  void set_continuous(bool value);

  // @@protoc_insertion_point(class_scope:sim_msg.ActionLateralDistance)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::sim_msg::DynamicConstraints* dynamic_constraints_;
  double distance_;
  bool freespace_;
  bool continuous_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class Trigger :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Trigger) */ {
 public:
  Trigger();
  virtual ~Trigger();

  Trigger(const Trigger& from);
  Trigger(Trigger&& from) noexcept
    : Trigger() {
    *this = ::std::move(from);
  }

  inline Trigger& operator=(const Trigger& from) {
    CopyFrom(from);
    return *this;
  }
  inline Trigger& operator=(Trigger&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Trigger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Trigger* internal_default_instance() {
    return reinterpret_cast<const Trigger*>(
               &_Trigger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Trigger& a, Trigger& b) {
    a.Swap(&b);
  }
  inline void Swap(Trigger* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Trigger* New() const final {
    return CreateMaybeMessage<Trigger>(nullptr);
  }

  Trigger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Trigger>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Trigger& from);
  void MergeFrom(const Trigger& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trigger* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Trigger";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConditionsFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .sim_msg.Condition conditions = 2;
  int conditions_size() const;
  void clear_conditions();
  ::sim_msg::Condition* mutable_conditions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Condition >*
      mutable_conditions();
  const ::sim_msg::Condition& conditions(int index) const;
  ::sim_msg::Condition* add_conditions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Condition >&
      conditions() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // @@protoc_insertion_point(class_scope:sim_msg.Trigger)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Condition > conditions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class Action :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Action) */ {
 public:
  Action();
  virtual ~Action();

  Action(const Action& from);
  Action(Action&& from) noexcept
    : Action() {
    *this = ::std::move(from);
  }

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  inline Action& operator=(Action&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Action& default_instance();

  enum ActionCase {
    kSpeed = 2,
    kAccel = 3,
    kLaneChange = 4,
    kLateralDistance = 5,
    kStatus = 6,
    kActivate = 7,
    kAssign = 8,
    kOverride = 9,
    kCommand = 10,
    ACTION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Action* internal_default_instance() {
    return reinterpret_cast<const Action*>(
               &_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Action& a, Action& b) {
    a.Swap(&b);
  }
  inline void Swap(Action* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Action* New() const final {
    return CreateMaybeMessage<Action>(nullptr);
  }

  Action* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Action>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Action& from);
  void MergeFrom(const Action& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Action* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Action";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityRefFieldNumber = 1,
    kSpeedFieldNumber = 2,
    kAccelFieldNumber = 3,
    kLaneChangeFieldNumber = 4,
    kLateralDistanceFieldNumber = 5,
    kStatusFieldNumber = 6,
    kActivateFieldNumber = 7,
    kAssignFieldNumber = 8,
    kOverrideFieldNumber = 9,
    kCommandFieldNumber = 10,
  };
  // string entity_ref = 1;
  void clear_entity_ref();
  const std::string& entity_ref() const;
  void set_entity_ref(const std::string& value);
  void set_entity_ref(std::string&& value);
  void set_entity_ref(const char* value);
  void set_entity_ref(const char* value, size_t size);
  std::string* mutable_entity_ref();
  std::string* release_entity_ref();
  void set_allocated_entity_ref(std::string* entity_ref);

  // .sim_msg.ActionSpeed speed = 2;
  bool has_speed() const;
  void clear_speed();
  const ::sim_msg::ActionSpeed& speed() const;
  ::sim_msg::ActionSpeed* release_speed();
  ::sim_msg::ActionSpeed* mutable_speed();
  void set_allocated_speed(::sim_msg::ActionSpeed* speed);

  // .sim_msg.ActionAccel accel = 3;
  bool has_accel() const;
  void clear_accel();
  const ::sim_msg::ActionAccel& accel() const;
  ::sim_msg::ActionAccel* release_accel();
  ::sim_msg::ActionAccel* mutable_accel();
  void set_allocated_accel(::sim_msg::ActionAccel* accel);

  // .sim_msg.ActionLaneChange lane_change = 4;
  bool has_lane_change() const;
  void clear_lane_change();
  const ::sim_msg::ActionLaneChange& lane_change() const;
  ::sim_msg::ActionLaneChange* release_lane_change();
  ::sim_msg::ActionLaneChange* mutable_lane_change();
  void set_allocated_lane_change(::sim_msg::ActionLaneChange* lane_change);

  // .sim_msg.ActionLateralDistance lateral_distance = 5;
  bool has_lateral_distance() const;
  void clear_lateral_distance();
  const ::sim_msg::ActionLateralDistance& lateral_distance() const;
  ::sim_msg::ActionLateralDistance* release_lateral_distance();
  ::sim_msg::ActionLateralDistance* mutable_lateral_distance();
  void set_allocated_lateral_distance(::sim_msg::ActionLateralDistance* lateral_distance);

  // .sim_msg.Status status = 6;
  bool has_status() const;
  void clear_status();
  const ::sim_msg::Status& status() const;
  ::sim_msg::Status* release_status();
  ::sim_msg::Status* mutable_status();
  void set_allocated_status(::sim_msg::Status* status);

  // .sim_msg.Activate activate = 7;
  bool has_activate() const;
  void clear_activate();
  const ::sim_msg::Activate& activate() const;
  ::sim_msg::Activate* release_activate();
  ::sim_msg::Activate* mutable_activate();
  void set_allocated_activate(::sim_msg::Activate* activate);

  // .sim_msg.Assign assign = 8;
  bool has_assign() const;
  void clear_assign();
  const ::sim_msg::Assign& assign() const;
  ::sim_msg::Assign* release_assign();
  ::sim_msg::Assign* mutable_assign();
  void set_allocated_assign(::sim_msg::Assign* assign);

  // .sim_msg.Override override = 9;
  bool has_override() const;
  void clear_override();
  const ::sim_msg::Override& override() const;
  ::sim_msg::Override* release_override();
  ::sim_msg::Override* mutable_override();
  void set_allocated_override(::sim_msg::Override* override);

  // .sim_msg.Command command = 10;
  bool has_command() const;
  void clear_command();
  const ::sim_msg::Command& command() const;
  ::sim_msg::Command* release_command();
  ::sim_msg::Command* mutable_command();
  void set_allocated_command(::sim_msg::Command* command);

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:sim_msg.Action)
 private:
  class _Internal;
  void set_has_speed();
  void set_has_accel();
  void set_has_lane_change();
  void set_has_lateral_distance();
  void set_has_status();
  void set_has_activate();
  void set_has_assign();
  void set_has_override();
  void set_has_command();

  inline bool has_action() const;
  inline void clear_has_action();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entity_ref_;
  union ActionUnion {
    ActionUnion() {}
    ::sim_msg::ActionSpeed* speed_;
    ::sim_msg::ActionAccel* accel_;
    ::sim_msg::ActionLaneChange* lane_change_;
    ::sim_msg::ActionLateralDistance* lateral_distance_;
    ::sim_msg::Status* status_;
    ::sim_msg::Activate* activate_;
    ::sim_msg::Assign* assign_;
    ::sim_msg::Override* override_;
    ::sim_msg::Command* command_;
  } action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class Event :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Event& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return CreateMaybeMessage<Event>(nullptr);
  }

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Event";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionsFieldNumber = 4,
    kNameFieldNumber = 2,
    kInfoFieldNumber = 5,
    kTriggerFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // repeated .sim_msg.Action actions = 4;
  int actions_size() const;
  void clear_actions();
  ::sim_msg::Action* mutable_actions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Action >*
      mutable_actions();
  const ::sim_msg::Action& actions(int index) const;
  ::sim_msg::Action* add_actions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Action >&
      actions() const;

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string info = 5;
  void clear_info();
  const std::string& info() const;
  void set_info(const std::string& value);
  void set_info(std::string&& value);
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  std::string* mutable_info();
  std::string* release_info();
  void set_allocated_info(std::string* info);

  // .sim_msg.Trigger trigger = 3;
  bool has_trigger() const;
  void clear_trigger();
  const ::sim_msg::Trigger& trigger() const;
  ::sim_msg::Trigger* release_trigger();
  ::sim_msg::Trigger* mutable_trigger();
  void set_allocated_trigger(::sim_msg::Trigger* trigger);

  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:sim_msg.Event)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Action > actions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
  ::sim_msg::Trigger* trigger_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class PhysicleCommon :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.PhysicleCommon) */ {
 public:
  PhysicleCommon();
  virtual ~PhysicleCommon();

  PhysicleCommon(const PhysicleCommon& from);
  PhysicleCommon(PhysicleCommon&& from) noexcept
    : PhysicleCommon() {
    *this = ::std::move(from);
  }

  inline PhysicleCommon& operator=(const PhysicleCommon& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhysicleCommon& operator=(PhysicleCommon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PhysicleCommon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PhysicleCommon* internal_default_instance() {
    return reinterpret_cast<const PhysicleCommon*>(
               &_PhysicleCommon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(PhysicleCommon& a, PhysicleCommon& b) {
    a.Swap(&b);
  }
  inline void Swap(PhysicleCommon* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PhysicleCommon* New() const final {
    return CreateMaybeMessage<PhysicleCommon>(nullptr);
  }

  PhysicleCommon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PhysicleCommon>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PhysicleCommon& from);
  void MergeFrom(const PhysicleCommon& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhysicleCommon* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.PhysicleCommon";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModel3DFieldNumber = 5,
    kBoundingBoxFieldNumber = 1,
    kMassFieldNumber = 3,
    kModelIdFieldNumber = 4,
    kColorFieldNumber = 2,
  };
  // string model_3d = 5;
  void clear_model_3d();
  const std::string& model_3d() const;
  void set_model_3d(const std::string& value);
  void set_model_3d(std::string&& value);
  void set_model_3d(const char* value);
  void set_model_3d(const char* value, size_t size);
  std::string* mutable_model_3d();
  std::string* release_model_3d();
  void set_allocated_model_3d(std::string* model_3d);

  // .sim_msg.BoundingBox bounding_box = 1;
  bool has_bounding_box() const;
  void clear_bounding_box();
  const ::sim_msg::BoundingBox& bounding_box() const;
  ::sim_msg::BoundingBox* release_bounding_box();
  ::sim_msg::BoundingBox* mutable_bounding_box();
  void set_allocated_bounding_box(::sim_msg::BoundingBox* bounding_box);

  // double mass = 3;
  void clear_mass();
  double mass() const;
  void set_mass(double value);

  // int64 model_id = 4;
  void clear_model_id();
  ::PROTOBUF_NAMESPACE_ID::int64 model_id() const;
  void set_model_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // .sim_msg.Color color = 2;
  void clear_color();
  ::sim_msg::Color color() const;
  void set_color(::sim_msg::Color value);

  // @@protoc_insertion_point(class_scope:sim_msg.PhysicleCommon)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_3d_;
  ::sim_msg::BoundingBox* bounding_box_;
  double mass_;
  ::PROTOBUF_NAMESPACE_ID::int64 model_id_;
  int color_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class PhysicleEgo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.PhysicleEgo) */ {
 public:
  PhysicleEgo();
  virtual ~PhysicleEgo();

  PhysicleEgo(const PhysicleEgo& from);
  PhysicleEgo(PhysicleEgo&& from) noexcept
    : PhysicleEgo() {
    *this = ::std::move(from);
  }

  inline PhysicleEgo& operator=(const PhysicleEgo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhysicleEgo& operator=(PhysicleEgo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PhysicleEgo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PhysicleEgo* internal_default_instance() {
    return reinterpret_cast<const PhysicleEgo*>(
               &_PhysicleEgo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(PhysicleEgo& a, PhysicleEgo& b) {
    a.Swap(&b);
  }
  inline void Swap(PhysicleEgo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PhysicleEgo* New() const final {
    return CreateMaybeMessage<PhysicleEgo>(nullptr);
  }

  PhysicleEgo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PhysicleEgo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PhysicleEgo& from);
  void MergeFrom(const PhysicleEgo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhysicleEgo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.PhysicleEgo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonFieldNumber = 1,
    kPerformanceFieldNumber = 2,
    kGeometoryFieldNumber = 3,
  };
  // .sim_msg.PhysicleCommon common = 1;
  bool has_common() const;
  void clear_common();
  const ::sim_msg::PhysicleCommon& common() const;
  ::sim_msg::PhysicleCommon* release_common();
  ::sim_msg::PhysicleCommon* mutable_common();
  void set_allocated_common(::sim_msg::PhysicleCommon* common);

  // .sim_msg.Performance performance = 2;
  bool has_performance() const;
  void clear_performance();
  const ::sim_msg::Performance& performance() const;
  ::sim_msg::Performance* release_performance();
  ::sim_msg::Performance* mutable_performance();
  void set_allocated_performance(::sim_msg::Performance* performance);

  // .sim_msg.VehicleGeometory geometory = 3;
  bool has_geometory() const;
  void clear_geometory();
  const ::sim_msg::VehicleGeometory& geometory() const;
  ::sim_msg::VehicleGeometory* release_geometory();
  ::sim_msg::VehicleGeometory* mutable_geometory();
  void set_allocated_geometory(::sim_msg::VehicleGeometory* geometory);

  // @@protoc_insertion_point(class_scope:sim_msg.PhysicleEgo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::sim_msg::PhysicleCommon* common_;
  ::sim_msg::Performance* performance_;
  ::sim_msg::VehicleGeometory* geometory_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class PhysicleVehicle :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.PhysicleVehicle) */ {
 public:
  PhysicleVehicle();
  virtual ~PhysicleVehicle();

  PhysicleVehicle(const PhysicleVehicle& from);
  PhysicleVehicle(PhysicleVehicle&& from) noexcept
    : PhysicleVehicle() {
    *this = ::std::move(from);
  }

  inline PhysicleVehicle& operator=(const PhysicleVehicle& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhysicleVehicle& operator=(PhysicleVehicle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PhysicleVehicle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PhysicleVehicle* internal_default_instance() {
    return reinterpret_cast<const PhysicleVehicle*>(
               &_PhysicleVehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(PhysicleVehicle& a, PhysicleVehicle& b) {
    a.Swap(&b);
  }
  inline void Swap(PhysicleVehicle* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PhysicleVehicle* New() const final {
    return CreateMaybeMessage<PhysicleVehicle>(nullptr);
  }

  PhysicleVehicle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PhysicleVehicle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PhysicleVehicle& from);
  void MergeFrom(const PhysicleVehicle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhysicleVehicle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.PhysicleVehicle";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonFieldNumber = 1,
    kPerformanceFieldNumber = 2,
    kGeometoryFieldNumber = 3,
  };
  // .sim_msg.PhysicleCommon common = 1;
  bool has_common() const;
  void clear_common();
  const ::sim_msg::PhysicleCommon& common() const;
  ::sim_msg::PhysicleCommon* release_common();
  ::sim_msg::PhysicleCommon* mutable_common();
  void set_allocated_common(::sim_msg::PhysicleCommon* common);

  // .sim_msg.Performance performance = 2;
  bool has_performance() const;
  void clear_performance();
  const ::sim_msg::Performance& performance() const;
  ::sim_msg::Performance* release_performance();
  ::sim_msg::Performance* mutable_performance();
  void set_allocated_performance(::sim_msg::Performance* performance);

  // .sim_msg.VehicleGeometory geometory = 3;
  bool has_geometory() const;
  void clear_geometory();
  const ::sim_msg::VehicleGeometory& geometory() const;
  ::sim_msg::VehicleGeometory* release_geometory();
  ::sim_msg::VehicleGeometory* mutable_geometory();
  void set_allocated_geometory(::sim_msg::VehicleGeometory* geometory);

  // @@protoc_insertion_point(class_scope:sim_msg.PhysicleVehicle)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::sim_msg::PhysicleCommon* common_;
  ::sim_msg::Performance* performance_;
  ::sim_msg::VehicleGeometory* geometory_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class PhysicleVru :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.PhysicleVru) */ {
 public:
  PhysicleVru();
  virtual ~PhysicleVru();

  PhysicleVru(const PhysicleVru& from);
  PhysicleVru(PhysicleVru&& from) noexcept
    : PhysicleVru() {
    *this = ::std::move(from);
  }

  inline PhysicleVru& operator=(const PhysicleVru& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhysicleVru& operator=(PhysicleVru&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PhysicleVru& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PhysicleVru* internal_default_instance() {
    return reinterpret_cast<const PhysicleVru*>(
               &_PhysicleVru_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(PhysicleVru& a, PhysicleVru& b) {
    a.Swap(&b);
  }
  inline void Swap(PhysicleVru* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PhysicleVru* New() const final {
    return CreateMaybeMessage<PhysicleVru>(nullptr);
  }

  PhysicleVru* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PhysicleVru>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PhysicleVru& from);
  void MergeFrom(const PhysicleVru& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhysicleVru* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.PhysicleVru";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonFieldNumber = 1,
    kPerformanceFieldNumber = 2,
  };
  // .sim_msg.PhysicleCommon common = 1;
  bool has_common() const;
  void clear_common();
  const ::sim_msg::PhysicleCommon& common() const;
  ::sim_msg::PhysicleCommon* release_common();
  ::sim_msg::PhysicleCommon* mutable_common();
  void set_allocated_common(::sim_msg::PhysicleCommon* common);

  // .sim_msg.Performance performance = 2;
  bool has_performance() const;
  void clear_performance();
  const ::sim_msg::Performance& performance() const;
  ::sim_msg::Performance* release_performance();
  ::sim_msg::Performance* mutable_performance();
  void set_allocated_performance(::sim_msg::Performance* performance);

  // @@protoc_insertion_point(class_scope:sim_msg.PhysicleVru)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::sim_msg::PhysicleCommon* common_;
  ::sim_msg::Performance* performance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class InitialCommon :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.InitialCommon) */ {
 public:
  InitialCommon();
  virtual ~InitialCommon();

  InitialCommon(const InitialCommon& from);
  InitialCommon(InitialCommon&& from) noexcept
    : InitialCommon() {
    *this = ::std::move(from);
  }

  inline InitialCommon& operator=(const InitialCommon& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitialCommon& operator=(InitialCommon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InitialCommon& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitialCommon* internal_default_instance() {
    return reinterpret_cast<const InitialCommon*>(
               &_InitialCommon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(InitialCommon& a, InitialCommon& b) {
    a.Swap(&b);
  }
  inline void Swap(InitialCommon* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InitialCommon* New() const final {
    return CreateMaybeMessage<InitialCommon>(nullptr);
  }

  InitialCommon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InitialCommon>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InitialCommon& from);
  void MergeFrom(const InitialCommon& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitialCommon* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.InitialCommon";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWaypointsFieldNumber = 1,
    kSpeedFieldNumber = 2,
  };
  // repeated .sim_msg.Waypoint waypoints = 1;
  int waypoints_size() const;
  void clear_waypoints();
  ::sim_msg::Waypoint* mutable_waypoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Waypoint >*
      mutable_waypoints();
  const ::sim_msg::Waypoint& waypoints(int index) const;
  ::sim_msg::Waypoint* add_waypoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Waypoint >&
      waypoints() const;

  // double speed = 2;
  void clear_speed();
  double speed() const;
  void set_speed(double value);

  // @@protoc_insertion_point(class_scope:sim_msg.InitialCommon)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Waypoint > waypoints_;
  double speed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class InitialEgo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.InitialEgo) */ {
 public:
  InitialEgo();
  virtual ~InitialEgo();

  InitialEgo(const InitialEgo& from);
  InitialEgo(InitialEgo&& from) noexcept
    : InitialEgo() {
    *this = ::std::move(from);
  }

  inline InitialEgo& operator=(const InitialEgo& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitialEgo& operator=(InitialEgo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InitialEgo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitialEgo* internal_default_instance() {
    return reinterpret_cast<const InitialEgo*>(
               &_InitialEgo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(InitialEgo& a, InitialEgo& b) {
    a.Swap(&b);
  }
  inline void Swap(InitialEgo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InitialEgo* New() const final {
    return CreateMaybeMessage<InitialEgo>(nullptr);
  }

  InitialEgo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InitialEgo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InitialEgo& from);
  void MergeFrom(const InitialEgo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitialEgo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.InitialEgo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonFieldNumber = 1,
    kAssignFieldNumber = 3,
    kActivateFieldNumber = 4,
    kTrajectoryEnabledFieldNumber = 5,
  };
  // .sim_msg.InitialCommon common = 1;
  bool has_common() const;
  void clear_common();
  const ::sim_msg::InitialCommon& common() const;
  ::sim_msg::InitialCommon* release_common();
  ::sim_msg::InitialCommon* mutable_common();
  void set_allocated_common(::sim_msg::InitialCommon* common);

  // .sim_msg.Assign assign = 3;
  bool has_assign() const;
  void clear_assign();
  const ::sim_msg::Assign& assign() const;
  ::sim_msg::Assign* release_assign();
  ::sim_msg::Assign* mutable_assign();
  void set_allocated_assign(::sim_msg::Assign* assign);

  // .sim_msg.Activate activate = 4;
  bool has_activate() const;
  void clear_activate();
  const ::sim_msg::Activate& activate() const;
  ::sim_msg::Activate* release_activate();
  ::sim_msg::Activate* mutable_activate();
  void set_allocated_activate(::sim_msg::Activate* activate);

  // bool trajectory_enabled = 5;
  void clear_trajectory_enabled();
  bool trajectory_enabled() const;
  void set_trajectory_enabled(bool value);

  // @@protoc_insertion_point(class_scope:sim_msg.InitialEgo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::sim_msg::InitialCommon* common_;
  ::sim_msg::Assign* assign_;
  ::sim_msg::Activate* activate_;
  bool trajectory_enabled_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class InitialVehicle :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.InitialVehicle) */ {
 public:
  InitialVehicle();
  virtual ~InitialVehicle();

  InitialVehicle(const InitialVehicle& from);
  InitialVehicle(InitialVehicle&& from) noexcept
    : InitialVehicle() {
    *this = ::std::move(from);
  }

  inline InitialVehicle& operator=(const InitialVehicle& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitialVehicle& operator=(InitialVehicle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InitialVehicle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitialVehicle* internal_default_instance() {
    return reinterpret_cast<const InitialVehicle*>(
               &_InitialVehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(InitialVehicle& a, InitialVehicle& b) {
    a.Swap(&b);
  }
  inline void Swap(InitialVehicle* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InitialVehicle* New() const final {
    return CreateMaybeMessage<InitialVehicle>(nullptr);
  }

  InitialVehicle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InitialVehicle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InitialVehicle& from);
  void MergeFrom(const InitialVehicle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitialVehicle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.InitialVehicle";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonFieldNumber = 1,
    kAggressFieldNumber = 3,
    kBehaviorTypeFieldNumber = 2,
  };
  // .sim_msg.InitialCommon common = 1;
  bool has_common() const;
  void clear_common();
  const ::sim_msg::InitialCommon& common() const;
  ::sim_msg::InitialCommon* release_common();
  ::sim_msg::InitialCommon* mutable_common();
  void set_allocated_common(::sim_msg::InitialCommon* common);

  // double aggress = 3;
  void clear_aggress();
  double aggress() const;
  void set_aggress(double value);

  // .sim_msg.BehaviorType behavior_type = 2;
  void clear_behavior_type();
  ::sim_msg::BehaviorType behavior_type() const;
  void set_behavior_type(::sim_msg::BehaviorType value);

  // @@protoc_insertion_point(class_scope:sim_msg.InitialVehicle)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::sim_msg::InitialCommon* common_;
  double aggress_;
  int behavior_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class InitialVru :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.InitialVru) */ {
 public:
  InitialVru();
  virtual ~InitialVru();

  InitialVru(const InitialVru& from);
  InitialVru(InitialVru&& from) noexcept
    : InitialVru() {
    *this = ::std::move(from);
  }

  inline InitialVru& operator=(const InitialVru& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitialVru& operator=(InitialVru&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InitialVru& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitialVru* internal_default_instance() {
    return reinterpret_cast<const InitialVru*>(
               &_InitialVru_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(InitialVru& a, InitialVru& b) {
    a.Swap(&b);
  }
  inline void Swap(InitialVru* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InitialVru* New() const final {
    return CreateMaybeMessage<InitialVru>(nullptr);
  }

  InitialVru* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InitialVru>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InitialVru& from);
  void MergeFrom(const InitialVru& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitialVru* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.InitialVru";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonFieldNumber = 1,
    kAggressFieldNumber = 3,
    kBehaviorTypeFieldNumber = 2,
  };
  // .sim_msg.InitialCommon common = 1;
  bool has_common() const;
  void clear_common();
  const ::sim_msg::InitialCommon& common() const;
  ::sim_msg::InitialCommon* release_common();
  ::sim_msg::InitialCommon* mutable_common();
  void set_allocated_common(::sim_msg::InitialCommon* common);

  // double aggress = 3;
  void clear_aggress();
  double aggress() const;
  void set_aggress(double value);

  // .sim_msg.BehaviorType behavior_type = 2;
  void clear_behavior_type();
  ::sim_msg::BehaviorType behavior_type() const;
  void set_behavior_type(::sim_msg::BehaviorType value);

  // @@protoc_insertion_point(class_scope:sim_msg.InitialVru)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::sim_msg::InitialCommon* common_;
  double aggress_;
  int behavior_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class Dynamic :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Dynamic) */ {
 public:
  Dynamic();
  virtual ~Dynamic();

  Dynamic(const Dynamic& from);
  Dynamic(Dynamic&& from) noexcept
    : Dynamic() {
    *this = ::std::move(from);
  }

  inline Dynamic& operator=(const Dynamic& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dynamic& operator=(Dynamic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Dynamic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Dynamic* internal_default_instance() {
    return reinterpret_cast<const Dynamic*>(
               &_Dynamic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Dynamic& a, Dynamic& b) {
    a.Swap(&b);
  }
  inline void Swap(Dynamic* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Dynamic* New() const final {
    return CreateMaybeMessage<Dynamic>(nullptr);
  }

  Dynamic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Dynamic>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Dynamic& from);
  void MergeFrom(const Dynamic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dynamic* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Dynamic";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 1,
  };
  // repeated .sim_msg.Event events = 1;
  int events_size() const;
  void clear_events();
  ::sim_msg::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Event >*
      mutable_events();
  const ::sim_msg::Event& events(int index) const;
  ::sim_msg::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Event >&
      events() const;

  // @@protoc_insertion_point(class_scope:sim_msg.Dynamic)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Event > events_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class Ego :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Ego) */ {
 public:
  Ego();
  virtual ~Ego();

  Ego(const Ego& from);
  Ego(Ego&& from) noexcept
    : Ego() {
    *this = ::std::move(from);
  }

  inline Ego& operator=(const Ego& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ego& operator=(Ego&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Ego& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ego* internal_default_instance() {
    return reinterpret_cast<const Ego*>(
               &_Ego_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(Ego& a, Ego& b) {
    a.Swap(&b);
  }
  inline void Swap(Ego* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Ego* New() const final {
    return CreateMaybeMessage<Ego>(nullptr);
  }

  Ego* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Ego>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Ego& from);
  void MergeFrom(const Ego& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ego* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Ego";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhysiclesFieldNumber = 5,
    kNameFieldNumber = 2,
    kObjectnameFieldNumber = 3,
    kGroupFieldNumber = 9,
    kInitialFieldNumber = 6,
    kDynamicFieldNumber = 7,
    kSensorGroupFieldNumber = 8,
    kIdFieldNumber = 1,
    kCategoryFieldNumber = 4,
  };
  // repeated .sim_msg.PhysicleEgo physicles = 5;
  int physicles_size() const;
  void clear_physicles();
  ::sim_msg::PhysicleEgo* mutable_physicles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::PhysicleEgo >*
      mutable_physicles();
  const ::sim_msg::PhysicleEgo& physicles(int index) const;
  ::sim_msg::PhysicleEgo* add_physicles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::PhysicleEgo >&
      physicles() const;

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string objectname = 3;
  void clear_objectname();
  const std::string& objectname() const;
  void set_objectname(const std::string& value);
  void set_objectname(std::string&& value);
  void set_objectname(const char* value);
  void set_objectname(const char* value, size_t size);
  std::string* mutable_objectname();
  std::string* release_objectname();
  void set_allocated_objectname(std::string* objectname);

  // string group = 9;
  void clear_group();
  const std::string& group() const;
  void set_group(const std::string& value);
  void set_group(std::string&& value);
  void set_group(const char* value);
  void set_group(const char* value, size_t size);
  std::string* mutable_group();
  std::string* release_group();
  void set_allocated_group(std::string* group);

  // .sim_msg.InitialEgo initial = 6;
  bool has_initial() const;
  void clear_initial();
  const ::sim_msg::InitialEgo& initial() const;
  ::sim_msg::InitialEgo* release_initial();
  ::sim_msg::InitialEgo* mutable_initial();
  void set_allocated_initial(::sim_msg::InitialEgo* initial);

  // .sim_msg.Dynamic dynamic = 7;
  bool has_dynamic() const;
  void clear_dynamic();
  const ::sim_msg::Dynamic& dynamic() const;
  ::sim_msg::Dynamic* release_dynamic();
  ::sim_msg::Dynamic* mutable_dynamic();
  void set_allocated_dynamic(::sim_msg::Dynamic* dynamic);

  // .sim_msg.SensorGroup sensor_group = 8;
  bool has_sensor_group() const;
  void clear_sensor_group();
  const ::sim_msg::SensorGroup& sensor_group() const;
  ::sim_msg::SensorGroup* release_sensor_group();
  ::sim_msg::SensorGroup* mutable_sensor_group();
  void set_allocated_sensor_group(::sim_msg::SensorGroup* sensor_group);

  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // .sim_msg.CategoryVehicle category = 4;
  void clear_category();
  ::sim_msg::CategoryVehicle category() const;
  void set_category(::sim_msg::CategoryVehicle value);

  // @@protoc_insertion_point(class_scope:sim_msg.Ego)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::PhysicleEgo > physicles_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr objectname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
  ::sim_msg::InitialEgo* initial_;
  ::sim_msg::Dynamic* dynamic_;
  ::sim_msg::SensorGroup* sensor_group_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  int category_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class Vehicle :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Vehicle) */ {
 public:
  Vehicle();
  virtual ~Vehicle();

  Vehicle(const Vehicle& from);
  Vehicle(Vehicle&& from) noexcept
    : Vehicle() {
    *this = ::std::move(from);
  }

  inline Vehicle& operator=(const Vehicle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vehicle& operator=(Vehicle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vehicle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vehicle* internal_default_instance() {
    return reinterpret_cast<const Vehicle*>(
               &_Vehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(Vehicle& a, Vehicle& b) {
    a.Swap(&b);
  }
  inline void Swap(Vehicle* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vehicle* New() const final {
    return CreateMaybeMessage<Vehicle>(nullptr);
  }

  Vehicle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vehicle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vehicle& from);
  void MergeFrom(const Vehicle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vehicle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Vehicle";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kObjectnameFieldNumber = 3,
    kGroupFieldNumber = 9,
    kPhysicleFieldNumber = 5,
    kInitialFieldNumber = 6,
    kDynamicFieldNumber = 7,
    kSensorGroupFieldNumber = 8,
    kIdFieldNumber = 1,
    kCategoryFieldNumber = 4,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string objectname = 3;
  void clear_objectname();
  const std::string& objectname() const;
  void set_objectname(const std::string& value);
  void set_objectname(std::string&& value);
  void set_objectname(const char* value);
  void set_objectname(const char* value, size_t size);
  std::string* mutable_objectname();
  std::string* release_objectname();
  void set_allocated_objectname(std::string* objectname);

  // string group = 9;
  void clear_group();
  const std::string& group() const;
  void set_group(const std::string& value);
  void set_group(std::string&& value);
  void set_group(const char* value);
  void set_group(const char* value, size_t size);
  std::string* mutable_group();
  std::string* release_group();
  void set_allocated_group(std::string* group);

  // .sim_msg.PhysicleVehicle physicle = 5;
  bool has_physicle() const;
  void clear_physicle();
  const ::sim_msg::PhysicleVehicle& physicle() const;
  ::sim_msg::PhysicleVehicle* release_physicle();
  ::sim_msg::PhysicleVehicle* mutable_physicle();
  void set_allocated_physicle(::sim_msg::PhysicleVehicle* physicle);

  // .sim_msg.InitialVehicle initial = 6;
  bool has_initial() const;
  void clear_initial();
  const ::sim_msg::InitialVehicle& initial() const;
  ::sim_msg::InitialVehicle* release_initial();
  ::sim_msg::InitialVehicle* mutable_initial();
  void set_allocated_initial(::sim_msg::InitialVehicle* initial);

  // .sim_msg.Dynamic dynamic = 7;
  bool has_dynamic() const;
  void clear_dynamic();
  const ::sim_msg::Dynamic& dynamic() const;
  ::sim_msg::Dynamic* release_dynamic();
  ::sim_msg::Dynamic* mutable_dynamic();
  void set_allocated_dynamic(::sim_msg::Dynamic* dynamic);

  // .sim_msg.SensorGroup sensor_group = 8;
  bool has_sensor_group() const;
  void clear_sensor_group();
  const ::sim_msg::SensorGroup& sensor_group() const;
  ::sim_msg::SensorGroup* release_sensor_group();
  ::sim_msg::SensorGroup* mutable_sensor_group();
  void set_allocated_sensor_group(::sim_msg::SensorGroup* sensor_group);

  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // .sim_msg.CategoryVehicle category = 4;
  void clear_category();
  ::sim_msg::CategoryVehicle category() const;
  void set_category(::sim_msg::CategoryVehicle value);

  // @@protoc_insertion_point(class_scope:sim_msg.Vehicle)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr objectname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_;
  ::sim_msg::PhysicleVehicle* physicle_;
  ::sim_msg::InitialVehicle* initial_;
  ::sim_msg::Dynamic* dynamic_;
  ::sim_msg::SensorGroup* sensor_group_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  int category_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class VulnerableRoadUser :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.VulnerableRoadUser) */ {
 public:
  VulnerableRoadUser();
  virtual ~VulnerableRoadUser();

  VulnerableRoadUser(const VulnerableRoadUser& from);
  VulnerableRoadUser(VulnerableRoadUser&& from) noexcept
    : VulnerableRoadUser() {
    *this = ::std::move(from);
  }

  inline VulnerableRoadUser& operator=(const VulnerableRoadUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline VulnerableRoadUser& operator=(VulnerableRoadUser&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VulnerableRoadUser& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VulnerableRoadUser* internal_default_instance() {
    return reinterpret_cast<const VulnerableRoadUser*>(
               &_VulnerableRoadUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(VulnerableRoadUser& a, VulnerableRoadUser& b) {
    a.Swap(&b);
  }
  inline void Swap(VulnerableRoadUser* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VulnerableRoadUser* New() const final {
    return CreateMaybeMessage<VulnerableRoadUser>(nullptr);
  }

  VulnerableRoadUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VulnerableRoadUser>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VulnerableRoadUser& from);
  void MergeFrom(const VulnerableRoadUser& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VulnerableRoadUser* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.VulnerableRoadUser";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kObjectnameFieldNumber = 3,
    kPhysicleFieldNumber = 5,
    kInitialFieldNumber = 6,
    kDynamicFieldNumber = 7,
    kSensorGroupFieldNumber = 8,
    kIdFieldNumber = 1,
    kCategoryFieldNumber = 4,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string objectname = 3;
  void clear_objectname();
  const std::string& objectname() const;
  void set_objectname(const std::string& value);
  void set_objectname(std::string&& value);
  void set_objectname(const char* value);
  void set_objectname(const char* value, size_t size);
  std::string* mutable_objectname();
  std::string* release_objectname();
  void set_allocated_objectname(std::string* objectname);

  // .sim_msg.PhysicleVru physicle = 5;
  bool has_physicle() const;
  void clear_physicle();
  const ::sim_msg::PhysicleVru& physicle() const;
  ::sim_msg::PhysicleVru* release_physicle();
  ::sim_msg::PhysicleVru* mutable_physicle();
  void set_allocated_physicle(::sim_msg::PhysicleVru* physicle);

  // .sim_msg.InitialVru initial = 6;
  bool has_initial() const;
  void clear_initial();
  const ::sim_msg::InitialVru& initial() const;
  ::sim_msg::InitialVru* release_initial();
  ::sim_msg::InitialVru* mutable_initial();
  void set_allocated_initial(::sim_msg::InitialVru* initial);

  // .sim_msg.Dynamic dynamic = 7;
  bool has_dynamic() const;
  void clear_dynamic();
  const ::sim_msg::Dynamic& dynamic() const;
  ::sim_msg::Dynamic* release_dynamic();
  ::sim_msg::Dynamic* mutable_dynamic();
  void set_allocated_dynamic(::sim_msg::Dynamic* dynamic);

  // .sim_msg.SensorGroup sensor_group = 8;
  bool has_sensor_group() const;
  void clear_sensor_group();
  const ::sim_msg::SensorGroup& sensor_group() const;
  ::sim_msg::SensorGroup* release_sensor_group();
  ::sim_msg::SensorGroup* mutable_sensor_group();
  void set_allocated_sensor_group(::sim_msg::SensorGroup* sensor_group);

  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // .sim_msg.CategoryVru category = 4;
  void clear_category();
  ::sim_msg::CategoryVru category() const;
  void set_category(::sim_msg::CategoryVru value);

  // @@protoc_insertion_point(class_scope:sim_msg.VulnerableRoadUser)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr objectname_;
  ::sim_msg::PhysicleVru* physicle_;
  ::sim_msg::InitialVru* initial_;
  ::sim_msg::Dynamic* dynamic_;
  ::sim_msg::SensorGroup* sensor_group_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  int category_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class MiscellaneousObject :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.MiscellaneousObject) */ {
 public:
  MiscellaneousObject();
  virtual ~MiscellaneousObject();

  MiscellaneousObject(const MiscellaneousObject& from);
  MiscellaneousObject(MiscellaneousObject&& from) noexcept
    : MiscellaneousObject() {
    *this = ::std::move(from);
  }

  inline MiscellaneousObject& operator=(const MiscellaneousObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline MiscellaneousObject& operator=(MiscellaneousObject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MiscellaneousObject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MiscellaneousObject* internal_default_instance() {
    return reinterpret_cast<const MiscellaneousObject*>(
               &_MiscellaneousObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(MiscellaneousObject& a, MiscellaneousObject& b) {
    a.Swap(&b);
  }
  inline void Swap(MiscellaneousObject* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MiscellaneousObject* New() const final {
    return CreateMaybeMessage<MiscellaneousObject>(nullptr);
  }

  MiscellaneousObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MiscellaneousObject>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MiscellaneousObject& from);
  void MergeFrom(const MiscellaneousObject& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MiscellaneousObject* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.MiscellaneousObject";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kObjectnameFieldNumber = 3,
    kPhysicleFieldNumber = 5,
    kInitialFieldNumber = 6,
    kDynamicFieldNumber = 7,
    kSensorGroupFieldNumber = 8,
    kIdFieldNumber = 1,
    kCategoryFieldNumber = 4,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // string objectname = 3;
  void clear_objectname();
  const std::string& objectname() const;
  void set_objectname(const std::string& value);
  void set_objectname(std::string&& value);
  void set_objectname(const char* value);
  void set_objectname(const char* value, size_t size);
  std::string* mutable_objectname();
  std::string* release_objectname();
  void set_allocated_objectname(std::string* objectname);

  // .sim_msg.PhysicleCommon physicle = 5;
  bool has_physicle() const;
  void clear_physicle();
  const ::sim_msg::PhysicleCommon& physicle() const;
  ::sim_msg::PhysicleCommon* release_physicle();
  ::sim_msg::PhysicleCommon* mutable_physicle();
  void set_allocated_physicle(::sim_msg::PhysicleCommon* physicle);

  // .sim_msg.InitialCommon initial = 6;
  bool has_initial() const;
  void clear_initial();
  const ::sim_msg::InitialCommon& initial() const;
  ::sim_msg::InitialCommon* release_initial();
  ::sim_msg::InitialCommon* mutable_initial();
  void set_allocated_initial(::sim_msg::InitialCommon* initial);

  // .sim_msg.Dynamic dynamic = 7;
  bool has_dynamic() const;
  void clear_dynamic();
  const ::sim_msg::Dynamic& dynamic() const;
  ::sim_msg::Dynamic* release_dynamic();
  ::sim_msg::Dynamic* mutable_dynamic();
  void set_allocated_dynamic(::sim_msg::Dynamic* dynamic);

  // .sim_msg.SensorGroup sensor_group = 8;
  bool has_sensor_group() const;
  void clear_sensor_group();
  const ::sim_msg::SensorGroup& sensor_group() const;
  ::sim_msg::SensorGroup* release_sensor_group();
  ::sim_msg::SensorGroup* mutable_sensor_group();
  void set_allocated_sensor_group(::sim_msg::SensorGroup* sensor_group);

  // int64 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);

  // .sim_msg.CategoryMisc category = 4;
  void clear_category();
  ::sim_msg::CategoryMisc category() const;
  void set_category(::sim_msg::CategoryMisc value);

  // @@protoc_insertion_point(class_scope:sim_msg.MiscellaneousObject)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr objectname_;
  ::sim_msg::PhysicleCommon* physicle_;
  ::sim_msg::InitialCommon* initial_;
  ::sim_msg::Dynamic* dynamic_;
  ::sim_msg::SensorGroup* sensor_group_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  int category_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class MapModel :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.MapModel) */ {
 public:
  MapModel();
  virtual ~MapModel();

  MapModel(const MapModel& from);
  MapModel(MapModel&& from) noexcept
    : MapModel() {
    *this = ::std::move(from);
  }

  inline MapModel& operator=(const MapModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapModel& operator=(MapModel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MapModel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapModel* internal_default_instance() {
    return reinterpret_cast<const MapModel*>(
               &_MapModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(MapModel& a, MapModel& b) {
    a.Swap(&b);
  }
  inline void Swap(MapModel* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MapModel* New() const final {
    return CreateMaybeMessage<MapModel>(nullptr);
  }

  MapModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MapModel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MapModel& from);
  void MergeFrom(const MapModel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapModel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.MapModel";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCommonFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // .sim_msg.PhysicleCommon common = 2;
  bool has_common() const;
  void clear_common();
  const ::sim_msg::PhysicleCommon& common() const;
  ::sim_msg::PhysicleCommon* release_common();
  ::sim_msg::PhysicleCommon* mutable_common();
  void set_allocated_common(::sim_msg::PhysicleCommon* common);

  // @@protoc_insertion_point(class_scope:sim_msg.MapModel)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::sim_msg::PhysicleCommon* common_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class Scene_EnvironmentEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Scene_EnvironmentEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int64, ::sim_msg::EnvironmentalConditions,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Scene_EnvironmentEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::int64, ::sim_msg::EnvironmentalConditions,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Scene_EnvironmentEntry_DoNotUse();
  Scene_EnvironmentEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Scene_EnvironmentEntry_DoNotUse& other);
  static const Scene_EnvironmentEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Scene_EnvironmentEntry_DoNotUse*>(&_Scene_EnvironmentEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[35];
  }

  public:
};

// -------------------------------------------------------------------

class Scene :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Scene) */ {
 public:
  Scene();
  virtual ~Scene();

  Scene(const Scene& from);
  Scene(Scene&& from) noexcept
    : Scene() {
    *this = ::std::move(from);
  }

  inline Scene& operator=(const Scene& from) {
    CopyFrom(from);
    return *this;
  }
  inline Scene& operator=(Scene&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Scene& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scene* internal_default_instance() {
    return reinterpret_cast<const Scene*>(
               &_Scene_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(Scene& a, Scene& b) {
    a.Swap(&b);
  }
  inline void Swap(Scene* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Scene* New() const final {
    return CreateMaybeMessage<Scene>(nullptr);
  }

  Scene* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Scene>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Scene& from);
  void MergeFrom(const Scene& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scene* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Scene";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_scene_2eproto);
    return ::descriptor_table_scene_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kEgosFieldNumber = 2,
    kVehiclesFieldNumber = 3,
    kVrusFieldNumber = 4,
    kMiscsFieldNumber = 5,
    kEnvironmentFieldNumber = 6,
    kMapModelsFieldNumber = 8,
    kSettingFieldNumber = 1,
    kInfrastructureGroupFieldNumber = 7,
  };
  // repeated .sim_msg.Ego egos = 2;
  int egos_size() const;
  void clear_egos();
  ::sim_msg::Ego* mutable_egos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Ego >*
      mutable_egos();
  const ::sim_msg::Ego& egos(int index) const;
  ::sim_msg::Ego* add_egos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Ego >&
      egos() const;

  // repeated .sim_msg.Vehicle vehicles = 3;
  int vehicles_size() const;
  void clear_vehicles();
  ::sim_msg::Vehicle* mutable_vehicles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Vehicle >*
      mutable_vehicles();
  const ::sim_msg::Vehicle& vehicles(int index) const;
  ::sim_msg::Vehicle* add_vehicles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Vehicle >&
      vehicles() const;

  // repeated .sim_msg.VulnerableRoadUser vrus = 4;
  int vrus_size() const;
  void clear_vrus();
  ::sim_msg::VulnerableRoadUser* mutable_vrus(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::VulnerableRoadUser >*
      mutable_vrus();
  const ::sim_msg::VulnerableRoadUser& vrus(int index) const;
  ::sim_msg::VulnerableRoadUser* add_vrus();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::VulnerableRoadUser >&
      vrus() const;

  // repeated .sim_msg.MiscellaneousObject miscs = 5;
  int miscs_size() const;
  void clear_miscs();
  ::sim_msg::MiscellaneousObject* mutable_miscs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::MiscellaneousObject >*
      mutable_miscs();
  const ::sim_msg::MiscellaneousObject& miscs(int index) const;
  ::sim_msg::MiscellaneousObject* add_miscs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::MiscellaneousObject >&
      miscs() const;

  // map<int64, .sim_msg.EnvironmentalConditions> environment = 6;
  int environment_size() const;
  void clear_environment();
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, ::sim_msg::EnvironmentalConditions >&
      environment() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, ::sim_msg::EnvironmentalConditions >*
      mutable_environment();

  // repeated .sim_msg.MapModel map_models = 8;
  int map_models_size() const;
  void clear_map_models();
  ::sim_msg::MapModel* mutable_map_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::MapModel >*
      mutable_map_models();
  const ::sim_msg::MapModel& map_models(int index) const;
  ::sim_msg::MapModel* add_map_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::MapModel >&
      map_models() const;

  // .sim_msg.Setting setting = 1;
  bool has_setting() const;
  void clear_setting();
  const ::sim_msg::Setting& setting() const;
  ::sim_msg::Setting* release_setting();
  ::sim_msg::Setting* mutable_setting();
  void set_allocated_setting(::sim_msg::Setting* setting);

  // .sim_msg.InfrastructureGroup infrastructure_group = 7;
  bool has_infrastructure_group() const;
  void clear_infrastructure_group();
  const ::sim_msg::InfrastructureGroup& infrastructure_group() const;
  ::sim_msg::InfrastructureGroup* release_infrastructure_group();
  ::sim_msg::InfrastructureGroup* mutable_infrastructure_group();
  void set_allocated_infrastructure_group(::sim_msg::InfrastructureGroup* infrastructure_group);

  // @@protoc_insertion_point(class_scope:sim_msg.Scene)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Ego > egos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Vehicle > vehicles_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::VulnerableRoadUser > vrus_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::MiscellaneousObject > miscs_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Scene_EnvironmentEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::int64, ::sim_msg::EnvironmentalConditions,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > environment_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::MapModel > map_models_;
  ::sim_msg::Setting* setting_;
  ::sim_msg::InfrastructureGroup* infrastructure_group_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_scene_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DynamicConstraints

// double max_acceleration = 1;
inline void DynamicConstraints::clear_max_acceleration() {
  max_acceleration_ = 0;
}
inline double DynamicConstraints::max_acceleration() const {
  // @@protoc_insertion_point(field_get:sim_msg.DynamicConstraints.max_acceleration)
  return max_acceleration_;
}
inline void DynamicConstraints::set_max_acceleration(double value) {
  
  max_acceleration_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.DynamicConstraints.max_acceleration)
}

// double max_deceleration = 2;
inline void DynamicConstraints::clear_max_deceleration() {
  max_deceleration_ = 0;
}
inline double DynamicConstraints::max_deceleration() const {
  // @@protoc_insertion_point(field_get:sim_msg.DynamicConstraints.max_deceleration)
  return max_deceleration_;
}
inline void DynamicConstraints::set_max_deceleration(double value) {
  
  max_deceleration_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.DynamicConstraints.max_deceleration)
}

// double max_speed = 3;
inline void DynamicConstraints::clear_max_speed() {
  max_speed_ = 0;
}
inline double DynamicConstraints::max_speed() const {
  // @@protoc_insertion_point(field_get:sim_msg.DynamicConstraints.max_speed)
  return max_speed_;
}
inline void DynamicConstraints::set_max_speed(double value) {
  
  max_speed_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.DynamicConstraints.max_speed)
}

// -------------------------------------------------------------------

// BoundingBox

// .sim_msg.Vec3 center = 1;
inline bool BoundingBox::has_center() const {
  return this != internal_default_instance() && center_ != nullptr;
}
inline const ::sim_msg::Vec3& BoundingBox::center() const {
  const ::sim_msg::Vec3* p = center_;
  // @@protoc_insertion_point(field_get:sim_msg.BoundingBox.center)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Vec3*>(
      &::sim_msg::_Vec3_default_instance_);
}
inline ::sim_msg::Vec3* BoundingBox::release_center() {
  // @@protoc_insertion_point(field_release:sim_msg.BoundingBox.center)
  
  ::sim_msg::Vec3* temp = center_;
  center_ = nullptr;
  return temp;
}
inline ::sim_msg::Vec3* BoundingBox::mutable_center() {
  
  if (center_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Vec3>(GetArenaNoVirtual());
    center_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.BoundingBox.center)
  return center_;
}
inline void BoundingBox::set_allocated_center(::sim_msg::Vec3* center) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_);
  }
  if (center) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      center = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    
  } else {
    
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.BoundingBox.center)
}

// double length = 2;
inline void BoundingBox::clear_length() {
  length_ = 0;
}
inline double BoundingBox::length() const {
  // @@protoc_insertion_point(field_get:sim_msg.BoundingBox.length)
  return length_;
}
inline void BoundingBox::set_length(double value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.BoundingBox.length)
}

// double width = 3;
inline void BoundingBox::clear_width() {
  width_ = 0;
}
inline double BoundingBox::width() const {
  // @@protoc_insertion_point(field_get:sim_msg.BoundingBox.width)
  return width_;
}
inline void BoundingBox::set_width(double value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.BoundingBox.width)
}

// double higth = 4;
inline void BoundingBox::clear_higth() {
  higth_ = 0;
}
inline double BoundingBox::higth() const {
  // @@protoc_insertion_point(field_get:sim_msg.BoundingBox.higth)
  return higth_;
}
inline void BoundingBox::set_higth(double value) {
  
  higth_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.BoundingBox.higth)
}

// -------------------------------------------------------------------

// Performance

// double max_speed = 1;
inline void Performance::clear_max_speed() {
  max_speed_ = 0;
}
inline double Performance::max_speed() const {
  // @@protoc_insertion_point(field_get:sim_msg.Performance.max_speed)
  return max_speed_;
}
inline void Performance::set_max_speed(double value) {
  
  max_speed_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Performance.max_speed)
}

// double max_accel = 2;
inline void Performance::clear_max_accel() {
  max_accel_ = 0;
}
inline double Performance::max_accel() const {
  // @@protoc_insertion_point(field_get:sim_msg.Performance.max_accel)
  return max_accel_;
}
inline void Performance::set_max_accel(double value) {
  
  max_accel_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Performance.max_accel)
}

// double max_decel = 3;
inline void Performance::clear_max_decel() {
  max_decel_ = 0;
}
inline double Performance::max_decel() const {
  // @@protoc_insertion_point(field_get:sim_msg.Performance.max_decel)
  return max_decel_;
}
inline void Performance::set_max_decel(double value) {
  
  max_decel_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Performance.max_decel)
}

// -------------------------------------------------------------------

// ConditionTimeToCollision

// string entity_ref = 1;
inline void ConditionTimeToCollision::clear_entity_ref() {
  entity_ref_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ConditionTimeToCollision::entity_ref() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionTimeToCollision.entity_ref)
  return entity_ref_.GetNoArena();
}
inline void ConditionTimeToCollision::set_entity_ref(const std::string& value) {
  
  entity_ref_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.ConditionTimeToCollision.entity_ref)
}
inline void ConditionTimeToCollision::set_entity_ref(std::string&& value) {
  
  entity_ref_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.ConditionTimeToCollision.entity_ref)
}
inline void ConditionTimeToCollision::set_entity_ref(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  entity_ref_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.ConditionTimeToCollision.entity_ref)
}
inline void ConditionTimeToCollision::set_entity_ref(const char* value, size_t size) {
  
  entity_ref_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.ConditionTimeToCollision.entity_ref)
}
inline std::string* ConditionTimeToCollision::mutable_entity_ref() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.ConditionTimeToCollision.entity_ref)
  return entity_ref_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ConditionTimeToCollision::release_entity_ref() {
  // @@protoc_insertion_point(field_release:sim_msg.ConditionTimeToCollision.entity_ref)
  
  return entity_ref_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ConditionTimeToCollision::set_allocated_entity_ref(std::string* entity_ref) {
  if (entity_ref != nullptr) {
    
  } else {
    
  }
  entity_ref_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), entity_ref);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.ConditionTimeToCollision.entity_ref)
}

// .sim_msg.DistanceType distance_type = 2;
inline void ConditionTimeToCollision::clear_distance_type() {
  distance_type_ = 0;
}
inline ::sim_msg::DistanceType ConditionTimeToCollision::distance_type() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionTimeToCollision.distance_type)
  return static_cast< ::sim_msg::DistanceType >(distance_type_);
}
inline void ConditionTimeToCollision::set_distance_type(::sim_msg::DistanceType value) {
  
  distance_type_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionTimeToCollision.distance_type)
}

// .sim_msg.Rule rule = 3;
inline void ConditionTimeToCollision::clear_rule() {
  rule_ = 0;
}
inline ::sim_msg::Rule ConditionTimeToCollision::rule() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionTimeToCollision.rule)
  return static_cast< ::sim_msg::Rule >(rule_);
}
inline void ConditionTimeToCollision::set_rule(::sim_msg::Rule value) {
  
  rule_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionTimeToCollision.rule)
}

// double value = 4;
inline void ConditionTimeToCollision::clear_value() {
  value_ = 0;
}
inline double ConditionTimeToCollision::value() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionTimeToCollision.value)
  return value_;
}
inline void ConditionTimeToCollision::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionTimeToCollision.value)
}

// -------------------------------------------------------------------

// ConditionSpeed

// .sim_msg.DirDimension direction = 1;
inline void ConditionSpeed::clear_direction() {
  direction_ = 0;
}
inline ::sim_msg::DirDimension ConditionSpeed::direction() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionSpeed.direction)
  return static_cast< ::sim_msg::DirDimension >(direction_);
}
inline void ConditionSpeed::set_direction(::sim_msg::DirDimension value) {
  
  direction_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionSpeed.direction)
}

// .sim_msg.Rule rule = 2;
inline void ConditionSpeed::clear_rule() {
  rule_ = 0;
}
inline ::sim_msg::Rule ConditionSpeed::rule() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionSpeed.rule)
  return static_cast< ::sim_msg::Rule >(rule_);
}
inline void ConditionSpeed::set_rule(::sim_msg::Rule value) {
  
  rule_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionSpeed.rule)
}

// double value = 3;
inline void ConditionSpeed::clear_value() {
  value_ = 0;
}
inline double ConditionSpeed::value() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionSpeed.value)
  return value_;
}
inline void ConditionSpeed::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionSpeed.value)
}

// -------------------------------------------------------------------

// ConditionRelativeSpeed

// string entity_ref = 1;
inline void ConditionRelativeSpeed::clear_entity_ref() {
  entity_ref_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ConditionRelativeSpeed::entity_ref() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionRelativeSpeed.entity_ref)
  return entity_ref_.GetNoArena();
}
inline void ConditionRelativeSpeed::set_entity_ref(const std::string& value) {
  
  entity_ref_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.ConditionRelativeSpeed.entity_ref)
}
inline void ConditionRelativeSpeed::set_entity_ref(std::string&& value) {
  
  entity_ref_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.ConditionRelativeSpeed.entity_ref)
}
inline void ConditionRelativeSpeed::set_entity_ref(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  entity_ref_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.ConditionRelativeSpeed.entity_ref)
}
inline void ConditionRelativeSpeed::set_entity_ref(const char* value, size_t size) {
  
  entity_ref_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.ConditionRelativeSpeed.entity_ref)
}
inline std::string* ConditionRelativeSpeed::mutable_entity_ref() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.ConditionRelativeSpeed.entity_ref)
  return entity_ref_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ConditionRelativeSpeed::release_entity_ref() {
  // @@protoc_insertion_point(field_release:sim_msg.ConditionRelativeSpeed.entity_ref)
  
  return entity_ref_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ConditionRelativeSpeed::set_allocated_entity_ref(std::string* entity_ref) {
  if (entity_ref != nullptr) {
    
  } else {
    
  }
  entity_ref_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), entity_ref);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.ConditionRelativeSpeed.entity_ref)
}

// .sim_msg.DirDimension direction = 2;
inline void ConditionRelativeSpeed::clear_direction() {
  direction_ = 0;
}
inline ::sim_msg::DirDimension ConditionRelativeSpeed::direction() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionRelativeSpeed.direction)
  return static_cast< ::sim_msg::DirDimension >(direction_);
}
inline void ConditionRelativeSpeed::set_direction(::sim_msg::DirDimension value) {
  
  direction_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionRelativeSpeed.direction)
}

// .sim_msg.Rule rule = 3;
inline void ConditionRelativeSpeed::clear_rule() {
  rule_ = 0;
}
inline ::sim_msg::Rule ConditionRelativeSpeed::rule() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionRelativeSpeed.rule)
  return static_cast< ::sim_msg::Rule >(rule_);
}
inline void ConditionRelativeSpeed::set_rule(::sim_msg::Rule value) {
  
  rule_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionRelativeSpeed.rule)
}

// double value = 4;
inline void ConditionRelativeSpeed::clear_value() {
  value_ = 0;
}
inline double ConditionRelativeSpeed::value() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionRelativeSpeed.value)
  return value_;
}
inline void ConditionRelativeSpeed::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionRelativeSpeed.value)
}

// -------------------------------------------------------------------

// ConditionReachPosition

// double radius = 1;
inline void ConditionReachPosition::clear_radius() {
  radius_ = 0;
}
inline double ConditionReachPosition::radius() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionReachPosition.radius)
  return radius_;
}
inline void ConditionReachPosition::set_radius(double value) {
  
  radius_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionReachPosition.radius)
}

// .sim_msg.Position position = 2;
inline bool ConditionReachPosition::has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline const ::sim_msg::Position& ConditionReachPosition::position() const {
  const ::sim_msg::Position* p = position_;
  // @@protoc_insertion_point(field_get:sim_msg.ConditionReachPosition.position)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Position*>(
      &::sim_msg::_Position_default_instance_);
}
inline ::sim_msg::Position* ConditionReachPosition::release_position() {
  // @@protoc_insertion_point(field_release:sim_msg.ConditionReachPosition.position)
  
  ::sim_msg::Position* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::sim_msg::Position* ConditionReachPosition::mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Position>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.ConditionReachPosition.position)
  return position_;
}
inline void ConditionReachPosition::set_allocated_position(::sim_msg::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.ConditionReachPosition.position)
}

// -------------------------------------------------------------------

// ConditionRelativeDistance

// string entity_ref = 1;
inline void ConditionRelativeDistance::clear_entity_ref() {
  entity_ref_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ConditionRelativeDistance::entity_ref() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionRelativeDistance.entity_ref)
  return entity_ref_.GetNoArena();
}
inline void ConditionRelativeDistance::set_entity_ref(const std::string& value) {
  
  entity_ref_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.ConditionRelativeDistance.entity_ref)
}
inline void ConditionRelativeDistance::set_entity_ref(std::string&& value) {
  
  entity_ref_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.ConditionRelativeDistance.entity_ref)
}
inline void ConditionRelativeDistance::set_entity_ref(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  entity_ref_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.ConditionRelativeDistance.entity_ref)
}
inline void ConditionRelativeDistance::set_entity_ref(const char* value, size_t size) {
  
  entity_ref_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.ConditionRelativeDistance.entity_ref)
}
inline std::string* ConditionRelativeDistance::mutable_entity_ref() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.ConditionRelativeDistance.entity_ref)
  return entity_ref_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ConditionRelativeDistance::release_entity_ref() {
  // @@protoc_insertion_point(field_release:sim_msg.ConditionRelativeDistance.entity_ref)
  
  return entity_ref_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ConditionRelativeDistance::set_allocated_entity_ref(std::string* entity_ref) {
  if (entity_ref != nullptr) {
    
  } else {
    
  }
  entity_ref_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), entity_ref);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.ConditionRelativeDistance.entity_ref)
}

// .sim_msg.DistanceType distance_type = 2;
inline void ConditionRelativeDistance::clear_distance_type() {
  distance_type_ = 0;
}
inline ::sim_msg::DistanceType ConditionRelativeDistance::distance_type() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionRelativeDistance.distance_type)
  return static_cast< ::sim_msg::DistanceType >(distance_type_);
}
inline void ConditionRelativeDistance::set_distance_type(::sim_msg::DistanceType value) {
  
  distance_type_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionRelativeDistance.distance_type)
}

// .sim_msg.Rule rule = 3;
inline void ConditionRelativeDistance::clear_rule() {
  rule_ = 0;
}
inline ::sim_msg::Rule ConditionRelativeDistance::rule() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionRelativeDistance.rule)
  return static_cast< ::sim_msg::Rule >(rule_);
}
inline void ConditionRelativeDistance::set_rule(::sim_msg::Rule value) {
  
  rule_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionRelativeDistance.rule)
}

// double value = 4;
inline void ConditionRelativeDistance::clear_value() {
  value_ = 0;
}
inline double ConditionRelativeDistance::value() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionRelativeDistance.value)
  return value_;
}
inline void ConditionRelativeDistance::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionRelativeDistance.value)
}

// -------------------------------------------------------------------

// ConditionEgoAttachLaneidCustom

// uint64 road_id = 1;
inline void ConditionEgoAttachLaneidCustom::clear_road_id() {
  road_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ConditionEgoAttachLaneidCustom::road_id() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionEgoAttachLaneidCustom.road_id)
  return road_id_;
}
inline void ConditionEgoAttachLaneidCustom::set_road_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  road_id_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionEgoAttachLaneidCustom.road_id)
}

// uint64 section_id = 2;
inline void ConditionEgoAttachLaneidCustom::clear_section_id() {
  section_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ConditionEgoAttachLaneidCustom::section_id() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionEgoAttachLaneidCustom.section_id)
  return section_id_;
}
inline void ConditionEgoAttachLaneidCustom::set_section_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  section_id_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionEgoAttachLaneidCustom.section_id)
}

// int64 lane_id = 3;
inline void ConditionEgoAttachLaneidCustom::clear_lane_id() {
  lane_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ConditionEgoAttachLaneidCustom::lane_id() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionEgoAttachLaneidCustom.lane_id)
  return lane_id_;
}
inline void ConditionEgoAttachLaneidCustom::set_lane_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  lane_id_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionEgoAttachLaneidCustom.lane_id)
}

// -------------------------------------------------------------------

// ConditionSimulationTime

// .sim_msg.Rule rule = 1;
inline void ConditionSimulationTime::clear_rule() {
  rule_ = 0;
}
inline ::sim_msg::Rule ConditionSimulationTime::rule() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionSimulationTime.rule)
  return static_cast< ::sim_msg::Rule >(rule_);
}
inline void ConditionSimulationTime::set_rule(::sim_msg::Rule value) {
  
  rule_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionSimulationTime.rule)
}

// double value = 2;
inline void ConditionSimulationTime::clear_value() {
  value_ = 0;
}
inline double ConditionSimulationTime::value() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionSimulationTime.value)
  return value_;
}
inline void ConditionSimulationTime::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionSimulationTime.value)
}

// -------------------------------------------------------------------

// ConditionTimeHeadway

// string entity_ref = 1;
inline void ConditionTimeHeadway::clear_entity_ref() {
  entity_ref_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ConditionTimeHeadway::entity_ref() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionTimeHeadway.entity_ref)
  return entity_ref_.GetNoArena();
}
inline void ConditionTimeHeadway::set_entity_ref(const std::string& value) {
  
  entity_ref_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.ConditionTimeHeadway.entity_ref)
}
inline void ConditionTimeHeadway::set_entity_ref(std::string&& value) {
  
  entity_ref_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.ConditionTimeHeadway.entity_ref)
}
inline void ConditionTimeHeadway::set_entity_ref(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  entity_ref_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.ConditionTimeHeadway.entity_ref)
}
inline void ConditionTimeHeadway::set_entity_ref(const char* value, size_t size) {
  
  entity_ref_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.ConditionTimeHeadway.entity_ref)
}
inline std::string* ConditionTimeHeadway::mutable_entity_ref() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.ConditionTimeHeadway.entity_ref)
  return entity_ref_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ConditionTimeHeadway::release_entity_ref() {
  // @@protoc_insertion_point(field_release:sim_msg.ConditionTimeHeadway.entity_ref)
  
  return entity_ref_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ConditionTimeHeadway::set_allocated_entity_ref(std::string* entity_ref) {
  if (entity_ref != nullptr) {
    
  } else {
    
  }
  entity_ref_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), entity_ref);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.ConditionTimeHeadway.entity_ref)
}

// double value = 2;
inline void ConditionTimeHeadway::clear_value() {
  value_ = 0;
}
inline double ConditionTimeHeadway::value() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionTimeHeadway.value)
  return value_;
}
inline void ConditionTimeHeadway::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionTimeHeadway.value)
}

// bool freespace = 3;
inline void ConditionTimeHeadway::clear_freespace() {
  freespace_ = false;
}
inline bool ConditionTimeHeadway::freespace() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionTimeHeadway.freespace)
  return freespace_;
}
inline void ConditionTimeHeadway::set_freespace(bool value) {
  
  freespace_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionTimeHeadway.freespace)
}

// bool along_route = 4;
inline void ConditionTimeHeadway::clear_along_route() {
  along_route_ = false;
}
inline bool ConditionTimeHeadway::along_route() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionTimeHeadway.along_route)
  return along_route_;
}
inline void ConditionTimeHeadway::set_along_route(bool value) {
  
  along_route_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionTimeHeadway.along_route)
}

// .sim_msg.Rule rule = 5;
inline void ConditionTimeHeadway::clear_rule() {
  rule_ = 0;
}
inline ::sim_msg::Rule ConditionTimeHeadway::rule() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionTimeHeadway.rule)
  return static_cast< ::sim_msg::Rule >(rule_);
}
inline void ConditionTimeHeadway::set_rule(::sim_msg::Rule value) {
  
  rule_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionTimeHeadway.rule)
}

// -------------------------------------------------------------------

// ConditionReachDistance

// string entity_ref = 1;
inline void ConditionReachDistance::clear_entity_ref() {
  entity_ref_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ConditionReachDistance::entity_ref() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionReachDistance.entity_ref)
  return entity_ref_.GetNoArena();
}
inline void ConditionReachDistance::set_entity_ref(const std::string& value) {
  
  entity_ref_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.ConditionReachDistance.entity_ref)
}
inline void ConditionReachDistance::set_entity_ref(std::string&& value) {
  
  entity_ref_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.ConditionReachDistance.entity_ref)
}
inline void ConditionReachDistance::set_entity_ref(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  entity_ref_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.ConditionReachDistance.entity_ref)
}
inline void ConditionReachDistance::set_entity_ref(const char* value, size_t size) {
  
  entity_ref_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.ConditionReachDistance.entity_ref)
}
inline std::string* ConditionReachDistance::mutable_entity_ref() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.ConditionReachDistance.entity_ref)
  return entity_ref_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ConditionReachDistance::release_entity_ref() {
  // @@protoc_insertion_point(field_release:sim_msg.ConditionReachDistance.entity_ref)
  
  return entity_ref_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ConditionReachDistance::set_allocated_entity_ref(std::string* entity_ref) {
  if (entity_ref != nullptr) {
    
  } else {
    
  }
  entity_ref_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), entity_ref);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.ConditionReachDistance.entity_ref)
}

// double value = 2;
inline void ConditionReachDistance::clear_value() {
  value_ = 0;
}
inline double ConditionReachDistance::value() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionReachDistance.value)
  return value_;
}
inline void ConditionReachDistance::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionReachDistance.value)
}

// bool freespace = 3;
inline void ConditionReachDistance::clear_freespace() {
  freespace_ = false;
}
inline bool ConditionReachDistance::freespace() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionReachDistance.freespace)
  return freespace_;
}
inline void ConditionReachDistance::set_freespace(bool value) {
  
  freespace_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionReachDistance.freespace)
}

// bool along_route = 4;
inline void ConditionReachDistance::clear_along_route() {
  along_route_ = false;
}
inline bool ConditionReachDistance::along_route() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionReachDistance.along_route)
  return along_route_;
}
inline void ConditionReachDistance::set_along_route(bool value) {
  
  along_route_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionReachDistance.along_route)
}

// .sim_msg.Rule rule = 5;
inline void ConditionReachDistance::clear_rule() {
  rule_ = 0;
}
inline ::sim_msg::Rule ConditionReachDistance::rule() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionReachDistance.rule)
  return static_cast< ::sim_msg::Rule >(rule_);
}
inline void ConditionReachDistance::set_rule(::sim_msg::Rule value) {
  
  rule_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionReachDistance.rule)
}

// -------------------------------------------------------------------

// ConditionStoryboardElementState

// .sim_msg.StoryboardElementType type = 1;
inline void ConditionStoryboardElementState::clear_type() {
  type_ = 0;
}
inline ::sim_msg::StoryboardElementType ConditionStoryboardElementState::type() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionStoryboardElementState.type)
  return static_cast< ::sim_msg::StoryboardElementType >(type_);
}
inline void ConditionStoryboardElementState::set_type(::sim_msg::StoryboardElementType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionStoryboardElementState.type)
}

// string storyboard_ref = 2;
inline void ConditionStoryboardElementState::clear_storyboard_ref() {
  storyboard_ref_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ConditionStoryboardElementState::storyboard_ref() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionStoryboardElementState.storyboard_ref)
  return storyboard_ref_.GetNoArena();
}
inline void ConditionStoryboardElementState::set_storyboard_ref(const std::string& value) {
  
  storyboard_ref_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.ConditionStoryboardElementState.storyboard_ref)
}
inline void ConditionStoryboardElementState::set_storyboard_ref(std::string&& value) {
  
  storyboard_ref_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.ConditionStoryboardElementState.storyboard_ref)
}
inline void ConditionStoryboardElementState::set_storyboard_ref(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  storyboard_ref_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.ConditionStoryboardElementState.storyboard_ref)
}
inline void ConditionStoryboardElementState::set_storyboard_ref(const char* value, size_t size) {
  
  storyboard_ref_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.ConditionStoryboardElementState.storyboard_ref)
}
inline std::string* ConditionStoryboardElementState::mutable_storyboard_ref() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.ConditionStoryboardElementState.storyboard_ref)
  return storyboard_ref_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ConditionStoryboardElementState::release_storyboard_ref() {
  // @@protoc_insertion_point(field_release:sim_msg.ConditionStoryboardElementState.storyboard_ref)
  
  return storyboard_ref_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ConditionStoryboardElementState::set_allocated_storyboard_ref(std::string* storyboard_ref) {
  if (storyboard_ref != nullptr) {
    
  } else {
    
  }
  storyboard_ref_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), storyboard_ref);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.ConditionStoryboardElementState.storyboard_ref)
}

// .sim_msg.StoryboardElementState state = 3;
inline void ConditionStoryboardElementState::clear_state() {
  state_ = 0;
}
inline ::sim_msg::StoryboardElementState ConditionStoryboardElementState::state() const {
  // @@protoc_insertion_point(field_get:sim_msg.ConditionStoryboardElementState.state)
  return static_cast< ::sim_msg::StoryboardElementState >(state_);
}
inline void ConditionStoryboardElementState::set_state(::sim_msg::StoryboardElementState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ConditionStoryboardElementState.state)
}

// -------------------------------------------------------------------

// Condition

// .sim_msg.ConditionEdge edge = 1;
inline void Condition::clear_edge() {
  edge_ = 0;
}
inline ::sim_msg::ConditionEdge Condition::edge() const {
  // @@protoc_insertion_point(field_get:sim_msg.Condition.edge)
  return static_cast< ::sim_msg::ConditionEdge >(edge_);
}
inline void Condition::set_edge(::sim_msg::ConditionEdge value) {
  
  edge_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Condition.edge)
}

// double delay = 2;
inline void Condition::clear_delay() {
  delay_ = 0;
}
inline double Condition::delay() const {
  // @@protoc_insertion_point(field_get:sim_msg.Condition.delay)
  return delay_;
}
inline void Condition::set_delay(double value) {
  
  delay_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Condition.delay)
}

// uint32 count = 3;
inline void Condition::clear_count() {
  count_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Condition::count() const {
  // @@protoc_insertion_point(field_get:sim_msg.Condition.count)
  return count_;
}
inline void Condition::set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Condition.count)
}

// .sim_msg.ConditionTimeToCollision ttc = 4;
inline bool Condition::has_ttc() const {
  return type_case() == kTtc;
}
inline void Condition::set_has_ttc() {
  _oneof_case_[0] = kTtc;
}
inline void Condition::clear_ttc() {
  if (has_ttc()) {
    delete type_.ttc_;
    clear_has_type();
  }
}
inline ::sim_msg::ConditionTimeToCollision* Condition::release_ttc() {
  // @@protoc_insertion_point(field_release:sim_msg.Condition.ttc)
  if (has_ttc()) {
    clear_has_type();
      ::sim_msg::ConditionTimeToCollision* temp = type_.ttc_;
    type_.ttc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sim_msg::ConditionTimeToCollision& Condition::ttc() const {
  // @@protoc_insertion_point(field_get:sim_msg.Condition.ttc)
  return has_ttc()
      ? *type_.ttc_
      : *reinterpret_cast< ::sim_msg::ConditionTimeToCollision*>(&::sim_msg::_ConditionTimeToCollision_default_instance_);
}
inline ::sim_msg::ConditionTimeToCollision* Condition::mutable_ttc() {
  if (!has_ttc()) {
    clear_type();
    set_has_ttc();
    type_.ttc_ = CreateMaybeMessage< ::sim_msg::ConditionTimeToCollision >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Condition.ttc)
  return type_.ttc_;
}

// .sim_msg.ConditionSpeed speed = 5;
inline bool Condition::has_speed() const {
  return type_case() == kSpeed;
}
inline void Condition::set_has_speed() {
  _oneof_case_[0] = kSpeed;
}
inline void Condition::clear_speed() {
  if (has_speed()) {
    delete type_.speed_;
    clear_has_type();
  }
}
inline ::sim_msg::ConditionSpeed* Condition::release_speed() {
  // @@protoc_insertion_point(field_release:sim_msg.Condition.speed)
  if (has_speed()) {
    clear_has_type();
      ::sim_msg::ConditionSpeed* temp = type_.speed_;
    type_.speed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sim_msg::ConditionSpeed& Condition::speed() const {
  // @@protoc_insertion_point(field_get:sim_msg.Condition.speed)
  return has_speed()
      ? *type_.speed_
      : *reinterpret_cast< ::sim_msg::ConditionSpeed*>(&::sim_msg::_ConditionSpeed_default_instance_);
}
inline ::sim_msg::ConditionSpeed* Condition::mutable_speed() {
  if (!has_speed()) {
    clear_type();
    set_has_speed();
    type_.speed_ = CreateMaybeMessage< ::sim_msg::ConditionSpeed >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Condition.speed)
  return type_.speed_;
}

// .sim_msg.ConditionRelativeSpeed relative_speed = 6;
inline bool Condition::has_relative_speed() const {
  return type_case() == kRelativeSpeed;
}
inline void Condition::set_has_relative_speed() {
  _oneof_case_[0] = kRelativeSpeed;
}
inline void Condition::clear_relative_speed() {
  if (has_relative_speed()) {
    delete type_.relative_speed_;
    clear_has_type();
  }
}
inline ::sim_msg::ConditionRelativeSpeed* Condition::release_relative_speed() {
  // @@protoc_insertion_point(field_release:sim_msg.Condition.relative_speed)
  if (has_relative_speed()) {
    clear_has_type();
      ::sim_msg::ConditionRelativeSpeed* temp = type_.relative_speed_;
    type_.relative_speed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sim_msg::ConditionRelativeSpeed& Condition::relative_speed() const {
  // @@protoc_insertion_point(field_get:sim_msg.Condition.relative_speed)
  return has_relative_speed()
      ? *type_.relative_speed_
      : *reinterpret_cast< ::sim_msg::ConditionRelativeSpeed*>(&::sim_msg::_ConditionRelativeSpeed_default_instance_);
}
inline ::sim_msg::ConditionRelativeSpeed* Condition::mutable_relative_speed() {
  if (!has_relative_speed()) {
    clear_type();
    set_has_relative_speed();
    type_.relative_speed_ = CreateMaybeMessage< ::sim_msg::ConditionRelativeSpeed >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Condition.relative_speed)
  return type_.relative_speed_;
}

// .sim_msg.ConditionReachPosition reach_position = 7;
inline bool Condition::has_reach_position() const {
  return type_case() == kReachPosition;
}
inline void Condition::set_has_reach_position() {
  _oneof_case_[0] = kReachPosition;
}
inline void Condition::clear_reach_position() {
  if (has_reach_position()) {
    delete type_.reach_position_;
    clear_has_type();
  }
}
inline ::sim_msg::ConditionReachPosition* Condition::release_reach_position() {
  // @@protoc_insertion_point(field_release:sim_msg.Condition.reach_position)
  if (has_reach_position()) {
    clear_has_type();
      ::sim_msg::ConditionReachPosition* temp = type_.reach_position_;
    type_.reach_position_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sim_msg::ConditionReachPosition& Condition::reach_position() const {
  // @@protoc_insertion_point(field_get:sim_msg.Condition.reach_position)
  return has_reach_position()
      ? *type_.reach_position_
      : *reinterpret_cast< ::sim_msg::ConditionReachPosition*>(&::sim_msg::_ConditionReachPosition_default_instance_);
}
inline ::sim_msg::ConditionReachPosition* Condition::mutable_reach_position() {
  if (!has_reach_position()) {
    clear_type();
    set_has_reach_position();
    type_.reach_position_ = CreateMaybeMessage< ::sim_msg::ConditionReachPosition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Condition.reach_position)
  return type_.reach_position_;
}

// .sim_msg.ConditionRelativeDistance relative_distance = 8;
inline bool Condition::has_relative_distance() const {
  return type_case() == kRelativeDistance;
}
inline void Condition::set_has_relative_distance() {
  _oneof_case_[0] = kRelativeDistance;
}
inline void Condition::clear_relative_distance() {
  if (has_relative_distance()) {
    delete type_.relative_distance_;
    clear_has_type();
  }
}
inline ::sim_msg::ConditionRelativeDistance* Condition::release_relative_distance() {
  // @@protoc_insertion_point(field_release:sim_msg.Condition.relative_distance)
  if (has_relative_distance()) {
    clear_has_type();
      ::sim_msg::ConditionRelativeDistance* temp = type_.relative_distance_;
    type_.relative_distance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sim_msg::ConditionRelativeDistance& Condition::relative_distance() const {
  // @@protoc_insertion_point(field_get:sim_msg.Condition.relative_distance)
  return has_relative_distance()
      ? *type_.relative_distance_
      : *reinterpret_cast< ::sim_msg::ConditionRelativeDistance*>(&::sim_msg::_ConditionRelativeDistance_default_instance_);
}
inline ::sim_msg::ConditionRelativeDistance* Condition::mutable_relative_distance() {
  if (!has_relative_distance()) {
    clear_type();
    set_has_relative_distance();
    type_.relative_distance_ = CreateMaybeMessage< ::sim_msg::ConditionRelativeDistance >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Condition.relative_distance)
  return type_.relative_distance_;
}

// .sim_msg.ConditionEgoAttachLaneidCustom ego_attach_laneid_custom = 9;
inline bool Condition::has_ego_attach_laneid_custom() const {
  return type_case() == kEgoAttachLaneidCustom;
}
inline void Condition::set_has_ego_attach_laneid_custom() {
  _oneof_case_[0] = kEgoAttachLaneidCustom;
}
inline void Condition::clear_ego_attach_laneid_custom() {
  if (has_ego_attach_laneid_custom()) {
    delete type_.ego_attach_laneid_custom_;
    clear_has_type();
  }
}
inline ::sim_msg::ConditionEgoAttachLaneidCustom* Condition::release_ego_attach_laneid_custom() {
  // @@protoc_insertion_point(field_release:sim_msg.Condition.ego_attach_laneid_custom)
  if (has_ego_attach_laneid_custom()) {
    clear_has_type();
      ::sim_msg::ConditionEgoAttachLaneidCustom* temp = type_.ego_attach_laneid_custom_;
    type_.ego_attach_laneid_custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sim_msg::ConditionEgoAttachLaneidCustom& Condition::ego_attach_laneid_custom() const {
  // @@protoc_insertion_point(field_get:sim_msg.Condition.ego_attach_laneid_custom)
  return has_ego_attach_laneid_custom()
      ? *type_.ego_attach_laneid_custom_
      : *reinterpret_cast< ::sim_msg::ConditionEgoAttachLaneidCustom*>(&::sim_msg::_ConditionEgoAttachLaneidCustom_default_instance_);
}
inline ::sim_msg::ConditionEgoAttachLaneidCustom* Condition::mutable_ego_attach_laneid_custom() {
  if (!has_ego_attach_laneid_custom()) {
    clear_type();
    set_has_ego_attach_laneid_custom();
    type_.ego_attach_laneid_custom_ = CreateMaybeMessage< ::sim_msg::ConditionEgoAttachLaneidCustom >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Condition.ego_attach_laneid_custom)
  return type_.ego_attach_laneid_custom_;
}

// .sim_msg.ConditionTimeHeadway time_headway = 10;
inline bool Condition::has_time_headway() const {
  return type_case() == kTimeHeadway;
}
inline void Condition::set_has_time_headway() {
  _oneof_case_[0] = kTimeHeadway;
}
inline void Condition::clear_time_headway() {
  if (has_time_headway()) {
    delete type_.time_headway_;
    clear_has_type();
  }
}
inline ::sim_msg::ConditionTimeHeadway* Condition::release_time_headway() {
  // @@protoc_insertion_point(field_release:sim_msg.Condition.time_headway)
  if (has_time_headway()) {
    clear_has_type();
      ::sim_msg::ConditionTimeHeadway* temp = type_.time_headway_;
    type_.time_headway_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sim_msg::ConditionTimeHeadway& Condition::time_headway() const {
  // @@protoc_insertion_point(field_get:sim_msg.Condition.time_headway)
  return has_time_headway()
      ? *type_.time_headway_
      : *reinterpret_cast< ::sim_msg::ConditionTimeHeadway*>(&::sim_msg::_ConditionTimeHeadway_default_instance_);
}
inline ::sim_msg::ConditionTimeHeadway* Condition::mutable_time_headway() {
  if (!has_time_headway()) {
    clear_type();
    set_has_time_headway();
    type_.time_headway_ = CreateMaybeMessage< ::sim_msg::ConditionTimeHeadway >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Condition.time_headway)
  return type_.time_headway_;
}

// .sim_msg.ConditionStoryboardElementState storyboard_element_state = 11;
inline bool Condition::has_storyboard_element_state() const {
  return type_case() == kStoryboardElementState;
}
inline void Condition::set_has_storyboard_element_state() {
  _oneof_case_[0] = kStoryboardElementState;
}
inline void Condition::clear_storyboard_element_state() {
  if (has_storyboard_element_state()) {
    delete type_.storyboard_element_state_;
    clear_has_type();
  }
}
inline ::sim_msg::ConditionStoryboardElementState* Condition::release_storyboard_element_state() {
  // @@protoc_insertion_point(field_release:sim_msg.Condition.storyboard_element_state)
  if (has_storyboard_element_state()) {
    clear_has_type();
      ::sim_msg::ConditionStoryboardElementState* temp = type_.storyboard_element_state_;
    type_.storyboard_element_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sim_msg::ConditionStoryboardElementState& Condition::storyboard_element_state() const {
  // @@protoc_insertion_point(field_get:sim_msg.Condition.storyboard_element_state)
  return has_storyboard_element_state()
      ? *type_.storyboard_element_state_
      : *reinterpret_cast< ::sim_msg::ConditionStoryboardElementState*>(&::sim_msg::_ConditionStoryboardElementState_default_instance_);
}
inline ::sim_msg::ConditionStoryboardElementState* Condition::mutable_storyboard_element_state() {
  if (!has_storyboard_element_state()) {
    clear_type();
    set_has_storyboard_element_state();
    type_.storyboard_element_state_ = CreateMaybeMessage< ::sim_msg::ConditionStoryboardElementState >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Condition.storyboard_element_state)
  return type_.storyboard_element_state_;
}

// .sim_msg.ConditionSimulationTime simulation_time = 12;
inline bool Condition::has_simulation_time() const {
  return type_case() == kSimulationTime;
}
inline void Condition::set_has_simulation_time() {
  _oneof_case_[0] = kSimulationTime;
}
inline void Condition::clear_simulation_time() {
  if (has_simulation_time()) {
    delete type_.simulation_time_;
    clear_has_type();
  }
}
inline ::sim_msg::ConditionSimulationTime* Condition::release_simulation_time() {
  // @@protoc_insertion_point(field_release:sim_msg.Condition.simulation_time)
  if (has_simulation_time()) {
    clear_has_type();
      ::sim_msg::ConditionSimulationTime* temp = type_.simulation_time_;
    type_.simulation_time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sim_msg::ConditionSimulationTime& Condition::simulation_time() const {
  // @@protoc_insertion_point(field_get:sim_msg.Condition.simulation_time)
  return has_simulation_time()
      ? *type_.simulation_time_
      : *reinterpret_cast< ::sim_msg::ConditionSimulationTime*>(&::sim_msg::_ConditionSimulationTime_default_instance_);
}
inline ::sim_msg::ConditionSimulationTime* Condition::mutable_simulation_time() {
  if (!has_simulation_time()) {
    clear_type();
    set_has_simulation_time();
    type_.simulation_time_ = CreateMaybeMessage< ::sim_msg::ConditionSimulationTime >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Condition.simulation_time)
  return type_.simulation_time_;
}

inline bool Condition::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Condition::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Condition::TypeCase Condition::type_case() const {
  return Condition::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ActionSpeed

// double value = 1;
inline void ActionSpeed::clear_value() {
  value_ = 0;
}
inline double ActionSpeed::value() const {
  // @@protoc_insertion_point(field_get:sim_msg.ActionSpeed.value)
  return value_;
}
inline void ActionSpeed::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ActionSpeed.value)
}

// double angle = 2;
inline void ActionSpeed::clear_angle() {
  angle_ = 0;
}
inline double ActionSpeed::angle() const {
  // @@protoc_insertion_point(field_get:sim_msg.ActionSpeed.angle)
  return angle_;
}
inline void ActionSpeed::set_angle(double value) {
  
  angle_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ActionSpeed.angle)
}

// -------------------------------------------------------------------

// ActionAccel

// double value = 1;
inline void ActionAccel::clear_value() {
  value_ = 0;
}
inline double ActionAccel::value() const {
  // @@protoc_insertion_point(field_get:sim_msg.ActionAccel.value)
  return value_;
}
inline void ActionAccel::set_value(double value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ActionAccel.value)
}

// double angle = 2;
inline void ActionAccel::clear_angle() {
  angle_ = 0;
}
inline double ActionAccel::angle() const {
  // @@protoc_insertion_point(field_get:sim_msg.ActionAccel.angle)
  return angle_;
}
inline void ActionAccel::set_angle(double value) {
  
  angle_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ActionAccel.angle)
}

// .sim_msg.ActionAccel.EndType end_type = 3;
inline void ActionAccel::clear_end_type() {
  end_type_ = 0;
}
inline ::sim_msg::ActionAccel_EndType ActionAccel::end_type() const {
  // @@protoc_insertion_point(field_get:sim_msg.ActionAccel.end_type)
  return static_cast< ::sim_msg::ActionAccel_EndType >(end_type_);
}
inline void ActionAccel::set_end_type(::sim_msg::ActionAccel_EndType value) {
  
  end_type_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ActionAccel.end_type)
}

// double end_value = 4;
inline void ActionAccel::clear_end_value() {
  end_value_ = 0;
}
inline double ActionAccel::end_value() const {
  // @@protoc_insertion_point(field_get:sim_msg.ActionAccel.end_value)
  return end_value_;
}
inline void ActionAccel::set_end_value(double value) {
  
  end_value_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ActionAccel.end_value)
}

// -------------------------------------------------------------------

// ActionLaneChange

// .sim_msg.ActionLaneChange.Dir dir = 1;
inline void ActionLaneChange::clear_dir() {
  dir_ = 0;
}
inline ::sim_msg::ActionLaneChange_Dir ActionLaneChange::dir() const {
  // @@protoc_insertion_point(field_get:sim_msg.ActionLaneChange.dir)
  return static_cast< ::sim_msg::ActionLaneChange_Dir >(dir_);
}
inline void ActionLaneChange::set_dir(::sim_msg::ActionLaneChange_Dir value) {
  
  dir_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ActionLaneChange.dir)
}

// double duration = 2;
inline void ActionLaneChange::clear_duration() {
  duration_ = 0;
}
inline double ActionLaneChange::duration() const {
  // @@protoc_insertion_point(field_get:sim_msg.ActionLaneChange.duration)
  return duration_;
}
inline void ActionLaneChange::set_duration(double value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ActionLaneChange.duration)
}

// double offset = 3;
inline void ActionLaneChange::clear_offset() {
  offset_ = 0;
}
inline double ActionLaneChange::offset() const {
  // @@protoc_insertion_point(field_get:sim_msg.ActionLaneChange.offset)
  return offset_;
}
inline void ActionLaneChange::set_offset(double value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ActionLaneChange.offset)
}

// -------------------------------------------------------------------

// ActionLateralDistance

// double distance = 1;
inline void ActionLateralDistance::clear_distance() {
  distance_ = 0;
}
inline double ActionLateralDistance::distance() const {
  // @@protoc_insertion_point(field_get:sim_msg.ActionLateralDistance.distance)
  return distance_;
}
inline void ActionLateralDistance::set_distance(double value) {
  
  distance_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ActionLateralDistance.distance)
}

// bool freespace = 2;
inline void ActionLateralDistance::clear_freespace() {
  freespace_ = false;
}
inline bool ActionLateralDistance::freespace() const {
  // @@protoc_insertion_point(field_get:sim_msg.ActionLateralDistance.freespace)
  return freespace_;
}
inline void ActionLateralDistance::set_freespace(bool value) {
  
  freespace_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ActionLateralDistance.freespace)
}

// bool continuous = 3;
inline void ActionLateralDistance::clear_continuous() {
  continuous_ = false;
}
inline bool ActionLateralDistance::continuous() const {
  // @@protoc_insertion_point(field_get:sim_msg.ActionLateralDistance.continuous)
  return continuous_;
}
inline void ActionLateralDistance::set_continuous(bool value) {
  
  continuous_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ActionLateralDistance.continuous)
}

// .sim_msg.DynamicConstraints dynamic_constraints = 4;
inline bool ActionLateralDistance::has_dynamic_constraints() const {
  return this != internal_default_instance() && dynamic_constraints_ != nullptr;
}
inline void ActionLateralDistance::clear_dynamic_constraints() {
  if (GetArenaNoVirtual() == nullptr && dynamic_constraints_ != nullptr) {
    delete dynamic_constraints_;
  }
  dynamic_constraints_ = nullptr;
}
inline const ::sim_msg::DynamicConstraints& ActionLateralDistance::dynamic_constraints() const {
  const ::sim_msg::DynamicConstraints* p = dynamic_constraints_;
  // @@protoc_insertion_point(field_get:sim_msg.ActionLateralDistance.dynamic_constraints)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::DynamicConstraints*>(
      &::sim_msg::_DynamicConstraints_default_instance_);
}
inline ::sim_msg::DynamicConstraints* ActionLateralDistance::release_dynamic_constraints() {
  // @@protoc_insertion_point(field_release:sim_msg.ActionLateralDistance.dynamic_constraints)
  
  ::sim_msg::DynamicConstraints* temp = dynamic_constraints_;
  dynamic_constraints_ = nullptr;
  return temp;
}
inline ::sim_msg::DynamicConstraints* ActionLateralDistance::mutable_dynamic_constraints() {
  
  if (dynamic_constraints_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::DynamicConstraints>(GetArenaNoVirtual());
    dynamic_constraints_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.ActionLateralDistance.dynamic_constraints)
  return dynamic_constraints_;
}
inline void ActionLateralDistance::set_allocated_dynamic_constraints(::sim_msg::DynamicConstraints* dynamic_constraints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dynamic_constraints_;
  }
  if (dynamic_constraints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dynamic_constraints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dynamic_constraints, submessage_arena);
    }
    
  } else {
    
  }
  dynamic_constraints_ = dynamic_constraints;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.ActionLateralDistance.dynamic_constraints)
}

// -------------------------------------------------------------------

// Trigger

// string name = 1;
inline void Trigger::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Trigger::name() const {
  // @@protoc_insertion_point(field_get:sim_msg.Trigger.name)
  return name_.GetNoArena();
}
inline void Trigger::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.Trigger.name)
}
inline void Trigger::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.Trigger.name)
}
inline void Trigger::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.Trigger.name)
}
inline void Trigger::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.Trigger.name)
}
inline std::string* Trigger::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.Trigger.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Trigger::release_name() {
  // @@protoc_insertion_point(field_release:sim_msg.Trigger.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Trigger::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Trigger.name)
}

// repeated .sim_msg.Condition conditions = 2;
inline int Trigger::conditions_size() const {
  return conditions_.size();
}
inline void Trigger::clear_conditions() {
  conditions_.Clear();
}
inline ::sim_msg::Condition* Trigger::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:sim_msg.Trigger.conditions)
  return conditions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Condition >*
Trigger::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:sim_msg.Trigger.conditions)
  return &conditions_;
}
inline const ::sim_msg::Condition& Trigger::conditions(int index) const {
  // @@protoc_insertion_point(field_get:sim_msg.Trigger.conditions)
  return conditions_.Get(index);
}
inline ::sim_msg::Condition* Trigger::add_conditions() {
  // @@protoc_insertion_point(field_add:sim_msg.Trigger.conditions)
  return conditions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Condition >&
Trigger::conditions() const {
  // @@protoc_insertion_point(field_list:sim_msg.Trigger.conditions)
  return conditions_;
}

// -------------------------------------------------------------------

// Action

// string entity_ref = 1;
inline void Action::clear_entity_ref() {
  entity_ref_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Action::entity_ref() const {
  // @@protoc_insertion_point(field_get:sim_msg.Action.entity_ref)
  return entity_ref_.GetNoArena();
}
inline void Action::set_entity_ref(const std::string& value) {
  
  entity_ref_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.Action.entity_ref)
}
inline void Action::set_entity_ref(std::string&& value) {
  
  entity_ref_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.Action.entity_ref)
}
inline void Action::set_entity_ref(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  entity_ref_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.Action.entity_ref)
}
inline void Action::set_entity_ref(const char* value, size_t size) {
  
  entity_ref_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.Action.entity_ref)
}
inline std::string* Action::mutable_entity_ref() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.Action.entity_ref)
  return entity_ref_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Action::release_entity_ref() {
  // @@protoc_insertion_point(field_release:sim_msg.Action.entity_ref)
  
  return entity_ref_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Action::set_allocated_entity_ref(std::string* entity_ref) {
  if (entity_ref != nullptr) {
    
  } else {
    
  }
  entity_ref_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), entity_ref);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Action.entity_ref)
}

// .sim_msg.ActionSpeed speed = 2;
inline bool Action::has_speed() const {
  return action_case() == kSpeed;
}
inline void Action::set_has_speed() {
  _oneof_case_[0] = kSpeed;
}
inline void Action::clear_speed() {
  if (has_speed()) {
    delete action_.speed_;
    clear_has_action();
  }
}
inline ::sim_msg::ActionSpeed* Action::release_speed() {
  // @@protoc_insertion_point(field_release:sim_msg.Action.speed)
  if (has_speed()) {
    clear_has_action();
      ::sim_msg::ActionSpeed* temp = action_.speed_;
    action_.speed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sim_msg::ActionSpeed& Action::speed() const {
  // @@protoc_insertion_point(field_get:sim_msg.Action.speed)
  return has_speed()
      ? *action_.speed_
      : *reinterpret_cast< ::sim_msg::ActionSpeed*>(&::sim_msg::_ActionSpeed_default_instance_);
}
inline ::sim_msg::ActionSpeed* Action::mutable_speed() {
  if (!has_speed()) {
    clear_action();
    set_has_speed();
    action_.speed_ = CreateMaybeMessage< ::sim_msg::ActionSpeed >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Action.speed)
  return action_.speed_;
}

// .sim_msg.ActionAccel accel = 3;
inline bool Action::has_accel() const {
  return action_case() == kAccel;
}
inline void Action::set_has_accel() {
  _oneof_case_[0] = kAccel;
}
inline void Action::clear_accel() {
  if (has_accel()) {
    delete action_.accel_;
    clear_has_action();
  }
}
inline ::sim_msg::ActionAccel* Action::release_accel() {
  // @@protoc_insertion_point(field_release:sim_msg.Action.accel)
  if (has_accel()) {
    clear_has_action();
      ::sim_msg::ActionAccel* temp = action_.accel_;
    action_.accel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sim_msg::ActionAccel& Action::accel() const {
  // @@protoc_insertion_point(field_get:sim_msg.Action.accel)
  return has_accel()
      ? *action_.accel_
      : *reinterpret_cast< ::sim_msg::ActionAccel*>(&::sim_msg::_ActionAccel_default_instance_);
}
inline ::sim_msg::ActionAccel* Action::mutable_accel() {
  if (!has_accel()) {
    clear_action();
    set_has_accel();
    action_.accel_ = CreateMaybeMessage< ::sim_msg::ActionAccel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Action.accel)
  return action_.accel_;
}

// .sim_msg.ActionLaneChange lane_change = 4;
inline bool Action::has_lane_change() const {
  return action_case() == kLaneChange;
}
inline void Action::set_has_lane_change() {
  _oneof_case_[0] = kLaneChange;
}
inline void Action::clear_lane_change() {
  if (has_lane_change()) {
    delete action_.lane_change_;
    clear_has_action();
  }
}
inline ::sim_msg::ActionLaneChange* Action::release_lane_change() {
  // @@protoc_insertion_point(field_release:sim_msg.Action.lane_change)
  if (has_lane_change()) {
    clear_has_action();
      ::sim_msg::ActionLaneChange* temp = action_.lane_change_;
    action_.lane_change_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sim_msg::ActionLaneChange& Action::lane_change() const {
  // @@protoc_insertion_point(field_get:sim_msg.Action.lane_change)
  return has_lane_change()
      ? *action_.lane_change_
      : *reinterpret_cast< ::sim_msg::ActionLaneChange*>(&::sim_msg::_ActionLaneChange_default_instance_);
}
inline ::sim_msg::ActionLaneChange* Action::mutable_lane_change() {
  if (!has_lane_change()) {
    clear_action();
    set_has_lane_change();
    action_.lane_change_ = CreateMaybeMessage< ::sim_msg::ActionLaneChange >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Action.lane_change)
  return action_.lane_change_;
}

// .sim_msg.ActionLateralDistance lateral_distance = 5;
inline bool Action::has_lateral_distance() const {
  return action_case() == kLateralDistance;
}
inline void Action::set_has_lateral_distance() {
  _oneof_case_[0] = kLateralDistance;
}
inline void Action::clear_lateral_distance() {
  if (has_lateral_distance()) {
    delete action_.lateral_distance_;
    clear_has_action();
  }
}
inline ::sim_msg::ActionLateralDistance* Action::release_lateral_distance() {
  // @@protoc_insertion_point(field_release:sim_msg.Action.lateral_distance)
  if (has_lateral_distance()) {
    clear_has_action();
      ::sim_msg::ActionLateralDistance* temp = action_.lateral_distance_;
    action_.lateral_distance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sim_msg::ActionLateralDistance& Action::lateral_distance() const {
  // @@protoc_insertion_point(field_get:sim_msg.Action.lateral_distance)
  return has_lateral_distance()
      ? *action_.lateral_distance_
      : *reinterpret_cast< ::sim_msg::ActionLateralDistance*>(&::sim_msg::_ActionLateralDistance_default_instance_);
}
inline ::sim_msg::ActionLateralDistance* Action::mutable_lateral_distance() {
  if (!has_lateral_distance()) {
    clear_action();
    set_has_lateral_distance();
    action_.lateral_distance_ = CreateMaybeMessage< ::sim_msg::ActionLateralDistance >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Action.lateral_distance)
  return action_.lateral_distance_;
}

// .sim_msg.Status status = 6;
inline bool Action::has_status() const {
  return action_case() == kStatus;
}
inline void Action::set_has_status() {
  _oneof_case_[0] = kStatus;
}
inline ::sim_msg::Status* Action::release_status() {
  // @@protoc_insertion_point(field_release:sim_msg.Action.status)
  if (has_status()) {
    clear_has_action();
      ::sim_msg::Status* temp = action_.status_;
    action_.status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sim_msg::Status& Action::status() const {
  // @@protoc_insertion_point(field_get:sim_msg.Action.status)
  return has_status()
      ? *action_.status_
      : *reinterpret_cast< ::sim_msg::Status*>(&::sim_msg::_Status_default_instance_);
}
inline ::sim_msg::Status* Action::mutable_status() {
  if (!has_status()) {
    clear_action();
    set_has_status();
    action_.status_ = CreateMaybeMessage< ::sim_msg::Status >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Action.status)
  return action_.status_;
}

// .sim_msg.Activate activate = 7;
inline bool Action::has_activate() const {
  return action_case() == kActivate;
}
inline void Action::set_has_activate() {
  _oneof_case_[0] = kActivate;
}
inline ::sim_msg::Activate* Action::release_activate() {
  // @@protoc_insertion_point(field_release:sim_msg.Action.activate)
  if (has_activate()) {
    clear_has_action();
      ::sim_msg::Activate* temp = action_.activate_;
    action_.activate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sim_msg::Activate& Action::activate() const {
  // @@protoc_insertion_point(field_get:sim_msg.Action.activate)
  return has_activate()
      ? *action_.activate_
      : *reinterpret_cast< ::sim_msg::Activate*>(&::sim_msg::_Activate_default_instance_);
}
inline ::sim_msg::Activate* Action::mutable_activate() {
  if (!has_activate()) {
    clear_action();
    set_has_activate();
    action_.activate_ = CreateMaybeMessage< ::sim_msg::Activate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Action.activate)
  return action_.activate_;
}

// .sim_msg.Assign assign = 8;
inline bool Action::has_assign() const {
  return action_case() == kAssign;
}
inline void Action::set_has_assign() {
  _oneof_case_[0] = kAssign;
}
inline ::sim_msg::Assign* Action::release_assign() {
  // @@protoc_insertion_point(field_release:sim_msg.Action.assign)
  if (has_assign()) {
    clear_has_action();
      ::sim_msg::Assign* temp = action_.assign_;
    action_.assign_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sim_msg::Assign& Action::assign() const {
  // @@protoc_insertion_point(field_get:sim_msg.Action.assign)
  return has_assign()
      ? *action_.assign_
      : *reinterpret_cast< ::sim_msg::Assign*>(&::sim_msg::_Assign_default_instance_);
}
inline ::sim_msg::Assign* Action::mutable_assign() {
  if (!has_assign()) {
    clear_action();
    set_has_assign();
    action_.assign_ = CreateMaybeMessage< ::sim_msg::Assign >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Action.assign)
  return action_.assign_;
}

// .sim_msg.Override override = 9;
inline bool Action::has_override() const {
  return action_case() == kOverride;
}
inline void Action::set_has_override() {
  _oneof_case_[0] = kOverride;
}
inline ::sim_msg::Override* Action::release_override() {
  // @@protoc_insertion_point(field_release:sim_msg.Action.override)
  if (has_override()) {
    clear_has_action();
      ::sim_msg::Override* temp = action_.override_;
    action_.override_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sim_msg::Override& Action::override() const {
  // @@protoc_insertion_point(field_get:sim_msg.Action.override)
  return has_override()
      ? *action_.override_
      : *reinterpret_cast< ::sim_msg::Override*>(&::sim_msg::_Override_default_instance_);
}
inline ::sim_msg::Override* Action::mutable_override() {
  if (!has_override()) {
    clear_action();
    set_has_override();
    action_.override_ = CreateMaybeMessage< ::sim_msg::Override >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Action.override)
  return action_.override_;
}

// .sim_msg.Command command = 10;
inline bool Action::has_command() const {
  return action_case() == kCommand;
}
inline void Action::set_has_command() {
  _oneof_case_[0] = kCommand;
}
inline ::sim_msg::Command* Action::release_command() {
  // @@protoc_insertion_point(field_release:sim_msg.Action.command)
  if (has_command()) {
    clear_has_action();
      ::sim_msg::Command* temp = action_.command_;
    action_.command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sim_msg::Command& Action::command() const {
  // @@protoc_insertion_point(field_get:sim_msg.Action.command)
  return has_command()
      ? *action_.command_
      : *reinterpret_cast< ::sim_msg::Command*>(&::sim_msg::_Command_default_instance_);
}
inline ::sim_msg::Command* Action::mutable_command() {
  if (!has_command()) {
    clear_action();
    set_has_command();
    action_.command_ = CreateMaybeMessage< ::sim_msg::Command >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Action.command)
  return action_.command_;
}

inline bool Action::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void Action::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline Action::ActionCase Action::action_case() const {
  return Action::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Event

// int32 id = 1;
inline void Event::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Event::id() const {
  // @@protoc_insertion_point(field_get:sim_msg.Event.id)
  return id_;
}
inline void Event::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Event.id)
}

// string name = 2;
inline void Event::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Event::name() const {
  // @@protoc_insertion_point(field_get:sim_msg.Event.name)
  return name_.GetNoArena();
}
inline void Event::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.Event.name)
}
inline void Event::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.Event.name)
}
inline void Event::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.Event.name)
}
inline void Event::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.Event.name)
}
inline std::string* Event::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.Event.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Event::release_name() {
  // @@protoc_insertion_point(field_release:sim_msg.Event.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Event::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Event.name)
}

// .sim_msg.Trigger trigger = 3;
inline bool Event::has_trigger() const {
  return this != internal_default_instance() && trigger_ != nullptr;
}
inline void Event::clear_trigger() {
  if (GetArenaNoVirtual() == nullptr && trigger_ != nullptr) {
    delete trigger_;
  }
  trigger_ = nullptr;
}
inline const ::sim_msg::Trigger& Event::trigger() const {
  const ::sim_msg::Trigger* p = trigger_;
  // @@protoc_insertion_point(field_get:sim_msg.Event.trigger)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Trigger*>(
      &::sim_msg::_Trigger_default_instance_);
}
inline ::sim_msg::Trigger* Event::release_trigger() {
  // @@protoc_insertion_point(field_release:sim_msg.Event.trigger)
  
  ::sim_msg::Trigger* temp = trigger_;
  trigger_ = nullptr;
  return temp;
}
inline ::sim_msg::Trigger* Event::mutable_trigger() {
  
  if (trigger_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Trigger>(GetArenaNoVirtual());
    trigger_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Event.trigger)
  return trigger_;
}
inline void Event::set_allocated_trigger(::sim_msg::Trigger* trigger) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete trigger_;
  }
  if (trigger) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      trigger = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trigger, submessage_arena);
    }
    
  } else {
    
  }
  trigger_ = trigger;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Event.trigger)
}

// repeated .sim_msg.Action actions = 4;
inline int Event::actions_size() const {
  return actions_.size();
}
inline void Event::clear_actions() {
  actions_.Clear();
}
inline ::sim_msg::Action* Event::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:sim_msg.Event.actions)
  return actions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Action >*
Event::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:sim_msg.Event.actions)
  return &actions_;
}
inline const ::sim_msg::Action& Event::actions(int index) const {
  // @@protoc_insertion_point(field_get:sim_msg.Event.actions)
  return actions_.Get(index);
}
inline ::sim_msg::Action* Event::add_actions() {
  // @@protoc_insertion_point(field_add:sim_msg.Event.actions)
  return actions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Action >&
Event::actions() const {
  // @@protoc_insertion_point(field_list:sim_msg.Event.actions)
  return actions_;
}

// string info = 5;
inline void Event::clear_info() {
  info_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Event::info() const {
  // @@protoc_insertion_point(field_get:sim_msg.Event.info)
  return info_.GetNoArena();
}
inline void Event::set_info(const std::string& value) {
  
  info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.Event.info)
}
inline void Event::set_info(std::string&& value) {
  
  info_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.Event.info)
}
inline void Event::set_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.Event.info)
}
inline void Event::set_info(const char* value, size_t size) {
  
  info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.Event.info)
}
inline std::string* Event::mutable_info() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.Event.info)
  return info_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Event::release_info() {
  // @@protoc_insertion_point(field_release:sim_msg.Event.info)
  
  return info_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Event::set_allocated_info(std::string* info) {
  if (info != nullptr) {
    
  } else {
    
  }
  info_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Event.info)
}

// -------------------------------------------------------------------

// PhysicleCommon

// .sim_msg.BoundingBox bounding_box = 1;
inline bool PhysicleCommon::has_bounding_box() const {
  return this != internal_default_instance() && bounding_box_ != nullptr;
}
inline void PhysicleCommon::clear_bounding_box() {
  if (GetArenaNoVirtual() == nullptr && bounding_box_ != nullptr) {
    delete bounding_box_;
  }
  bounding_box_ = nullptr;
}
inline const ::sim_msg::BoundingBox& PhysicleCommon::bounding_box() const {
  const ::sim_msg::BoundingBox* p = bounding_box_;
  // @@protoc_insertion_point(field_get:sim_msg.PhysicleCommon.bounding_box)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::BoundingBox*>(
      &::sim_msg::_BoundingBox_default_instance_);
}
inline ::sim_msg::BoundingBox* PhysicleCommon::release_bounding_box() {
  // @@protoc_insertion_point(field_release:sim_msg.PhysicleCommon.bounding_box)
  
  ::sim_msg::BoundingBox* temp = bounding_box_;
  bounding_box_ = nullptr;
  return temp;
}
inline ::sim_msg::BoundingBox* PhysicleCommon::mutable_bounding_box() {
  
  if (bounding_box_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::BoundingBox>(GetArenaNoVirtual());
    bounding_box_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.PhysicleCommon.bounding_box)
  return bounding_box_;
}
inline void PhysicleCommon::set_allocated_bounding_box(::sim_msg::BoundingBox* bounding_box) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete bounding_box_;
  }
  if (bounding_box) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bounding_box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bounding_box, submessage_arena);
    }
    
  } else {
    
  }
  bounding_box_ = bounding_box;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.PhysicleCommon.bounding_box)
}

// .sim_msg.Color color = 2;
inline void PhysicleCommon::clear_color() {
  color_ = 0;
}
inline ::sim_msg::Color PhysicleCommon::color() const {
  // @@protoc_insertion_point(field_get:sim_msg.PhysicleCommon.color)
  return static_cast< ::sim_msg::Color >(color_);
}
inline void PhysicleCommon::set_color(::sim_msg::Color value) {
  
  color_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.PhysicleCommon.color)
}

// double mass = 3;
inline void PhysicleCommon::clear_mass() {
  mass_ = 0;
}
inline double PhysicleCommon::mass() const {
  // @@protoc_insertion_point(field_get:sim_msg.PhysicleCommon.mass)
  return mass_;
}
inline void PhysicleCommon::set_mass(double value) {
  
  mass_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.PhysicleCommon.mass)
}

// int64 model_id = 4;
inline void PhysicleCommon::clear_model_id() {
  model_id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PhysicleCommon::model_id() const {
  // @@protoc_insertion_point(field_get:sim_msg.PhysicleCommon.model_id)
  return model_id_;
}
inline void PhysicleCommon::set_model_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  model_id_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.PhysicleCommon.model_id)
}

// string model_3d = 5;
inline void PhysicleCommon::clear_model_3d() {
  model_3d_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PhysicleCommon::model_3d() const {
  // @@protoc_insertion_point(field_get:sim_msg.PhysicleCommon.model_3d)
  return model_3d_.GetNoArena();
}
inline void PhysicleCommon::set_model_3d(const std::string& value) {
  
  model_3d_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.PhysicleCommon.model_3d)
}
inline void PhysicleCommon::set_model_3d(std::string&& value) {
  
  model_3d_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.PhysicleCommon.model_3d)
}
inline void PhysicleCommon::set_model_3d(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  model_3d_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.PhysicleCommon.model_3d)
}
inline void PhysicleCommon::set_model_3d(const char* value, size_t size) {
  
  model_3d_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.PhysicleCommon.model_3d)
}
inline std::string* PhysicleCommon::mutable_model_3d() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.PhysicleCommon.model_3d)
  return model_3d_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PhysicleCommon::release_model_3d() {
  // @@protoc_insertion_point(field_release:sim_msg.PhysicleCommon.model_3d)
  
  return model_3d_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PhysicleCommon::set_allocated_model_3d(std::string* model_3d) {
  if (model_3d != nullptr) {
    
  } else {
    
  }
  model_3d_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model_3d);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.PhysicleCommon.model_3d)
}

// -------------------------------------------------------------------

// PhysicleEgo

// .sim_msg.PhysicleCommon common = 1;
inline bool PhysicleEgo::has_common() const {
  return this != internal_default_instance() && common_ != nullptr;
}
inline void PhysicleEgo::clear_common() {
  if (GetArenaNoVirtual() == nullptr && common_ != nullptr) {
    delete common_;
  }
  common_ = nullptr;
}
inline const ::sim_msg::PhysicleCommon& PhysicleEgo::common() const {
  const ::sim_msg::PhysicleCommon* p = common_;
  // @@protoc_insertion_point(field_get:sim_msg.PhysicleEgo.common)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::PhysicleCommon*>(
      &::sim_msg::_PhysicleCommon_default_instance_);
}
inline ::sim_msg::PhysicleCommon* PhysicleEgo::release_common() {
  // @@protoc_insertion_point(field_release:sim_msg.PhysicleEgo.common)
  
  ::sim_msg::PhysicleCommon* temp = common_;
  common_ = nullptr;
  return temp;
}
inline ::sim_msg::PhysicleCommon* PhysicleEgo::mutable_common() {
  
  if (common_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::PhysicleCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.PhysicleEgo.common)
  return common_;
}
inline void PhysicleEgo::set_allocated_common(::sim_msg::PhysicleCommon* common) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete common_;
  }
  if (common) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      common = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.PhysicleEgo.common)
}

// .sim_msg.Performance performance = 2;
inline bool PhysicleEgo::has_performance() const {
  return this != internal_default_instance() && performance_ != nullptr;
}
inline void PhysicleEgo::clear_performance() {
  if (GetArenaNoVirtual() == nullptr && performance_ != nullptr) {
    delete performance_;
  }
  performance_ = nullptr;
}
inline const ::sim_msg::Performance& PhysicleEgo::performance() const {
  const ::sim_msg::Performance* p = performance_;
  // @@protoc_insertion_point(field_get:sim_msg.PhysicleEgo.performance)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Performance*>(
      &::sim_msg::_Performance_default_instance_);
}
inline ::sim_msg::Performance* PhysicleEgo::release_performance() {
  // @@protoc_insertion_point(field_release:sim_msg.PhysicleEgo.performance)
  
  ::sim_msg::Performance* temp = performance_;
  performance_ = nullptr;
  return temp;
}
inline ::sim_msg::Performance* PhysicleEgo::mutable_performance() {
  
  if (performance_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Performance>(GetArenaNoVirtual());
    performance_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.PhysicleEgo.performance)
  return performance_;
}
inline void PhysicleEgo::set_allocated_performance(::sim_msg::Performance* performance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete performance_;
  }
  if (performance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      performance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, performance, submessage_arena);
    }
    
  } else {
    
  }
  performance_ = performance;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.PhysicleEgo.performance)
}

// .sim_msg.VehicleGeometory geometory = 3;
inline bool PhysicleEgo::has_geometory() const {
  return this != internal_default_instance() && geometory_ != nullptr;
}
inline const ::sim_msg::VehicleGeometory& PhysicleEgo::geometory() const {
  const ::sim_msg::VehicleGeometory* p = geometory_;
  // @@protoc_insertion_point(field_get:sim_msg.PhysicleEgo.geometory)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::VehicleGeometory*>(
      &::sim_msg::_VehicleGeometory_default_instance_);
}
inline ::sim_msg::VehicleGeometory* PhysicleEgo::release_geometory() {
  // @@protoc_insertion_point(field_release:sim_msg.PhysicleEgo.geometory)
  
  ::sim_msg::VehicleGeometory* temp = geometory_;
  geometory_ = nullptr;
  return temp;
}
inline ::sim_msg::VehicleGeometory* PhysicleEgo::mutable_geometory() {
  
  if (geometory_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::VehicleGeometory>(GetArenaNoVirtual());
    geometory_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.PhysicleEgo.geometory)
  return geometory_;
}
inline void PhysicleEgo::set_allocated_geometory(::sim_msg::VehicleGeometory* geometory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(geometory_);
  }
  if (geometory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      geometory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geometory, submessage_arena);
    }
    
  } else {
    
  }
  geometory_ = geometory;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.PhysicleEgo.geometory)
}

// -------------------------------------------------------------------

// PhysicleVehicle

// .sim_msg.PhysicleCommon common = 1;
inline bool PhysicleVehicle::has_common() const {
  return this != internal_default_instance() && common_ != nullptr;
}
inline void PhysicleVehicle::clear_common() {
  if (GetArenaNoVirtual() == nullptr && common_ != nullptr) {
    delete common_;
  }
  common_ = nullptr;
}
inline const ::sim_msg::PhysicleCommon& PhysicleVehicle::common() const {
  const ::sim_msg::PhysicleCommon* p = common_;
  // @@protoc_insertion_point(field_get:sim_msg.PhysicleVehicle.common)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::PhysicleCommon*>(
      &::sim_msg::_PhysicleCommon_default_instance_);
}
inline ::sim_msg::PhysicleCommon* PhysicleVehicle::release_common() {
  // @@protoc_insertion_point(field_release:sim_msg.PhysicleVehicle.common)
  
  ::sim_msg::PhysicleCommon* temp = common_;
  common_ = nullptr;
  return temp;
}
inline ::sim_msg::PhysicleCommon* PhysicleVehicle::mutable_common() {
  
  if (common_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::PhysicleCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.PhysicleVehicle.common)
  return common_;
}
inline void PhysicleVehicle::set_allocated_common(::sim_msg::PhysicleCommon* common) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete common_;
  }
  if (common) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      common = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.PhysicleVehicle.common)
}

// .sim_msg.Performance performance = 2;
inline bool PhysicleVehicle::has_performance() const {
  return this != internal_default_instance() && performance_ != nullptr;
}
inline void PhysicleVehicle::clear_performance() {
  if (GetArenaNoVirtual() == nullptr && performance_ != nullptr) {
    delete performance_;
  }
  performance_ = nullptr;
}
inline const ::sim_msg::Performance& PhysicleVehicle::performance() const {
  const ::sim_msg::Performance* p = performance_;
  // @@protoc_insertion_point(field_get:sim_msg.PhysicleVehicle.performance)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Performance*>(
      &::sim_msg::_Performance_default_instance_);
}
inline ::sim_msg::Performance* PhysicleVehicle::release_performance() {
  // @@protoc_insertion_point(field_release:sim_msg.PhysicleVehicle.performance)
  
  ::sim_msg::Performance* temp = performance_;
  performance_ = nullptr;
  return temp;
}
inline ::sim_msg::Performance* PhysicleVehicle::mutable_performance() {
  
  if (performance_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Performance>(GetArenaNoVirtual());
    performance_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.PhysicleVehicle.performance)
  return performance_;
}
inline void PhysicleVehicle::set_allocated_performance(::sim_msg::Performance* performance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete performance_;
  }
  if (performance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      performance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, performance, submessage_arena);
    }
    
  } else {
    
  }
  performance_ = performance;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.PhysicleVehicle.performance)
}

// .sim_msg.VehicleGeometory geometory = 3;
inline bool PhysicleVehicle::has_geometory() const {
  return this != internal_default_instance() && geometory_ != nullptr;
}
inline const ::sim_msg::VehicleGeometory& PhysicleVehicle::geometory() const {
  const ::sim_msg::VehicleGeometory* p = geometory_;
  // @@protoc_insertion_point(field_get:sim_msg.PhysicleVehicle.geometory)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::VehicleGeometory*>(
      &::sim_msg::_VehicleGeometory_default_instance_);
}
inline ::sim_msg::VehicleGeometory* PhysicleVehicle::release_geometory() {
  // @@protoc_insertion_point(field_release:sim_msg.PhysicleVehicle.geometory)
  
  ::sim_msg::VehicleGeometory* temp = geometory_;
  geometory_ = nullptr;
  return temp;
}
inline ::sim_msg::VehicleGeometory* PhysicleVehicle::mutable_geometory() {
  
  if (geometory_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::VehicleGeometory>(GetArenaNoVirtual());
    geometory_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.PhysicleVehicle.geometory)
  return geometory_;
}
inline void PhysicleVehicle::set_allocated_geometory(::sim_msg::VehicleGeometory* geometory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(geometory_);
  }
  if (geometory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      geometory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geometory, submessage_arena);
    }
    
  } else {
    
  }
  geometory_ = geometory;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.PhysicleVehicle.geometory)
}

// -------------------------------------------------------------------

// PhysicleVru

// .sim_msg.PhysicleCommon common = 1;
inline bool PhysicleVru::has_common() const {
  return this != internal_default_instance() && common_ != nullptr;
}
inline void PhysicleVru::clear_common() {
  if (GetArenaNoVirtual() == nullptr && common_ != nullptr) {
    delete common_;
  }
  common_ = nullptr;
}
inline const ::sim_msg::PhysicleCommon& PhysicleVru::common() const {
  const ::sim_msg::PhysicleCommon* p = common_;
  // @@protoc_insertion_point(field_get:sim_msg.PhysicleVru.common)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::PhysicleCommon*>(
      &::sim_msg::_PhysicleCommon_default_instance_);
}
inline ::sim_msg::PhysicleCommon* PhysicleVru::release_common() {
  // @@protoc_insertion_point(field_release:sim_msg.PhysicleVru.common)
  
  ::sim_msg::PhysicleCommon* temp = common_;
  common_ = nullptr;
  return temp;
}
inline ::sim_msg::PhysicleCommon* PhysicleVru::mutable_common() {
  
  if (common_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::PhysicleCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.PhysicleVru.common)
  return common_;
}
inline void PhysicleVru::set_allocated_common(::sim_msg::PhysicleCommon* common) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete common_;
  }
  if (common) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      common = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.PhysicleVru.common)
}

// .sim_msg.Performance performance = 2;
inline bool PhysicleVru::has_performance() const {
  return this != internal_default_instance() && performance_ != nullptr;
}
inline void PhysicleVru::clear_performance() {
  if (GetArenaNoVirtual() == nullptr && performance_ != nullptr) {
    delete performance_;
  }
  performance_ = nullptr;
}
inline const ::sim_msg::Performance& PhysicleVru::performance() const {
  const ::sim_msg::Performance* p = performance_;
  // @@protoc_insertion_point(field_get:sim_msg.PhysicleVru.performance)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Performance*>(
      &::sim_msg::_Performance_default_instance_);
}
inline ::sim_msg::Performance* PhysicleVru::release_performance() {
  // @@protoc_insertion_point(field_release:sim_msg.PhysicleVru.performance)
  
  ::sim_msg::Performance* temp = performance_;
  performance_ = nullptr;
  return temp;
}
inline ::sim_msg::Performance* PhysicleVru::mutable_performance() {
  
  if (performance_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Performance>(GetArenaNoVirtual());
    performance_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.PhysicleVru.performance)
  return performance_;
}
inline void PhysicleVru::set_allocated_performance(::sim_msg::Performance* performance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete performance_;
  }
  if (performance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      performance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, performance, submessage_arena);
    }
    
  } else {
    
  }
  performance_ = performance;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.PhysicleVru.performance)
}

// -------------------------------------------------------------------

// InitialCommon

// repeated .sim_msg.Waypoint waypoints = 1;
inline int InitialCommon::waypoints_size() const {
  return waypoints_.size();
}
inline ::sim_msg::Waypoint* InitialCommon::mutable_waypoints(int index) {
  // @@protoc_insertion_point(field_mutable:sim_msg.InitialCommon.waypoints)
  return waypoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Waypoint >*
InitialCommon::mutable_waypoints() {
  // @@protoc_insertion_point(field_mutable_list:sim_msg.InitialCommon.waypoints)
  return &waypoints_;
}
inline const ::sim_msg::Waypoint& InitialCommon::waypoints(int index) const {
  // @@protoc_insertion_point(field_get:sim_msg.InitialCommon.waypoints)
  return waypoints_.Get(index);
}
inline ::sim_msg::Waypoint* InitialCommon::add_waypoints() {
  // @@protoc_insertion_point(field_add:sim_msg.InitialCommon.waypoints)
  return waypoints_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Waypoint >&
InitialCommon::waypoints() const {
  // @@protoc_insertion_point(field_list:sim_msg.InitialCommon.waypoints)
  return waypoints_;
}

// double speed = 2;
inline void InitialCommon::clear_speed() {
  speed_ = 0;
}
inline double InitialCommon::speed() const {
  // @@protoc_insertion_point(field_get:sim_msg.InitialCommon.speed)
  return speed_;
}
inline void InitialCommon::set_speed(double value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.InitialCommon.speed)
}

// -------------------------------------------------------------------

// InitialEgo

// .sim_msg.InitialCommon common = 1;
inline bool InitialEgo::has_common() const {
  return this != internal_default_instance() && common_ != nullptr;
}
inline void InitialEgo::clear_common() {
  if (GetArenaNoVirtual() == nullptr && common_ != nullptr) {
    delete common_;
  }
  common_ = nullptr;
}
inline const ::sim_msg::InitialCommon& InitialEgo::common() const {
  const ::sim_msg::InitialCommon* p = common_;
  // @@protoc_insertion_point(field_get:sim_msg.InitialEgo.common)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::InitialCommon*>(
      &::sim_msg::_InitialCommon_default_instance_);
}
inline ::sim_msg::InitialCommon* InitialEgo::release_common() {
  // @@protoc_insertion_point(field_release:sim_msg.InitialEgo.common)
  
  ::sim_msg::InitialCommon* temp = common_;
  common_ = nullptr;
  return temp;
}
inline ::sim_msg::InitialCommon* InitialEgo::mutable_common() {
  
  if (common_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::InitialCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.InitialEgo.common)
  return common_;
}
inline void InitialEgo::set_allocated_common(::sim_msg::InitialCommon* common) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete common_;
  }
  if (common) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      common = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.InitialEgo.common)
}

// .sim_msg.Assign assign = 3;
inline bool InitialEgo::has_assign() const {
  return this != internal_default_instance() && assign_ != nullptr;
}
inline const ::sim_msg::Assign& InitialEgo::assign() const {
  const ::sim_msg::Assign* p = assign_;
  // @@protoc_insertion_point(field_get:sim_msg.InitialEgo.assign)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Assign*>(
      &::sim_msg::_Assign_default_instance_);
}
inline ::sim_msg::Assign* InitialEgo::release_assign() {
  // @@protoc_insertion_point(field_release:sim_msg.InitialEgo.assign)
  
  ::sim_msg::Assign* temp = assign_;
  assign_ = nullptr;
  return temp;
}
inline ::sim_msg::Assign* InitialEgo::mutable_assign() {
  
  if (assign_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Assign>(GetArenaNoVirtual());
    assign_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.InitialEgo.assign)
  return assign_;
}
inline void InitialEgo::set_allocated_assign(::sim_msg::Assign* assign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(assign_);
  }
  if (assign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      assign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, assign, submessage_arena);
    }
    
  } else {
    
  }
  assign_ = assign;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.InitialEgo.assign)
}

// .sim_msg.Activate activate = 4;
inline bool InitialEgo::has_activate() const {
  return this != internal_default_instance() && activate_ != nullptr;
}
inline const ::sim_msg::Activate& InitialEgo::activate() const {
  const ::sim_msg::Activate* p = activate_;
  // @@protoc_insertion_point(field_get:sim_msg.InitialEgo.activate)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Activate*>(
      &::sim_msg::_Activate_default_instance_);
}
inline ::sim_msg::Activate* InitialEgo::release_activate() {
  // @@protoc_insertion_point(field_release:sim_msg.InitialEgo.activate)
  
  ::sim_msg::Activate* temp = activate_;
  activate_ = nullptr;
  return temp;
}
inline ::sim_msg::Activate* InitialEgo::mutable_activate() {
  
  if (activate_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Activate>(GetArenaNoVirtual());
    activate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.InitialEgo.activate)
  return activate_;
}
inline void InitialEgo::set_allocated_activate(::sim_msg::Activate* activate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(activate_);
  }
  if (activate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      activate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activate, submessage_arena);
    }
    
  } else {
    
  }
  activate_ = activate;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.InitialEgo.activate)
}

// bool trajectory_enabled = 5;
inline void InitialEgo::clear_trajectory_enabled() {
  trajectory_enabled_ = false;
}
inline bool InitialEgo::trajectory_enabled() const {
  // @@protoc_insertion_point(field_get:sim_msg.InitialEgo.trajectory_enabled)
  return trajectory_enabled_;
}
inline void InitialEgo::set_trajectory_enabled(bool value) {
  
  trajectory_enabled_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.InitialEgo.trajectory_enabled)
}

// -------------------------------------------------------------------

// InitialVehicle

// .sim_msg.InitialCommon common = 1;
inline bool InitialVehicle::has_common() const {
  return this != internal_default_instance() && common_ != nullptr;
}
inline void InitialVehicle::clear_common() {
  if (GetArenaNoVirtual() == nullptr && common_ != nullptr) {
    delete common_;
  }
  common_ = nullptr;
}
inline const ::sim_msg::InitialCommon& InitialVehicle::common() const {
  const ::sim_msg::InitialCommon* p = common_;
  // @@protoc_insertion_point(field_get:sim_msg.InitialVehicle.common)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::InitialCommon*>(
      &::sim_msg::_InitialCommon_default_instance_);
}
inline ::sim_msg::InitialCommon* InitialVehicle::release_common() {
  // @@protoc_insertion_point(field_release:sim_msg.InitialVehicle.common)
  
  ::sim_msg::InitialCommon* temp = common_;
  common_ = nullptr;
  return temp;
}
inline ::sim_msg::InitialCommon* InitialVehicle::mutable_common() {
  
  if (common_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::InitialCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.InitialVehicle.common)
  return common_;
}
inline void InitialVehicle::set_allocated_common(::sim_msg::InitialCommon* common) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete common_;
  }
  if (common) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      common = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.InitialVehicle.common)
}

// .sim_msg.BehaviorType behavior_type = 2;
inline void InitialVehicle::clear_behavior_type() {
  behavior_type_ = 0;
}
inline ::sim_msg::BehaviorType InitialVehicle::behavior_type() const {
  // @@protoc_insertion_point(field_get:sim_msg.InitialVehicle.behavior_type)
  return static_cast< ::sim_msg::BehaviorType >(behavior_type_);
}
inline void InitialVehicle::set_behavior_type(::sim_msg::BehaviorType value) {
  
  behavior_type_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.InitialVehicle.behavior_type)
}

// double aggress = 3;
inline void InitialVehicle::clear_aggress() {
  aggress_ = 0;
}
inline double InitialVehicle::aggress() const {
  // @@protoc_insertion_point(field_get:sim_msg.InitialVehicle.aggress)
  return aggress_;
}
inline void InitialVehicle::set_aggress(double value) {
  
  aggress_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.InitialVehicle.aggress)
}

// -------------------------------------------------------------------

// InitialVru

// .sim_msg.InitialCommon common = 1;
inline bool InitialVru::has_common() const {
  return this != internal_default_instance() && common_ != nullptr;
}
inline void InitialVru::clear_common() {
  if (GetArenaNoVirtual() == nullptr && common_ != nullptr) {
    delete common_;
  }
  common_ = nullptr;
}
inline const ::sim_msg::InitialCommon& InitialVru::common() const {
  const ::sim_msg::InitialCommon* p = common_;
  // @@protoc_insertion_point(field_get:sim_msg.InitialVru.common)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::InitialCommon*>(
      &::sim_msg::_InitialCommon_default_instance_);
}
inline ::sim_msg::InitialCommon* InitialVru::release_common() {
  // @@protoc_insertion_point(field_release:sim_msg.InitialVru.common)
  
  ::sim_msg::InitialCommon* temp = common_;
  common_ = nullptr;
  return temp;
}
inline ::sim_msg::InitialCommon* InitialVru::mutable_common() {
  
  if (common_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::InitialCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.InitialVru.common)
  return common_;
}
inline void InitialVru::set_allocated_common(::sim_msg::InitialCommon* common) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete common_;
  }
  if (common) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      common = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.InitialVru.common)
}

// .sim_msg.BehaviorType behavior_type = 2;
inline void InitialVru::clear_behavior_type() {
  behavior_type_ = 0;
}
inline ::sim_msg::BehaviorType InitialVru::behavior_type() const {
  // @@protoc_insertion_point(field_get:sim_msg.InitialVru.behavior_type)
  return static_cast< ::sim_msg::BehaviorType >(behavior_type_);
}
inline void InitialVru::set_behavior_type(::sim_msg::BehaviorType value) {
  
  behavior_type_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.InitialVru.behavior_type)
}

// double aggress = 3;
inline void InitialVru::clear_aggress() {
  aggress_ = 0;
}
inline double InitialVru::aggress() const {
  // @@protoc_insertion_point(field_get:sim_msg.InitialVru.aggress)
  return aggress_;
}
inline void InitialVru::set_aggress(double value) {
  
  aggress_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.InitialVru.aggress)
}

// -------------------------------------------------------------------

// Dynamic

// repeated .sim_msg.Event events = 1;
inline int Dynamic::events_size() const {
  return events_.size();
}
inline void Dynamic::clear_events() {
  events_.Clear();
}
inline ::sim_msg::Event* Dynamic::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:sim_msg.Dynamic.events)
  return events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Event >*
Dynamic::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:sim_msg.Dynamic.events)
  return &events_;
}
inline const ::sim_msg::Event& Dynamic::events(int index) const {
  // @@protoc_insertion_point(field_get:sim_msg.Dynamic.events)
  return events_.Get(index);
}
inline ::sim_msg::Event* Dynamic::add_events() {
  // @@protoc_insertion_point(field_add:sim_msg.Dynamic.events)
  return events_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Event >&
Dynamic::events() const {
  // @@protoc_insertion_point(field_list:sim_msg.Dynamic.events)
  return events_;
}

// -------------------------------------------------------------------

// Ego

// int64 id = 1;
inline void Ego::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Ego::id() const {
  // @@protoc_insertion_point(field_get:sim_msg.Ego.id)
  return id_;
}
inline void Ego::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Ego.id)
}

// string name = 2;
inline void Ego::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Ego::name() const {
  // @@protoc_insertion_point(field_get:sim_msg.Ego.name)
  return name_.GetNoArena();
}
inline void Ego::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.Ego.name)
}
inline void Ego::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.Ego.name)
}
inline void Ego::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.Ego.name)
}
inline void Ego::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.Ego.name)
}
inline std::string* Ego::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.Ego.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Ego::release_name() {
  // @@protoc_insertion_point(field_release:sim_msg.Ego.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Ego::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Ego.name)
}

// string objectname = 3;
inline void Ego::clear_objectname() {
  objectname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Ego::objectname() const {
  // @@protoc_insertion_point(field_get:sim_msg.Ego.objectname)
  return objectname_.GetNoArena();
}
inline void Ego::set_objectname(const std::string& value) {
  
  objectname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.Ego.objectname)
}
inline void Ego::set_objectname(std::string&& value) {
  
  objectname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.Ego.objectname)
}
inline void Ego::set_objectname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  objectname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.Ego.objectname)
}
inline void Ego::set_objectname(const char* value, size_t size) {
  
  objectname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.Ego.objectname)
}
inline std::string* Ego::mutable_objectname() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.Ego.objectname)
  return objectname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Ego::release_objectname() {
  // @@protoc_insertion_point(field_release:sim_msg.Ego.objectname)
  
  return objectname_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Ego::set_allocated_objectname(std::string* objectname) {
  if (objectname != nullptr) {
    
  } else {
    
  }
  objectname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), objectname);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Ego.objectname)
}

// .sim_msg.CategoryVehicle category = 4;
inline void Ego::clear_category() {
  category_ = 0;
}
inline ::sim_msg::CategoryVehicle Ego::category() const {
  // @@protoc_insertion_point(field_get:sim_msg.Ego.category)
  return static_cast< ::sim_msg::CategoryVehicle >(category_);
}
inline void Ego::set_category(::sim_msg::CategoryVehicle value) {
  
  category_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Ego.category)
}

// repeated .sim_msg.PhysicleEgo physicles = 5;
inline int Ego::physicles_size() const {
  return physicles_.size();
}
inline void Ego::clear_physicles() {
  physicles_.Clear();
}
inline ::sim_msg::PhysicleEgo* Ego::mutable_physicles(int index) {
  // @@protoc_insertion_point(field_mutable:sim_msg.Ego.physicles)
  return physicles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::PhysicleEgo >*
Ego::mutable_physicles() {
  // @@protoc_insertion_point(field_mutable_list:sim_msg.Ego.physicles)
  return &physicles_;
}
inline const ::sim_msg::PhysicleEgo& Ego::physicles(int index) const {
  // @@protoc_insertion_point(field_get:sim_msg.Ego.physicles)
  return physicles_.Get(index);
}
inline ::sim_msg::PhysicleEgo* Ego::add_physicles() {
  // @@protoc_insertion_point(field_add:sim_msg.Ego.physicles)
  return physicles_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::PhysicleEgo >&
Ego::physicles() const {
  // @@protoc_insertion_point(field_list:sim_msg.Ego.physicles)
  return physicles_;
}

// .sim_msg.InitialEgo initial = 6;
inline bool Ego::has_initial() const {
  return this != internal_default_instance() && initial_ != nullptr;
}
inline void Ego::clear_initial() {
  if (GetArenaNoVirtual() == nullptr && initial_ != nullptr) {
    delete initial_;
  }
  initial_ = nullptr;
}
inline const ::sim_msg::InitialEgo& Ego::initial() const {
  const ::sim_msg::InitialEgo* p = initial_;
  // @@protoc_insertion_point(field_get:sim_msg.Ego.initial)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::InitialEgo*>(
      &::sim_msg::_InitialEgo_default_instance_);
}
inline ::sim_msg::InitialEgo* Ego::release_initial() {
  // @@protoc_insertion_point(field_release:sim_msg.Ego.initial)
  
  ::sim_msg::InitialEgo* temp = initial_;
  initial_ = nullptr;
  return temp;
}
inline ::sim_msg::InitialEgo* Ego::mutable_initial() {
  
  if (initial_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::InitialEgo>(GetArenaNoVirtual());
    initial_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Ego.initial)
  return initial_;
}
inline void Ego::set_allocated_initial(::sim_msg::InitialEgo* initial) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete initial_;
  }
  if (initial) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      initial = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initial, submessage_arena);
    }
    
  } else {
    
  }
  initial_ = initial;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Ego.initial)
}

// .sim_msg.Dynamic dynamic = 7;
inline bool Ego::has_dynamic() const {
  return this != internal_default_instance() && dynamic_ != nullptr;
}
inline void Ego::clear_dynamic() {
  if (GetArenaNoVirtual() == nullptr && dynamic_ != nullptr) {
    delete dynamic_;
  }
  dynamic_ = nullptr;
}
inline const ::sim_msg::Dynamic& Ego::dynamic() const {
  const ::sim_msg::Dynamic* p = dynamic_;
  // @@protoc_insertion_point(field_get:sim_msg.Ego.dynamic)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Dynamic*>(
      &::sim_msg::_Dynamic_default_instance_);
}
inline ::sim_msg::Dynamic* Ego::release_dynamic() {
  // @@protoc_insertion_point(field_release:sim_msg.Ego.dynamic)
  
  ::sim_msg::Dynamic* temp = dynamic_;
  dynamic_ = nullptr;
  return temp;
}
inline ::sim_msg::Dynamic* Ego::mutable_dynamic() {
  
  if (dynamic_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Dynamic>(GetArenaNoVirtual());
    dynamic_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Ego.dynamic)
  return dynamic_;
}
inline void Ego::set_allocated_dynamic(::sim_msg::Dynamic* dynamic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dynamic_;
  }
  if (dynamic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dynamic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dynamic, submessage_arena);
    }
    
  } else {
    
  }
  dynamic_ = dynamic;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Ego.dynamic)
}

// .sim_msg.SensorGroup sensor_group = 8;
inline bool Ego::has_sensor_group() const {
  return this != internal_default_instance() && sensor_group_ != nullptr;
}
inline const ::sim_msg::SensorGroup& Ego::sensor_group() const {
  const ::sim_msg::SensorGroup* p = sensor_group_;
  // @@protoc_insertion_point(field_get:sim_msg.Ego.sensor_group)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::SensorGroup*>(
      &::sim_msg::_SensorGroup_default_instance_);
}
inline ::sim_msg::SensorGroup* Ego::release_sensor_group() {
  // @@protoc_insertion_point(field_release:sim_msg.Ego.sensor_group)
  
  ::sim_msg::SensorGroup* temp = sensor_group_;
  sensor_group_ = nullptr;
  return temp;
}
inline ::sim_msg::SensorGroup* Ego::mutable_sensor_group() {
  
  if (sensor_group_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::SensorGroup>(GetArenaNoVirtual());
    sensor_group_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Ego.sensor_group)
  return sensor_group_;
}
inline void Ego::set_allocated_sensor_group(::sim_msg::SensorGroup* sensor_group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sensor_group_);
  }
  if (sensor_group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sensor_group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_group, submessage_arena);
    }
    
  } else {
    
  }
  sensor_group_ = sensor_group;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Ego.sensor_group)
}

// string group = 9;
inline void Ego::clear_group() {
  group_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Ego::group() const {
  // @@protoc_insertion_point(field_get:sim_msg.Ego.group)
  return group_.GetNoArena();
}
inline void Ego::set_group(const std::string& value) {
  
  group_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.Ego.group)
}
inline void Ego::set_group(std::string&& value) {
  
  group_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.Ego.group)
}
inline void Ego::set_group(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  group_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.Ego.group)
}
inline void Ego::set_group(const char* value, size_t size) {
  
  group_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.Ego.group)
}
inline std::string* Ego::mutable_group() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.Ego.group)
  return group_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Ego::release_group() {
  // @@protoc_insertion_point(field_release:sim_msg.Ego.group)
  
  return group_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Ego::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    
  } else {
    
  }
  group_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Ego.group)
}

// -------------------------------------------------------------------

// Vehicle

// int64 id = 1;
inline void Vehicle::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Vehicle::id() const {
  // @@protoc_insertion_point(field_get:sim_msg.Vehicle.id)
  return id_;
}
inline void Vehicle::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Vehicle.id)
}

// string name = 2;
inline void Vehicle::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Vehicle::name() const {
  // @@protoc_insertion_point(field_get:sim_msg.Vehicle.name)
  return name_.GetNoArena();
}
inline void Vehicle::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.Vehicle.name)
}
inline void Vehicle::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.Vehicle.name)
}
inline void Vehicle::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.Vehicle.name)
}
inline void Vehicle::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.Vehicle.name)
}
inline std::string* Vehicle::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.Vehicle.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Vehicle::release_name() {
  // @@protoc_insertion_point(field_release:sim_msg.Vehicle.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Vehicle::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Vehicle.name)
}

// string objectname = 3;
inline void Vehicle::clear_objectname() {
  objectname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Vehicle::objectname() const {
  // @@protoc_insertion_point(field_get:sim_msg.Vehicle.objectname)
  return objectname_.GetNoArena();
}
inline void Vehicle::set_objectname(const std::string& value) {
  
  objectname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.Vehicle.objectname)
}
inline void Vehicle::set_objectname(std::string&& value) {
  
  objectname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.Vehicle.objectname)
}
inline void Vehicle::set_objectname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  objectname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.Vehicle.objectname)
}
inline void Vehicle::set_objectname(const char* value, size_t size) {
  
  objectname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.Vehicle.objectname)
}
inline std::string* Vehicle::mutable_objectname() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.Vehicle.objectname)
  return objectname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Vehicle::release_objectname() {
  // @@protoc_insertion_point(field_release:sim_msg.Vehicle.objectname)
  
  return objectname_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Vehicle::set_allocated_objectname(std::string* objectname) {
  if (objectname != nullptr) {
    
  } else {
    
  }
  objectname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), objectname);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Vehicle.objectname)
}

// .sim_msg.CategoryVehicle category = 4;
inline void Vehicle::clear_category() {
  category_ = 0;
}
inline ::sim_msg::CategoryVehicle Vehicle::category() const {
  // @@protoc_insertion_point(field_get:sim_msg.Vehicle.category)
  return static_cast< ::sim_msg::CategoryVehicle >(category_);
}
inline void Vehicle::set_category(::sim_msg::CategoryVehicle value) {
  
  category_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Vehicle.category)
}

// .sim_msg.PhysicleVehicle physicle = 5;
inline bool Vehicle::has_physicle() const {
  return this != internal_default_instance() && physicle_ != nullptr;
}
inline void Vehicle::clear_physicle() {
  if (GetArenaNoVirtual() == nullptr && physicle_ != nullptr) {
    delete physicle_;
  }
  physicle_ = nullptr;
}
inline const ::sim_msg::PhysicleVehicle& Vehicle::physicle() const {
  const ::sim_msg::PhysicleVehicle* p = physicle_;
  // @@protoc_insertion_point(field_get:sim_msg.Vehicle.physicle)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::PhysicleVehicle*>(
      &::sim_msg::_PhysicleVehicle_default_instance_);
}
inline ::sim_msg::PhysicleVehicle* Vehicle::release_physicle() {
  // @@protoc_insertion_point(field_release:sim_msg.Vehicle.physicle)
  
  ::sim_msg::PhysicleVehicle* temp = physicle_;
  physicle_ = nullptr;
  return temp;
}
inline ::sim_msg::PhysicleVehicle* Vehicle::mutable_physicle() {
  
  if (physicle_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::PhysicleVehicle>(GetArenaNoVirtual());
    physicle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Vehicle.physicle)
  return physicle_;
}
inline void Vehicle::set_allocated_physicle(::sim_msg::PhysicleVehicle* physicle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete physicle_;
  }
  if (physicle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      physicle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, physicle, submessage_arena);
    }
    
  } else {
    
  }
  physicle_ = physicle;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Vehicle.physicle)
}

// .sim_msg.InitialVehicle initial = 6;
inline bool Vehicle::has_initial() const {
  return this != internal_default_instance() && initial_ != nullptr;
}
inline void Vehicle::clear_initial() {
  if (GetArenaNoVirtual() == nullptr && initial_ != nullptr) {
    delete initial_;
  }
  initial_ = nullptr;
}
inline const ::sim_msg::InitialVehicle& Vehicle::initial() const {
  const ::sim_msg::InitialVehicle* p = initial_;
  // @@protoc_insertion_point(field_get:sim_msg.Vehicle.initial)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::InitialVehicle*>(
      &::sim_msg::_InitialVehicle_default_instance_);
}
inline ::sim_msg::InitialVehicle* Vehicle::release_initial() {
  // @@protoc_insertion_point(field_release:sim_msg.Vehicle.initial)
  
  ::sim_msg::InitialVehicle* temp = initial_;
  initial_ = nullptr;
  return temp;
}
inline ::sim_msg::InitialVehicle* Vehicle::mutable_initial() {
  
  if (initial_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::InitialVehicle>(GetArenaNoVirtual());
    initial_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Vehicle.initial)
  return initial_;
}
inline void Vehicle::set_allocated_initial(::sim_msg::InitialVehicle* initial) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete initial_;
  }
  if (initial) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      initial = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initial, submessage_arena);
    }
    
  } else {
    
  }
  initial_ = initial;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Vehicle.initial)
}

// .sim_msg.Dynamic dynamic = 7;
inline bool Vehicle::has_dynamic() const {
  return this != internal_default_instance() && dynamic_ != nullptr;
}
inline void Vehicle::clear_dynamic() {
  if (GetArenaNoVirtual() == nullptr && dynamic_ != nullptr) {
    delete dynamic_;
  }
  dynamic_ = nullptr;
}
inline const ::sim_msg::Dynamic& Vehicle::dynamic() const {
  const ::sim_msg::Dynamic* p = dynamic_;
  // @@protoc_insertion_point(field_get:sim_msg.Vehicle.dynamic)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Dynamic*>(
      &::sim_msg::_Dynamic_default_instance_);
}
inline ::sim_msg::Dynamic* Vehicle::release_dynamic() {
  // @@protoc_insertion_point(field_release:sim_msg.Vehicle.dynamic)
  
  ::sim_msg::Dynamic* temp = dynamic_;
  dynamic_ = nullptr;
  return temp;
}
inline ::sim_msg::Dynamic* Vehicle::mutable_dynamic() {
  
  if (dynamic_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Dynamic>(GetArenaNoVirtual());
    dynamic_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Vehicle.dynamic)
  return dynamic_;
}
inline void Vehicle::set_allocated_dynamic(::sim_msg::Dynamic* dynamic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dynamic_;
  }
  if (dynamic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dynamic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dynamic, submessage_arena);
    }
    
  } else {
    
  }
  dynamic_ = dynamic;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Vehicle.dynamic)
}

// .sim_msg.SensorGroup sensor_group = 8;
inline bool Vehicle::has_sensor_group() const {
  return this != internal_default_instance() && sensor_group_ != nullptr;
}
inline const ::sim_msg::SensorGroup& Vehicle::sensor_group() const {
  const ::sim_msg::SensorGroup* p = sensor_group_;
  // @@protoc_insertion_point(field_get:sim_msg.Vehicle.sensor_group)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::SensorGroup*>(
      &::sim_msg::_SensorGroup_default_instance_);
}
inline ::sim_msg::SensorGroup* Vehicle::release_sensor_group() {
  // @@protoc_insertion_point(field_release:sim_msg.Vehicle.sensor_group)
  
  ::sim_msg::SensorGroup* temp = sensor_group_;
  sensor_group_ = nullptr;
  return temp;
}
inline ::sim_msg::SensorGroup* Vehicle::mutable_sensor_group() {
  
  if (sensor_group_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::SensorGroup>(GetArenaNoVirtual());
    sensor_group_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Vehicle.sensor_group)
  return sensor_group_;
}
inline void Vehicle::set_allocated_sensor_group(::sim_msg::SensorGroup* sensor_group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sensor_group_);
  }
  if (sensor_group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sensor_group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_group, submessage_arena);
    }
    
  } else {
    
  }
  sensor_group_ = sensor_group;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Vehicle.sensor_group)
}

// string group = 9;
inline void Vehicle::clear_group() {
  group_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Vehicle::group() const {
  // @@protoc_insertion_point(field_get:sim_msg.Vehicle.group)
  return group_.GetNoArena();
}
inline void Vehicle::set_group(const std::string& value) {
  
  group_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.Vehicle.group)
}
inline void Vehicle::set_group(std::string&& value) {
  
  group_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.Vehicle.group)
}
inline void Vehicle::set_group(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  group_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.Vehicle.group)
}
inline void Vehicle::set_group(const char* value, size_t size) {
  
  group_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.Vehicle.group)
}
inline std::string* Vehicle::mutable_group() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.Vehicle.group)
  return group_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Vehicle::release_group() {
  // @@protoc_insertion_point(field_release:sim_msg.Vehicle.group)
  
  return group_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Vehicle::set_allocated_group(std::string* group) {
  if (group != nullptr) {
    
  } else {
    
  }
  group_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Vehicle.group)
}

// -------------------------------------------------------------------

// VulnerableRoadUser

// int64 id = 1;
inline void VulnerableRoadUser::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 VulnerableRoadUser::id() const {
  // @@protoc_insertion_point(field_get:sim_msg.VulnerableRoadUser.id)
  return id_;
}
inline void VulnerableRoadUser::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.VulnerableRoadUser.id)
}

// string name = 2;
inline void VulnerableRoadUser::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& VulnerableRoadUser::name() const {
  // @@protoc_insertion_point(field_get:sim_msg.VulnerableRoadUser.name)
  return name_.GetNoArena();
}
inline void VulnerableRoadUser::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.VulnerableRoadUser.name)
}
inline void VulnerableRoadUser::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.VulnerableRoadUser.name)
}
inline void VulnerableRoadUser::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.VulnerableRoadUser.name)
}
inline void VulnerableRoadUser::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.VulnerableRoadUser.name)
}
inline std::string* VulnerableRoadUser::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.VulnerableRoadUser.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VulnerableRoadUser::release_name() {
  // @@protoc_insertion_point(field_release:sim_msg.VulnerableRoadUser.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VulnerableRoadUser::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.VulnerableRoadUser.name)
}

// string objectname = 3;
inline void VulnerableRoadUser::clear_objectname() {
  objectname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& VulnerableRoadUser::objectname() const {
  // @@protoc_insertion_point(field_get:sim_msg.VulnerableRoadUser.objectname)
  return objectname_.GetNoArena();
}
inline void VulnerableRoadUser::set_objectname(const std::string& value) {
  
  objectname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.VulnerableRoadUser.objectname)
}
inline void VulnerableRoadUser::set_objectname(std::string&& value) {
  
  objectname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.VulnerableRoadUser.objectname)
}
inline void VulnerableRoadUser::set_objectname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  objectname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.VulnerableRoadUser.objectname)
}
inline void VulnerableRoadUser::set_objectname(const char* value, size_t size) {
  
  objectname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.VulnerableRoadUser.objectname)
}
inline std::string* VulnerableRoadUser::mutable_objectname() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.VulnerableRoadUser.objectname)
  return objectname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VulnerableRoadUser::release_objectname() {
  // @@protoc_insertion_point(field_release:sim_msg.VulnerableRoadUser.objectname)
  
  return objectname_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VulnerableRoadUser::set_allocated_objectname(std::string* objectname) {
  if (objectname != nullptr) {
    
  } else {
    
  }
  objectname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), objectname);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.VulnerableRoadUser.objectname)
}

// .sim_msg.CategoryVru category = 4;
inline void VulnerableRoadUser::clear_category() {
  category_ = 0;
}
inline ::sim_msg::CategoryVru VulnerableRoadUser::category() const {
  // @@protoc_insertion_point(field_get:sim_msg.VulnerableRoadUser.category)
  return static_cast< ::sim_msg::CategoryVru >(category_);
}
inline void VulnerableRoadUser::set_category(::sim_msg::CategoryVru value) {
  
  category_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.VulnerableRoadUser.category)
}

// .sim_msg.PhysicleVru physicle = 5;
inline bool VulnerableRoadUser::has_physicle() const {
  return this != internal_default_instance() && physicle_ != nullptr;
}
inline void VulnerableRoadUser::clear_physicle() {
  if (GetArenaNoVirtual() == nullptr && physicle_ != nullptr) {
    delete physicle_;
  }
  physicle_ = nullptr;
}
inline const ::sim_msg::PhysicleVru& VulnerableRoadUser::physicle() const {
  const ::sim_msg::PhysicleVru* p = physicle_;
  // @@protoc_insertion_point(field_get:sim_msg.VulnerableRoadUser.physicle)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::PhysicleVru*>(
      &::sim_msg::_PhysicleVru_default_instance_);
}
inline ::sim_msg::PhysicleVru* VulnerableRoadUser::release_physicle() {
  // @@protoc_insertion_point(field_release:sim_msg.VulnerableRoadUser.physicle)
  
  ::sim_msg::PhysicleVru* temp = physicle_;
  physicle_ = nullptr;
  return temp;
}
inline ::sim_msg::PhysicleVru* VulnerableRoadUser::mutable_physicle() {
  
  if (physicle_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::PhysicleVru>(GetArenaNoVirtual());
    physicle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.VulnerableRoadUser.physicle)
  return physicle_;
}
inline void VulnerableRoadUser::set_allocated_physicle(::sim_msg::PhysicleVru* physicle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete physicle_;
  }
  if (physicle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      physicle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, physicle, submessage_arena);
    }
    
  } else {
    
  }
  physicle_ = physicle;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.VulnerableRoadUser.physicle)
}

// .sim_msg.InitialVru initial = 6;
inline bool VulnerableRoadUser::has_initial() const {
  return this != internal_default_instance() && initial_ != nullptr;
}
inline void VulnerableRoadUser::clear_initial() {
  if (GetArenaNoVirtual() == nullptr && initial_ != nullptr) {
    delete initial_;
  }
  initial_ = nullptr;
}
inline const ::sim_msg::InitialVru& VulnerableRoadUser::initial() const {
  const ::sim_msg::InitialVru* p = initial_;
  // @@protoc_insertion_point(field_get:sim_msg.VulnerableRoadUser.initial)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::InitialVru*>(
      &::sim_msg::_InitialVru_default_instance_);
}
inline ::sim_msg::InitialVru* VulnerableRoadUser::release_initial() {
  // @@protoc_insertion_point(field_release:sim_msg.VulnerableRoadUser.initial)
  
  ::sim_msg::InitialVru* temp = initial_;
  initial_ = nullptr;
  return temp;
}
inline ::sim_msg::InitialVru* VulnerableRoadUser::mutable_initial() {
  
  if (initial_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::InitialVru>(GetArenaNoVirtual());
    initial_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.VulnerableRoadUser.initial)
  return initial_;
}
inline void VulnerableRoadUser::set_allocated_initial(::sim_msg::InitialVru* initial) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete initial_;
  }
  if (initial) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      initial = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initial, submessage_arena);
    }
    
  } else {
    
  }
  initial_ = initial;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.VulnerableRoadUser.initial)
}

// .sim_msg.Dynamic dynamic = 7;
inline bool VulnerableRoadUser::has_dynamic() const {
  return this != internal_default_instance() && dynamic_ != nullptr;
}
inline void VulnerableRoadUser::clear_dynamic() {
  if (GetArenaNoVirtual() == nullptr && dynamic_ != nullptr) {
    delete dynamic_;
  }
  dynamic_ = nullptr;
}
inline const ::sim_msg::Dynamic& VulnerableRoadUser::dynamic() const {
  const ::sim_msg::Dynamic* p = dynamic_;
  // @@protoc_insertion_point(field_get:sim_msg.VulnerableRoadUser.dynamic)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Dynamic*>(
      &::sim_msg::_Dynamic_default_instance_);
}
inline ::sim_msg::Dynamic* VulnerableRoadUser::release_dynamic() {
  // @@protoc_insertion_point(field_release:sim_msg.VulnerableRoadUser.dynamic)
  
  ::sim_msg::Dynamic* temp = dynamic_;
  dynamic_ = nullptr;
  return temp;
}
inline ::sim_msg::Dynamic* VulnerableRoadUser::mutable_dynamic() {
  
  if (dynamic_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Dynamic>(GetArenaNoVirtual());
    dynamic_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.VulnerableRoadUser.dynamic)
  return dynamic_;
}
inline void VulnerableRoadUser::set_allocated_dynamic(::sim_msg::Dynamic* dynamic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dynamic_;
  }
  if (dynamic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dynamic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dynamic, submessage_arena);
    }
    
  } else {
    
  }
  dynamic_ = dynamic;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.VulnerableRoadUser.dynamic)
}

// .sim_msg.SensorGroup sensor_group = 8;
inline bool VulnerableRoadUser::has_sensor_group() const {
  return this != internal_default_instance() && sensor_group_ != nullptr;
}
inline const ::sim_msg::SensorGroup& VulnerableRoadUser::sensor_group() const {
  const ::sim_msg::SensorGroup* p = sensor_group_;
  // @@protoc_insertion_point(field_get:sim_msg.VulnerableRoadUser.sensor_group)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::SensorGroup*>(
      &::sim_msg::_SensorGroup_default_instance_);
}
inline ::sim_msg::SensorGroup* VulnerableRoadUser::release_sensor_group() {
  // @@protoc_insertion_point(field_release:sim_msg.VulnerableRoadUser.sensor_group)
  
  ::sim_msg::SensorGroup* temp = sensor_group_;
  sensor_group_ = nullptr;
  return temp;
}
inline ::sim_msg::SensorGroup* VulnerableRoadUser::mutable_sensor_group() {
  
  if (sensor_group_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::SensorGroup>(GetArenaNoVirtual());
    sensor_group_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.VulnerableRoadUser.sensor_group)
  return sensor_group_;
}
inline void VulnerableRoadUser::set_allocated_sensor_group(::sim_msg::SensorGroup* sensor_group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sensor_group_);
  }
  if (sensor_group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sensor_group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_group, submessage_arena);
    }
    
  } else {
    
  }
  sensor_group_ = sensor_group;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.VulnerableRoadUser.sensor_group)
}

// -------------------------------------------------------------------

// MiscellaneousObject

// int64 id = 1;
inline void MiscellaneousObject::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 MiscellaneousObject::id() const {
  // @@protoc_insertion_point(field_get:sim_msg.MiscellaneousObject.id)
  return id_;
}
inline void MiscellaneousObject::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.MiscellaneousObject.id)
}

// string name = 2;
inline void MiscellaneousObject::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& MiscellaneousObject::name() const {
  // @@protoc_insertion_point(field_get:sim_msg.MiscellaneousObject.name)
  return name_.GetNoArena();
}
inline void MiscellaneousObject::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.MiscellaneousObject.name)
}
inline void MiscellaneousObject::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.MiscellaneousObject.name)
}
inline void MiscellaneousObject::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.MiscellaneousObject.name)
}
inline void MiscellaneousObject::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.MiscellaneousObject.name)
}
inline std::string* MiscellaneousObject::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.MiscellaneousObject.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MiscellaneousObject::release_name() {
  // @@protoc_insertion_point(field_release:sim_msg.MiscellaneousObject.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MiscellaneousObject::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.MiscellaneousObject.name)
}

// string objectname = 3;
inline void MiscellaneousObject::clear_objectname() {
  objectname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& MiscellaneousObject::objectname() const {
  // @@protoc_insertion_point(field_get:sim_msg.MiscellaneousObject.objectname)
  return objectname_.GetNoArena();
}
inline void MiscellaneousObject::set_objectname(const std::string& value) {
  
  objectname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.MiscellaneousObject.objectname)
}
inline void MiscellaneousObject::set_objectname(std::string&& value) {
  
  objectname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.MiscellaneousObject.objectname)
}
inline void MiscellaneousObject::set_objectname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  objectname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.MiscellaneousObject.objectname)
}
inline void MiscellaneousObject::set_objectname(const char* value, size_t size) {
  
  objectname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.MiscellaneousObject.objectname)
}
inline std::string* MiscellaneousObject::mutable_objectname() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.MiscellaneousObject.objectname)
  return objectname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MiscellaneousObject::release_objectname() {
  // @@protoc_insertion_point(field_release:sim_msg.MiscellaneousObject.objectname)
  
  return objectname_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MiscellaneousObject::set_allocated_objectname(std::string* objectname) {
  if (objectname != nullptr) {
    
  } else {
    
  }
  objectname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), objectname);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.MiscellaneousObject.objectname)
}

// .sim_msg.CategoryMisc category = 4;
inline void MiscellaneousObject::clear_category() {
  category_ = 0;
}
inline ::sim_msg::CategoryMisc MiscellaneousObject::category() const {
  // @@protoc_insertion_point(field_get:sim_msg.MiscellaneousObject.category)
  return static_cast< ::sim_msg::CategoryMisc >(category_);
}
inline void MiscellaneousObject::set_category(::sim_msg::CategoryMisc value) {
  
  category_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.MiscellaneousObject.category)
}

// .sim_msg.PhysicleCommon physicle = 5;
inline bool MiscellaneousObject::has_physicle() const {
  return this != internal_default_instance() && physicle_ != nullptr;
}
inline void MiscellaneousObject::clear_physicle() {
  if (GetArenaNoVirtual() == nullptr && physicle_ != nullptr) {
    delete physicle_;
  }
  physicle_ = nullptr;
}
inline const ::sim_msg::PhysicleCommon& MiscellaneousObject::physicle() const {
  const ::sim_msg::PhysicleCommon* p = physicle_;
  // @@protoc_insertion_point(field_get:sim_msg.MiscellaneousObject.physicle)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::PhysicleCommon*>(
      &::sim_msg::_PhysicleCommon_default_instance_);
}
inline ::sim_msg::PhysicleCommon* MiscellaneousObject::release_physicle() {
  // @@protoc_insertion_point(field_release:sim_msg.MiscellaneousObject.physicle)
  
  ::sim_msg::PhysicleCommon* temp = physicle_;
  physicle_ = nullptr;
  return temp;
}
inline ::sim_msg::PhysicleCommon* MiscellaneousObject::mutable_physicle() {
  
  if (physicle_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::PhysicleCommon>(GetArenaNoVirtual());
    physicle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.MiscellaneousObject.physicle)
  return physicle_;
}
inline void MiscellaneousObject::set_allocated_physicle(::sim_msg::PhysicleCommon* physicle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete physicle_;
  }
  if (physicle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      physicle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, physicle, submessage_arena);
    }
    
  } else {
    
  }
  physicle_ = physicle;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.MiscellaneousObject.physicle)
}

// .sim_msg.InitialCommon initial = 6;
inline bool MiscellaneousObject::has_initial() const {
  return this != internal_default_instance() && initial_ != nullptr;
}
inline void MiscellaneousObject::clear_initial() {
  if (GetArenaNoVirtual() == nullptr && initial_ != nullptr) {
    delete initial_;
  }
  initial_ = nullptr;
}
inline const ::sim_msg::InitialCommon& MiscellaneousObject::initial() const {
  const ::sim_msg::InitialCommon* p = initial_;
  // @@protoc_insertion_point(field_get:sim_msg.MiscellaneousObject.initial)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::InitialCommon*>(
      &::sim_msg::_InitialCommon_default_instance_);
}
inline ::sim_msg::InitialCommon* MiscellaneousObject::release_initial() {
  // @@protoc_insertion_point(field_release:sim_msg.MiscellaneousObject.initial)
  
  ::sim_msg::InitialCommon* temp = initial_;
  initial_ = nullptr;
  return temp;
}
inline ::sim_msg::InitialCommon* MiscellaneousObject::mutable_initial() {
  
  if (initial_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::InitialCommon>(GetArenaNoVirtual());
    initial_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.MiscellaneousObject.initial)
  return initial_;
}
inline void MiscellaneousObject::set_allocated_initial(::sim_msg::InitialCommon* initial) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete initial_;
  }
  if (initial) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      initial = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initial, submessage_arena);
    }
    
  } else {
    
  }
  initial_ = initial;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.MiscellaneousObject.initial)
}

// .sim_msg.Dynamic dynamic = 7;
inline bool MiscellaneousObject::has_dynamic() const {
  return this != internal_default_instance() && dynamic_ != nullptr;
}
inline void MiscellaneousObject::clear_dynamic() {
  if (GetArenaNoVirtual() == nullptr && dynamic_ != nullptr) {
    delete dynamic_;
  }
  dynamic_ = nullptr;
}
inline const ::sim_msg::Dynamic& MiscellaneousObject::dynamic() const {
  const ::sim_msg::Dynamic* p = dynamic_;
  // @@protoc_insertion_point(field_get:sim_msg.MiscellaneousObject.dynamic)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Dynamic*>(
      &::sim_msg::_Dynamic_default_instance_);
}
inline ::sim_msg::Dynamic* MiscellaneousObject::release_dynamic() {
  // @@protoc_insertion_point(field_release:sim_msg.MiscellaneousObject.dynamic)
  
  ::sim_msg::Dynamic* temp = dynamic_;
  dynamic_ = nullptr;
  return temp;
}
inline ::sim_msg::Dynamic* MiscellaneousObject::mutable_dynamic() {
  
  if (dynamic_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Dynamic>(GetArenaNoVirtual());
    dynamic_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.MiscellaneousObject.dynamic)
  return dynamic_;
}
inline void MiscellaneousObject::set_allocated_dynamic(::sim_msg::Dynamic* dynamic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dynamic_;
  }
  if (dynamic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dynamic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dynamic, submessage_arena);
    }
    
  } else {
    
  }
  dynamic_ = dynamic;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.MiscellaneousObject.dynamic)
}

// .sim_msg.SensorGroup sensor_group = 8;
inline bool MiscellaneousObject::has_sensor_group() const {
  return this != internal_default_instance() && sensor_group_ != nullptr;
}
inline const ::sim_msg::SensorGroup& MiscellaneousObject::sensor_group() const {
  const ::sim_msg::SensorGroup* p = sensor_group_;
  // @@protoc_insertion_point(field_get:sim_msg.MiscellaneousObject.sensor_group)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::SensorGroup*>(
      &::sim_msg::_SensorGroup_default_instance_);
}
inline ::sim_msg::SensorGroup* MiscellaneousObject::release_sensor_group() {
  // @@protoc_insertion_point(field_release:sim_msg.MiscellaneousObject.sensor_group)
  
  ::sim_msg::SensorGroup* temp = sensor_group_;
  sensor_group_ = nullptr;
  return temp;
}
inline ::sim_msg::SensorGroup* MiscellaneousObject::mutable_sensor_group() {
  
  if (sensor_group_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::SensorGroup>(GetArenaNoVirtual());
    sensor_group_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.MiscellaneousObject.sensor_group)
  return sensor_group_;
}
inline void MiscellaneousObject::set_allocated_sensor_group(::sim_msg::SensorGroup* sensor_group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sensor_group_);
  }
  if (sensor_group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sensor_group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_group, submessage_arena);
    }
    
  } else {
    
  }
  sensor_group_ = sensor_group;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.MiscellaneousObject.sensor_group)
}

// -------------------------------------------------------------------

// MapModel

// string name = 1;
inline void MapModel::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& MapModel::name() const {
  // @@protoc_insertion_point(field_get:sim_msg.MapModel.name)
  return name_.GetNoArena();
}
inline void MapModel::set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:sim_msg.MapModel.name)
}
inline void MapModel::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:sim_msg.MapModel.name)
}
inline void MapModel::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:sim_msg.MapModel.name)
}
inline void MapModel::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:sim_msg.MapModel.name)
}
inline std::string* MapModel::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:sim_msg.MapModel.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MapModel::release_name() {
  // @@protoc_insertion_point(field_release:sim_msg.MapModel.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MapModel::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:sim_msg.MapModel.name)
}

// .sim_msg.PhysicleCommon common = 2;
inline bool MapModel::has_common() const {
  return this != internal_default_instance() && common_ != nullptr;
}
inline void MapModel::clear_common() {
  if (GetArenaNoVirtual() == nullptr && common_ != nullptr) {
    delete common_;
  }
  common_ = nullptr;
}
inline const ::sim_msg::PhysicleCommon& MapModel::common() const {
  const ::sim_msg::PhysicleCommon* p = common_;
  // @@protoc_insertion_point(field_get:sim_msg.MapModel.common)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::PhysicleCommon*>(
      &::sim_msg::_PhysicleCommon_default_instance_);
}
inline ::sim_msg::PhysicleCommon* MapModel::release_common() {
  // @@protoc_insertion_point(field_release:sim_msg.MapModel.common)
  
  ::sim_msg::PhysicleCommon* temp = common_;
  common_ = nullptr;
  return temp;
}
inline ::sim_msg::PhysicleCommon* MapModel::mutable_common() {
  
  if (common_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::PhysicleCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.MapModel.common)
  return common_;
}
inline void MapModel::set_allocated_common(::sim_msg::PhysicleCommon* common) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete common_;
  }
  if (common) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      common = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.MapModel.common)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Scene

// .sim_msg.Setting setting = 1;
inline bool Scene::has_setting() const {
  return this != internal_default_instance() && setting_ != nullptr;
}
inline const ::sim_msg::Setting& Scene::setting() const {
  const ::sim_msg::Setting* p = setting_;
  // @@protoc_insertion_point(field_get:sim_msg.Scene.setting)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::Setting*>(
      &::sim_msg::_Setting_default_instance_);
}
inline ::sim_msg::Setting* Scene::release_setting() {
  // @@protoc_insertion_point(field_release:sim_msg.Scene.setting)
  
  ::sim_msg::Setting* temp = setting_;
  setting_ = nullptr;
  return temp;
}
inline ::sim_msg::Setting* Scene::mutable_setting() {
  
  if (setting_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Setting>(GetArenaNoVirtual());
    setting_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Scene.setting)
  return setting_;
}
inline void Scene::set_allocated_setting(::sim_msg::Setting* setting) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(setting_);
  }
  if (setting) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      setting = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, setting, submessage_arena);
    }
    
  } else {
    
  }
  setting_ = setting;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Scene.setting)
}

// repeated .sim_msg.Ego egos = 2;
inline int Scene::egos_size() const {
  return egos_.size();
}
inline void Scene::clear_egos() {
  egos_.Clear();
}
inline ::sim_msg::Ego* Scene::mutable_egos(int index) {
  // @@protoc_insertion_point(field_mutable:sim_msg.Scene.egos)
  return egos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Ego >*
Scene::mutable_egos() {
  // @@protoc_insertion_point(field_mutable_list:sim_msg.Scene.egos)
  return &egos_;
}
inline const ::sim_msg::Ego& Scene::egos(int index) const {
  // @@protoc_insertion_point(field_get:sim_msg.Scene.egos)
  return egos_.Get(index);
}
inline ::sim_msg::Ego* Scene::add_egos() {
  // @@protoc_insertion_point(field_add:sim_msg.Scene.egos)
  return egos_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Ego >&
Scene::egos() const {
  // @@protoc_insertion_point(field_list:sim_msg.Scene.egos)
  return egos_;
}

// repeated .sim_msg.Vehicle vehicles = 3;
inline int Scene::vehicles_size() const {
  return vehicles_.size();
}
inline void Scene::clear_vehicles() {
  vehicles_.Clear();
}
inline ::sim_msg::Vehicle* Scene::mutable_vehicles(int index) {
  // @@protoc_insertion_point(field_mutable:sim_msg.Scene.vehicles)
  return vehicles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Vehicle >*
Scene::mutable_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:sim_msg.Scene.vehicles)
  return &vehicles_;
}
inline const ::sim_msg::Vehicle& Scene::vehicles(int index) const {
  // @@protoc_insertion_point(field_get:sim_msg.Scene.vehicles)
  return vehicles_.Get(index);
}
inline ::sim_msg::Vehicle* Scene::add_vehicles() {
  // @@protoc_insertion_point(field_add:sim_msg.Scene.vehicles)
  return vehicles_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::Vehicle >&
Scene::vehicles() const {
  // @@protoc_insertion_point(field_list:sim_msg.Scene.vehicles)
  return vehicles_;
}

// repeated .sim_msg.VulnerableRoadUser vrus = 4;
inline int Scene::vrus_size() const {
  return vrus_.size();
}
inline void Scene::clear_vrus() {
  vrus_.Clear();
}
inline ::sim_msg::VulnerableRoadUser* Scene::mutable_vrus(int index) {
  // @@protoc_insertion_point(field_mutable:sim_msg.Scene.vrus)
  return vrus_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::VulnerableRoadUser >*
Scene::mutable_vrus() {
  // @@protoc_insertion_point(field_mutable_list:sim_msg.Scene.vrus)
  return &vrus_;
}
inline const ::sim_msg::VulnerableRoadUser& Scene::vrus(int index) const {
  // @@protoc_insertion_point(field_get:sim_msg.Scene.vrus)
  return vrus_.Get(index);
}
inline ::sim_msg::VulnerableRoadUser* Scene::add_vrus() {
  // @@protoc_insertion_point(field_add:sim_msg.Scene.vrus)
  return vrus_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::VulnerableRoadUser >&
Scene::vrus() const {
  // @@protoc_insertion_point(field_list:sim_msg.Scene.vrus)
  return vrus_;
}

// repeated .sim_msg.MiscellaneousObject miscs = 5;
inline int Scene::miscs_size() const {
  return miscs_.size();
}
inline void Scene::clear_miscs() {
  miscs_.Clear();
}
inline ::sim_msg::MiscellaneousObject* Scene::mutable_miscs(int index) {
  // @@protoc_insertion_point(field_mutable:sim_msg.Scene.miscs)
  return miscs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::MiscellaneousObject >*
Scene::mutable_miscs() {
  // @@protoc_insertion_point(field_mutable_list:sim_msg.Scene.miscs)
  return &miscs_;
}
inline const ::sim_msg::MiscellaneousObject& Scene::miscs(int index) const {
  // @@protoc_insertion_point(field_get:sim_msg.Scene.miscs)
  return miscs_.Get(index);
}
inline ::sim_msg::MiscellaneousObject* Scene::add_miscs() {
  // @@protoc_insertion_point(field_add:sim_msg.Scene.miscs)
  return miscs_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::MiscellaneousObject >&
Scene::miscs() const {
  // @@protoc_insertion_point(field_list:sim_msg.Scene.miscs)
  return miscs_;
}

// map<int64, .sim_msg.EnvironmentalConditions> environment = 6;
inline int Scene::environment_size() const {
  return environment_.size();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, ::sim_msg::EnvironmentalConditions >&
Scene::environment() const {
  // @@protoc_insertion_point(field_map:sim_msg.Scene.environment)
  return environment_.GetMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::int64, ::sim_msg::EnvironmentalConditions >*
Scene::mutable_environment() {
  // @@protoc_insertion_point(field_mutable_map:sim_msg.Scene.environment)
  return environment_.MutableMap();
}

// .sim_msg.InfrastructureGroup infrastructure_group = 7;
inline bool Scene::has_infrastructure_group() const {
  return this != internal_default_instance() && infrastructure_group_ != nullptr;
}
inline const ::sim_msg::InfrastructureGroup& Scene::infrastructure_group() const {
  const ::sim_msg::InfrastructureGroup* p = infrastructure_group_;
  // @@protoc_insertion_point(field_get:sim_msg.Scene.infrastructure_group)
  return p != nullptr ? *p : *reinterpret_cast<const ::sim_msg::InfrastructureGroup*>(
      &::sim_msg::_InfrastructureGroup_default_instance_);
}
inline ::sim_msg::InfrastructureGroup* Scene::release_infrastructure_group() {
  // @@protoc_insertion_point(field_release:sim_msg.Scene.infrastructure_group)
  
  ::sim_msg::InfrastructureGroup* temp = infrastructure_group_;
  infrastructure_group_ = nullptr;
  return temp;
}
inline ::sim_msg::InfrastructureGroup* Scene::mutable_infrastructure_group() {
  
  if (infrastructure_group_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::InfrastructureGroup>(GetArenaNoVirtual());
    infrastructure_group_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Scene.infrastructure_group)
  return infrastructure_group_;
}
inline void Scene::set_allocated_infrastructure_group(::sim_msg::InfrastructureGroup* infrastructure_group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(infrastructure_group_);
  }
  if (infrastructure_group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      infrastructure_group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, infrastructure_group, submessage_arena);
    }
    
  } else {
    
  }
  infrastructure_group_ = infrastructure_group;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Scene.infrastructure_group)
}

// repeated .sim_msg.MapModel map_models = 8;
inline int Scene::map_models_size() const {
  return map_models_.size();
}
inline void Scene::clear_map_models() {
  map_models_.Clear();
}
inline ::sim_msg::MapModel* Scene::mutable_map_models(int index) {
  // @@protoc_insertion_point(field_mutable:sim_msg.Scene.map_models)
  return map_models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::MapModel >*
Scene::mutable_map_models() {
  // @@protoc_insertion_point(field_mutable_list:sim_msg.Scene.map_models)
  return &map_models_;
}
inline const ::sim_msg::MapModel& Scene::map_models(int index) const {
  // @@protoc_insertion_point(field_get:sim_msg.Scene.map_models)
  return map_models_.Get(index);
}
inline ::sim_msg::MapModel* Scene::add_map_models() {
  // @@protoc_insertion_point(field_add:sim_msg.Scene.map_models)
  return map_models_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sim_msg::MapModel >&
Scene::map_models() const {
  // @@protoc_insertion_point(field_list:sim_msg.Scene.map_models)
  return map_models_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sim_msg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sim_msg::ActionAccel_EndType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::ActionAccel_EndType>() {
  return ::sim_msg::ActionAccel_EndType_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::ActionLaneChange_Dir> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::ActionLaneChange_Dir>() {
  return ::sim_msg::ActionLaneChange_Dir_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::CategoryVehicle> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::CategoryVehicle>() {
  return ::sim_msg::CategoryVehicle_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::CategoryVru> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::CategoryVru>() {
  return ::sim_msg::CategoryVru_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::CategoryMisc> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::CategoryMisc>() {
  return ::sim_msg::CategoryMisc_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::Color> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::Color>() {
  return ::sim_msg::Color_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::BehaviorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::BehaviorType>() {
  return ::sim_msg::BehaviorType_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::Rule> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::Rule>() {
  return ::sim_msg::Rule_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::DirDimension> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::DirDimension>() {
  return ::sim_msg::DirDimension_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::ConditionEdge> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::ConditionEdge>() {
  return ::sim_msg::ConditionEdge_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::DistanceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::DistanceType>() {
  return ::sim_msg::DistanceType_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::StoryboardElementType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::StoryboardElementType>() {
  return ::sim_msg::StoryboardElementType_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::StoryboardElementState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::StoryboardElementState>() {
  return ::sim_msg::StoryboardElementState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_scene_2eproto
