// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: osi_featuredata.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_osi_5ffeaturedata_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_osi_5ffeaturedata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "osi_version.pb.h"
#include "osi_common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_osi_5ffeaturedata_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_osi_5ffeaturedata_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_osi_5ffeaturedata_2eproto;
namespace osi3 {
class CameraDetection;
class CameraDetectionDefaultTypeInternal;
extern CameraDetectionDefaultTypeInternal _CameraDetection_default_instance_;
class CameraDetectionData;
class CameraDetectionDataDefaultTypeInternal;
extern CameraDetectionDataDefaultTypeInternal _CameraDetectionData_default_instance_;
class CameraDetectionSpecificHeader;
class CameraDetectionSpecificHeaderDefaultTypeInternal;
extern CameraDetectionSpecificHeaderDefaultTypeInternal _CameraDetectionSpecificHeader_default_instance_;
class CameraPoint;
class CameraPointDefaultTypeInternal;
extern CameraPointDefaultTypeInternal _CameraPoint_default_instance_;
class FeatureData;
class FeatureDataDefaultTypeInternal;
extern FeatureDataDefaultTypeInternal _FeatureData_default_instance_;
class LidarDetection;
class LidarDetectionDefaultTypeInternal;
extern LidarDetectionDefaultTypeInternal _LidarDetection_default_instance_;
class LidarDetectionData;
class LidarDetectionDataDefaultTypeInternal;
extern LidarDetectionDataDefaultTypeInternal _LidarDetectionData_default_instance_;
class RadarDetection;
class RadarDetectionDefaultTypeInternal;
extern RadarDetectionDefaultTypeInternal _RadarDetection_default_instance_;
class RadarDetectionData;
class RadarDetectionDataDefaultTypeInternal;
extern RadarDetectionDataDefaultTypeInternal _RadarDetectionData_default_instance_;
class SensorDetectionHeader;
class SensorDetectionHeaderDefaultTypeInternal;
extern SensorDetectionHeaderDefaultTypeInternal _SensorDetectionHeader_default_instance_;
class UltrasonicDetection;
class UltrasonicDetectionDefaultTypeInternal;
extern UltrasonicDetectionDefaultTypeInternal _UltrasonicDetection_default_instance_;
class UltrasonicDetectionData;
class UltrasonicDetectionDataDefaultTypeInternal;
extern UltrasonicDetectionDataDefaultTypeInternal _UltrasonicDetectionData_default_instance_;
class UltrasonicDetectionSpecificHeader;
class UltrasonicDetectionSpecificHeaderDefaultTypeInternal;
extern UltrasonicDetectionSpecificHeaderDefaultTypeInternal _UltrasonicDetectionSpecificHeader_default_instance_;
class UltrasonicIndirectDetection;
class UltrasonicIndirectDetectionDefaultTypeInternal;
extern UltrasonicIndirectDetectionDefaultTypeInternal _UltrasonicIndirectDetection_default_instance_;
}  // namespace osi3
PROTOBUF_NAMESPACE_OPEN
template<> ::osi3::CameraDetection* Arena::CreateMaybeMessage<::osi3::CameraDetection>(Arena*);
template<> ::osi3::CameraDetectionData* Arena::CreateMaybeMessage<::osi3::CameraDetectionData>(Arena*);
template<> ::osi3::CameraDetectionSpecificHeader* Arena::CreateMaybeMessage<::osi3::CameraDetectionSpecificHeader>(Arena*);
template<> ::osi3::CameraPoint* Arena::CreateMaybeMessage<::osi3::CameraPoint>(Arena*);
template<> ::osi3::FeatureData* Arena::CreateMaybeMessage<::osi3::FeatureData>(Arena*);
template<> ::osi3::LidarDetection* Arena::CreateMaybeMessage<::osi3::LidarDetection>(Arena*);
template<> ::osi3::LidarDetectionData* Arena::CreateMaybeMessage<::osi3::LidarDetectionData>(Arena*);
template<> ::osi3::RadarDetection* Arena::CreateMaybeMessage<::osi3::RadarDetection>(Arena*);
template<> ::osi3::RadarDetectionData* Arena::CreateMaybeMessage<::osi3::RadarDetectionData>(Arena*);
template<> ::osi3::SensorDetectionHeader* Arena::CreateMaybeMessage<::osi3::SensorDetectionHeader>(Arena*);
template<> ::osi3::UltrasonicDetection* Arena::CreateMaybeMessage<::osi3::UltrasonicDetection>(Arena*);
template<> ::osi3::UltrasonicDetectionData* Arena::CreateMaybeMessage<::osi3::UltrasonicDetectionData>(Arena*);
template<> ::osi3::UltrasonicDetectionSpecificHeader* Arena::CreateMaybeMessage<::osi3::UltrasonicDetectionSpecificHeader>(Arena*);
template<> ::osi3::UltrasonicIndirectDetection* Arena::CreateMaybeMessage<::osi3::UltrasonicIndirectDetection>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace osi3 {

enum SensorDetectionHeader_DataQualifier : int {
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_UNKNOWN = 0,
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_OTHER = 1,
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_AVAILABLE = 2,
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_AVAILABLE_REDUCED = 3,
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_NOT_AVAILABLE = 4,
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_BLINDNESS = 5,
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_TEMPORARY_AVAILABLE = 6,
  SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_INVALID = 7,
  SensorDetectionHeader_DataQualifier_SensorDetectionHeader_DataQualifier_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SensorDetectionHeader_DataQualifier_SensorDetectionHeader_DataQualifier_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SensorDetectionHeader_DataQualifier_IsValid(int value);
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader_DataQualifier_DataQualifier_MIN = SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_UNKNOWN;
constexpr SensorDetectionHeader_DataQualifier SensorDetectionHeader_DataQualifier_DataQualifier_MAX = SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_INVALID;
constexpr int SensorDetectionHeader_DataQualifier_DataQualifier_ARRAYSIZE = SensorDetectionHeader_DataQualifier_DataQualifier_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorDetectionHeader_DataQualifier_descriptor();
template<typename T>
inline const std::string& SensorDetectionHeader_DataQualifier_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SensorDetectionHeader_DataQualifier>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SensorDetectionHeader_DataQualifier_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SensorDetectionHeader_DataQualifier_descriptor(), enum_t_value);
}
inline bool SensorDetectionHeader_DataQualifier_Parse(
    const std::string& name, SensorDetectionHeader_DataQualifier* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SensorDetectionHeader_DataQualifier>(
    SensorDetectionHeader_DataQualifier_descriptor(), name, value);
}
enum SensorDetectionHeader_ExtendedQualifier : int {
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_UNKNOWN = 0,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_OTHER = 1,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_NORMAL_OPERATION_MODE = 2,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_POWER_UP_OR_DOWN = 3,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_SENSOR_NOT_CALIBRATED = 4,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_SENSOR_BLOCKED = 5,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_SENSOR_MISALIGNED = 6,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_BAD_SENSOR_ENVIRONMENTAL_CONDITION = 7,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_REDUCED_FIELD_OF_VIEW = 8,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_INPUT_NOT_AVAILABLE = 9,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_INTERNAL_REASON = 10,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_EXTERNAL_DISTURBANCE = 11,
  SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_BEGINNING_BLOCKAGE = 12,
  SensorDetectionHeader_ExtendedQualifier_SensorDetectionHeader_ExtendedQualifier_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SensorDetectionHeader_ExtendedQualifier_SensorDetectionHeader_ExtendedQualifier_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SensorDetectionHeader_ExtendedQualifier_IsValid(int value);
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader_ExtendedQualifier_ExtendedQualifier_MIN = SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_UNKNOWN;
constexpr SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader_ExtendedQualifier_ExtendedQualifier_MAX = SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_BEGINNING_BLOCKAGE;
constexpr int SensorDetectionHeader_ExtendedQualifier_ExtendedQualifier_ARRAYSIZE = SensorDetectionHeader_ExtendedQualifier_ExtendedQualifier_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SensorDetectionHeader_ExtendedQualifier_descriptor();
template<typename T>
inline const std::string& SensorDetectionHeader_ExtendedQualifier_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SensorDetectionHeader_ExtendedQualifier>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SensorDetectionHeader_ExtendedQualifier_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SensorDetectionHeader_ExtendedQualifier_descriptor(), enum_t_value);
}
inline bool SensorDetectionHeader_ExtendedQualifier_Parse(
    const std::string& name, SensorDetectionHeader_ExtendedQualifier* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SensorDetectionHeader_ExtendedQualifier>(
    SensorDetectionHeader_ExtendedQualifier_descriptor(), name, value);
}
enum CameraDetection_Color : int {
  CameraDetection_Color_COLOR_UNKNOWN = 0,
  CameraDetection_Color_COLOR_OTHER = 1,
  CameraDetection_Color_COLOR_BLACK = 2,
  CameraDetection_Color_COLOR_GREY = 3,
  CameraDetection_Color_COLOR_WHITE = 4,
  CameraDetection_Color_COLOR_YELLOW = 5,
  CameraDetection_Color_COLOR_ORANGE = 6,
  CameraDetection_Color_COLOR_RED = 7,
  CameraDetection_Color_COLOR_VIOLET = 8,
  CameraDetection_Color_COLOR_BLUE = 9,
  CameraDetection_Color_COLOR_GREEN = 10,
  CameraDetection_Color_COLOR_REFLECTIVE = 11,
  CameraDetection_Color_CameraDetection_Color_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CameraDetection_Color_CameraDetection_Color_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CameraDetection_Color_IsValid(int value);
constexpr CameraDetection_Color CameraDetection_Color_Color_MIN = CameraDetection_Color_COLOR_UNKNOWN;
constexpr CameraDetection_Color CameraDetection_Color_Color_MAX = CameraDetection_Color_COLOR_REFLECTIVE;
constexpr int CameraDetection_Color_Color_ARRAYSIZE = CameraDetection_Color_Color_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CameraDetection_Color_descriptor();
template<typename T>
inline const std::string& CameraDetection_Color_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CameraDetection_Color>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CameraDetection_Color_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CameraDetection_Color_descriptor(), enum_t_value);
}
inline bool CameraDetection_Color_Parse(
    const std::string& name, CameraDetection_Color* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CameraDetection_Color>(
    CameraDetection_Color_descriptor(), name, value);
}
enum CameraDetection_ImageShapeType : int {
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_UNKNOWN = 0,
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_OTHER = 1,
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POINT = 2,
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_BOX = 3,
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_ELLIPSE = 4,
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POLYGON = 5,
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POLYLINE = 6,
  CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POINT_CLOUD = 7,
  CameraDetection_ImageShapeType_CameraDetection_ImageShapeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CameraDetection_ImageShapeType_CameraDetection_ImageShapeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CameraDetection_ImageShapeType_IsValid(int value);
constexpr CameraDetection_ImageShapeType CameraDetection_ImageShapeType_ImageShapeType_MIN = CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_UNKNOWN;
constexpr CameraDetection_ImageShapeType CameraDetection_ImageShapeType_ImageShapeType_MAX = CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POINT_CLOUD;
constexpr int CameraDetection_ImageShapeType_ImageShapeType_ARRAYSIZE = CameraDetection_ImageShapeType_ImageShapeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CameraDetection_ImageShapeType_descriptor();
template<typename T>
inline const std::string& CameraDetection_ImageShapeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CameraDetection_ImageShapeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CameraDetection_ImageShapeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CameraDetection_ImageShapeType_descriptor(), enum_t_value);
}
inline bool CameraDetection_ImageShapeType_Parse(
    const std::string& name, CameraDetection_ImageShapeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CameraDetection_ImageShapeType>(
    CameraDetection_ImageShapeType_descriptor(), name, value);
}
enum DetectionClassification : int {
  DETECTION_CLASSIFICATION_UNKNOWN = 0,
  DETECTION_CLASSIFICATION_OTHER = 1,
  DETECTION_CLASSIFICATION_INVALID = 2,
  DETECTION_CLASSIFICATION_CLUTTER = 3,
  DETECTION_CLASSIFICATION_OVERDRIVABLE = 4,
  DETECTION_CLASSIFICATION_UNDERDRIVABLE = 5,
  DetectionClassification_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  DetectionClassification_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool DetectionClassification_IsValid(int value);
constexpr DetectionClassification DetectionClassification_MIN = DETECTION_CLASSIFICATION_UNKNOWN;
constexpr DetectionClassification DetectionClassification_MAX = DETECTION_CLASSIFICATION_UNDERDRIVABLE;
constexpr int DetectionClassification_ARRAYSIZE = DetectionClassification_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DetectionClassification_descriptor();
template<typename T>
inline const std::string& DetectionClassification_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DetectionClassification>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DetectionClassification_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DetectionClassification_descriptor(), enum_t_value);
}
inline bool DetectionClassification_Parse(
    const std::string& name, DetectionClassification* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DetectionClassification>(
    DetectionClassification_descriptor(), name, value);
}
// ===================================================================

class FeatureData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:osi3.FeatureData) */ {
 public:
  FeatureData();
  virtual ~FeatureData();

  FeatureData(const FeatureData& from);
  FeatureData(FeatureData&& from) noexcept
    : FeatureData() {
    *this = ::std::move(from);
  }

  inline FeatureData& operator=(const FeatureData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeatureData& operator=(FeatureData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FeatureData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FeatureData* internal_default_instance() {
    return reinterpret_cast<const FeatureData*>(
               &_FeatureData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FeatureData& a, FeatureData& b) {
    a.Swap(&b);
  }
  inline void Swap(FeatureData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FeatureData* New() const final {
    return CreateMaybeMessage<FeatureData>(nullptr);
  }

  FeatureData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FeatureData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FeatureData& from);
  void MergeFrom(const FeatureData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeatureData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "osi3.FeatureData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_osi_5ffeaturedata_2eproto);
    return ::descriptor_table_osi_5ffeaturedata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRadarSensorFieldNumber = 2,
    kLidarSensorFieldNumber = 3,
    kUltrasonicSensorFieldNumber = 4,
    kCameraSensorFieldNumber = 5,
    kVersionFieldNumber = 1,
  };
  // repeated .osi3.RadarDetectionData radar_sensor = 2;
  int radar_sensor_size() const;
  void clear_radar_sensor();
  ::osi3::RadarDetectionData* mutable_radar_sensor(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::RadarDetectionData >*
      mutable_radar_sensor();
  const ::osi3::RadarDetectionData& radar_sensor(int index) const;
  ::osi3::RadarDetectionData* add_radar_sensor();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::RadarDetectionData >&
      radar_sensor() const;

  // repeated .osi3.LidarDetectionData lidar_sensor = 3;
  int lidar_sensor_size() const;
  void clear_lidar_sensor();
  ::osi3::LidarDetectionData* mutable_lidar_sensor(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::LidarDetectionData >*
      mutable_lidar_sensor();
  const ::osi3::LidarDetectionData& lidar_sensor(int index) const;
  ::osi3::LidarDetectionData* add_lidar_sensor();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::LidarDetectionData >&
      lidar_sensor() const;

  // repeated .osi3.UltrasonicDetectionData ultrasonic_sensor = 4;
  int ultrasonic_sensor_size() const;
  void clear_ultrasonic_sensor();
  ::osi3::UltrasonicDetectionData* mutable_ultrasonic_sensor(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::UltrasonicDetectionData >*
      mutable_ultrasonic_sensor();
  const ::osi3::UltrasonicDetectionData& ultrasonic_sensor(int index) const;
  ::osi3::UltrasonicDetectionData* add_ultrasonic_sensor();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::UltrasonicDetectionData >&
      ultrasonic_sensor() const;

  // repeated .osi3.CameraDetectionData camera_sensor = 5;
  int camera_sensor_size() const;
  void clear_camera_sensor();
  ::osi3::CameraDetectionData* mutable_camera_sensor(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::CameraDetectionData >*
      mutable_camera_sensor();
  const ::osi3::CameraDetectionData& camera_sensor(int index) const;
  ::osi3::CameraDetectionData* add_camera_sensor();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::CameraDetectionData >&
      camera_sensor() const;

  // .osi3.InterfaceVersion version = 1;
  bool has_version() const;
  void clear_version();
  const ::osi3::InterfaceVersion& version() const;
  ::osi3::InterfaceVersion* release_version();
  ::osi3::InterfaceVersion* mutable_version();
  void set_allocated_version(::osi3::InterfaceVersion* version);

  // @@protoc_insertion_point(class_scope:osi3.FeatureData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::RadarDetectionData > radar_sensor_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::LidarDetectionData > lidar_sensor_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::UltrasonicDetectionData > ultrasonic_sensor_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::CameraDetectionData > camera_sensor_;
  ::osi3::InterfaceVersion* version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class SensorDetectionHeader :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:osi3.SensorDetectionHeader) */ {
 public:
  SensorDetectionHeader();
  virtual ~SensorDetectionHeader();

  SensorDetectionHeader(const SensorDetectionHeader& from);
  SensorDetectionHeader(SensorDetectionHeader&& from) noexcept
    : SensorDetectionHeader() {
    *this = ::std::move(from);
  }

  inline SensorDetectionHeader& operator=(const SensorDetectionHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorDetectionHeader& operator=(SensorDetectionHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SensorDetectionHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorDetectionHeader* internal_default_instance() {
    return reinterpret_cast<const SensorDetectionHeader*>(
               &_SensorDetectionHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SensorDetectionHeader& a, SensorDetectionHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorDetectionHeader* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SensorDetectionHeader* New() const final {
    return CreateMaybeMessage<SensorDetectionHeader>(nullptr);
  }

  SensorDetectionHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SensorDetectionHeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SensorDetectionHeader& from);
  void MergeFrom(const SensorDetectionHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorDetectionHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "osi3.SensorDetectionHeader";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_osi_5ffeaturedata_2eproto);
    return ::descriptor_table_osi_5ffeaturedata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SensorDetectionHeader_DataQualifier DataQualifier;
  static constexpr DataQualifier DATA_QUALIFIER_UNKNOWN =
    SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_UNKNOWN;
  static constexpr DataQualifier DATA_QUALIFIER_OTHER =
    SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_OTHER;
  static constexpr DataQualifier DATA_QUALIFIER_AVAILABLE =
    SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_AVAILABLE;
  static constexpr DataQualifier DATA_QUALIFIER_AVAILABLE_REDUCED =
    SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_AVAILABLE_REDUCED;
  static constexpr DataQualifier DATA_QUALIFIER_NOT_AVAILABLE =
    SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_NOT_AVAILABLE;
  static constexpr DataQualifier DATA_QUALIFIER_BLINDNESS =
    SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_BLINDNESS;
  static constexpr DataQualifier DATA_QUALIFIER_TEMPORARY_AVAILABLE =
    SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_TEMPORARY_AVAILABLE;
  static constexpr DataQualifier DATA_QUALIFIER_INVALID =
    SensorDetectionHeader_DataQualifier_DATA_QUALIFIER_INVALID;
  static inline bool DataQualifier_IsValid(int value) {
    return SensorDetectionHeader_DataQualifier_IsValid(value);
  }
  static constexpr DataQualifier DataQualifier_MIN =
    SensorDetectionHeader_DataQualifier_DataQualifier_MIN;
  static constexpr DataQualifier DataQualifier_MAX =
    SensorDetectionHeader_DataQualifier_DataQualifier_MAX;
  static constexpr int DataQualifier_ARRAYSIZE =
    SensorDetectionHeader_DataQualifier_DataQualifier_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DataQualifier_descriptor() {
    return SensorDetectionHeader_DataQualifier_descriptor();
  }
  template<typename T>
  static inline const std::string& DataQualifier_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DataQualifier>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DataQualifier_Name.");
    return SensorDetectionHeader_DataQualifier_Name(enum_t_value);
  }
  static inline bool DataQualifier_Parse(const std::string& name,
      DataQualifier* value) {
    return SensorDetectionHeader_DataQualifier_Parse(name, value);
  }

  typedef SensorDetectionHeader_ExtendedQualifier ExtendedQualifier;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_UNKNOWN =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_UNKNOWN;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_OTHER =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_OTHER;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_NORMAL_OPERATION_MODE =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_NORMAL_OPERATION_MODE;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_POWER_UP_OR_DOWN =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_POWER_UP_OR_DOWN;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_SENSOR_NOT_CALIBRATED =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_SENSOR_NOT_CALIBRATED;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_SENSOR_BLOCKED =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_SENSOR_BLOCKED;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_SENSOR_MISALIGNED =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_SENSOR_MISALIGNED;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_BAD_SENSOR_ENVIRONMENTAL_CONDITION =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_BAD_SENSOR_ENVIRONMENTAL_CONDITION;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_REDUCED_FIELD_OF_VIEW =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_REDUCED_FIELD_OF_VIEW;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_INPUT_NOT_AVAILABLE =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_INPUT_NOT_AVAILABLE;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_INTERNAL_REASON =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_INTERNAL_REASON;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_EXTERNAL_DISTURBANCE =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_EXTERNAL_DISTURBANCE;
  static constexpr ExtendedQualifier EXTENDED_QUALIFIER_BEGINNING_BLOCKAGE =
    SensorDetectionHeader_ExtendedQualifier_EXTENDED_QUALIFIER_BEGINNING_BLOCKAGE;
  static inline bool ExtendedQualifier_IsValid(int value) {
    return SensorDetectionHeader_ExtendedQualifier_IsValid(value);
  }
  static constexpr ExtendedQualifier ExtendedQualifier_MIN =
    SensorDetectionHeader_ExtendedQualifier_ExtendedQualifier_MIN;
  static constexpr ExtendedQualifier ExtendedQualifier_MAX =
    SensorDetectionHeader_ExtendedQualifier_ExtendedQualifier_MAX;
  static constexpr int ExtendedQualifier_ARRAYSIZE =
    SensorDetectionHeader_ExtendedQualifier_ExtendedQualifier_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ExtendedQualifier_descriptor() {
    return SensorDetectionHeader_ExtendedQualifier_descriptor();
  }
  template<typename T>
  static inline const std::string& ExtendedQualifier_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ExtendedQualifier>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ExtendedQualifier_Name.");
    return SensorDetectionHeader_ExtendedQualifier_Name(enum_t_value);
  }
  static inline bool ExtendedQualifier_Parse(const std::string& name,
      ExtendedQualifier* value) {
    return SensorDetectionHeader_ExtendedQualifier_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMeasurementTimeFieldNumber = 1,
    kMountingPositionFieldNumber = 3,
    kMountingPositionRmseFieldNumber = 4,
    kSensorIdFieldNumber = 7,
    kCycleCounterFieldNumber = 2,
    kDataQualifierFieldNumber = 5,
    kNumberOfValidDetectionsFieldNumber = 6,
    kExtendedQualifierFieldNumber = 8,
  };
  // .osi3.Timestamp measurement_time = 1;
  bool has_measurement_time() const;
  void clear_measurement_time();
  const ::osi3::Timestamp& measurement_time() const;
  ::osi3::Timestamp* release_measurement_time();
  ::osi3::Timestamp* mutable_measurement_time();
  void set_allocated_measurement_time(::osi3::Timestamp* measurement_time);

  // .osi3.MountingPosition mounting_position = 3;
  bool has_mounting_position() const;
  void clear_mounting_position();
  const ::osi3::MountingPosition& mounting_position() const;
  ::osi3::MountingPosition* release_mounting_position();
  ::osi3::MountingPosition* mutable_mounting_position();
  void set_allocated_mounting_position(::osi3::MountingPosition* mounting_position);

  // .osi3.MountingPosition mounting_position_rmse = 4;
  bool has_mounting_position_rmse() const;
  void clear_mounting_position_rmse();
  const ::osi3::MountingPosition& mounting_position_rmse() const;
  ::osi3::MountingPosition* release_mounting_position_rmse();
  ::osi3::MountingPosition* mutable_mounting_position_rmse();
  void set_allocated_mounting_position_rmse(::osi3::MountingPosition* mounting_position_rmse);

  // .osi3.Identifier sensor_id = 7;
  bool has_sensor_id() const;
  void clear_sensor_id();
  const ::osi3::Identifier& sensor_id() const;
  ::osi3::Identifier* release_sensor_id();
  ::osi3::Identifier* mutable_sensor_id();
  void set_allocated_sensor_id(::osi3::Identifier* sensor_id);

  // uint64 cycle_counter = 2;
  void clear_cycle_counter();
  ::PROTOBUF_NAMESPACE_ID::uint64 cycle_counter() const;
  void set_cycle_counter(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // .osi3.SensorDetectionHeader.DataQualifier data_qualifier = 5;
  void clear_data_qualifier();
  ::osi3::SensorDetectionHeader_DataQualifier data_qualifier() const;
  void set_data_qualifier(::osi3::SensorDetectionHeader_DataQualifier value);

  // uint32 number_of_valid_detections = 6;
  void clear_number_of_valid_detections();
  ::PROTOBUF_NAMESPACE_ID::uint32 number_of_valid_detections() const;
  void set_number_of_valid_detections(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // .osi3.SensorDetectionHeader.ExtendedQualifier extended_qualifier = 8;
  void clear_extended_qualifier();
  ::osi3::SensorDetectionHeader_ExtendedQualifier extended_qualifier() const;
  void set_extended_qualifier(::osi3::SensorDetectionHeader_ExtendedQualifier value);

  // @@protoc_insertion_point(class_scope:osi3.SensorDetectionHeader)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::osi3::Timestamp* measurement_time_;
  ::osi3::MountingPosition* mounting_position_;
  ::osi3::MountingPosition* mounting_position_rmse_;
  ::osi3::Identifier* sensor_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 cycle_counter_;
  int data_qualifier_;
  ::PROTOBUF_NAMESPACE_ID::uint32 number_of_valid_detections_;
  int extended_qualifier_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class RadarDetectionData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:osi3.RadarDetectionData) */ {
 public:
  RadarDetectionData();
  virtual ~RadarDetectionData();

  RadarDetectionData(const RadarDetectionData& from);
  RadarDetectionData(RadarDetectionData&& from) noexcept
    : RadarDetectionData() {
    *this = ::std::move(from);
  }

  inline RadarDetectionData& operator=(const RadarDetectionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadarDetectionData& operator=(RadarDetectionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RadarDetectionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RadarDetectionData* internal_default_instance() {
    return reinterpret_cast<const RadarDetectionData*>(
               &_RadarDetectionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RadarDetectionData& a, RadarDetectionData& b) {
    a.Swap(&b);
  }
  inline void Swap(RadarDetectionData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RadarDetectionData* New() const final {
    return CreateMaybeMessage<RadarDetectionData>(nullptr);
  }

  RadarDetectionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RadarDetectionData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RadarDetectionData& from);
  void MergeFrom(const RadarDetectionData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadarDetectionData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "osi3.RadarDetectionData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_osi_5ffeaturedata_2eproto);
    return ::descriptor_table_osi_5ffeaturedata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetectionFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .osi3.RadarDetection detection = 2;
  int detection_size() const;
  void clear_detection();
  ::osi3::RadarDetection* mutable_detection(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::RadarDetection >*
      mutable_detection();
  const ::osi3::RadarDetection& detection(int index) const;
  ::osi3::RadarDetection* add_detection();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::RadarDetection >&
      detection() const;

  // .osi3.SensorDetectionHeader header = 1;
  bool has_header() const;
  void clear_header();
  const ::osi3::SensorDetectionHeader& header() const;
  ::osi3::SensorDetectionHeader* release_header();
  ::osi3::SensorDetectionHeader* mutable_header();
  void set_allocated_header(::osi3::SensorDetectionHeader* header);

  // @@protoc_insertion_point(class_scope:osi3.RadarDetectionData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::RadarDetection > detection_;
  ::osi3::SensorDetectionHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class RadarDetection :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:osi3.RadarDetection) */ {
 public:
  RadarDetection();
  virtual ~RadarDetection();

  RadarDetection(const RadarDetection& from);
  RadarDetection(RadarDetection&& from) noexcept
    : RadarDetection() {
    *this = ::std::move(from);
  }

  inline RadarDetection& operator=(const RadarDetection& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadarDetection& operator=(RadarDetection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RadarDetection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RadarDetection* internal_default_instance() {
    return reinterpret_cast<const RadarDetection*>(
               &_RadarDetection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RadarDetection& a, RadarDetection& b) {
    a.Swap(&b);
  }
  inline void Swap(RadarDetection* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RadarDetection* New() const final {
    return CreateMaybeMessage<RadarDetection>(nullptr);
  }

  RadarDetection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RadarDetection>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RadarDetection& from);
  void MergeFrom(const RadarDetection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadarDetection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "osi3.RadarDetection";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_osi_5ffeaturedata_2eproto);
    return ::descriptor_table_osi_5ffeaturedata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 2,
    kPositionFieldNumber = 3,
    kPositionRmseFieldNumber = 4,
    kAmbiguityIdFieldNumber = 10,
    kExistenceProbabilityFieldNumber = 1,
    kRadialVelocityFieldNumber = 5,
    kRadialVelocityRmseFieldNumber = 6,
    kRcsFieldNumber = 7,
    kSnrFieldNumber = 8,
    kPointTargetProbabilityFieldNumber = 9,
    kClassificationFieldNumber = 11,
  };
  // .osi3.Identifier object_id = 2;
  bool has_object_id() const;
  void clear_object_id();
  const ::osi3::Identifier& object_id() const;
  ::osi3::Identifier* release_object_id();
  ::osi3::Identifier* mutable_object_id();
  void set_allocated_object_id(::osi3::Identifier* object_id);

  // .osi3.Spherical3d position = 3;
  bool has_position() const;
  void clear_position();
  const ::osi3::Spherical3d& position() const;
  ::osi3::Spherical3d* release_position();
  ::osi3::Spherical3d* mutable_position();
  void set_allocated_position(::osi3::Spherical3d* position);

  // .osi3.Spherical3d position_rmse = 4;
  bool has_position_rmse() const;
  void clear_position_rmse();
  const ::osi3::Spherical3d& position_rmse() const;
  ::osi3::Spherical3d* release_position_rmse();
  ::osi3::Spherical3d* mutable_position_rmse();
  void set_allocated_position_rmse(::osi3::Spherical3d* position_rmse);

  // .osi3.Identifier ambiguity_id = 10;
  bool has_ambiguity_id() const;
  void clear_ambiguity_id();
  const ::osi3::Identifier& ambiguity_id() const;
  ::osi3::Identifier* release_ambiguity_id();
  ::osi3::Identifier* mutable_ambiguity_id();
  void set_allocated_ambiguity_id(::osi3::Identifier* ambiguity_id);

  // double existence_probability = 1;
  void clear_existence_probability();
  double existence_probability() const;
  void set_existence_probability(double value);

  // double radial_velocity = 5;
  void clear_radial_velocity();
  double radial_velocity() const;
  void set_radial_velocity(double value);

  // double radial_velocity_rmse = 6;
  void clear_radial_velocity_rmse();
  double radial_velocity_rmse() const;
  void set_radial_velocity_rmse(double value);

  // double rcs = 7;
  void clear_rcs();
  double rcs() const;
  void set_rcs(double value);

  // double snr = 8;
  void clear_snr();
  double snr() const;
  void set_snr(double value);

  // double point_target_probability = 9;
  void clear_point_target_probability();
  double point_target_probability() const;
  void set_point_target_probability(double value);

  // .osi3.DetectionClassification classification = 11;
  void clear_classification();
  ::osi3::DetectionClassification classification() const;
  void set_classification(::osi3::DetectionClassification value);

  // @@protoc_insertion_point(class_scope:osi3.RadarDetection)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::osi3::Identifier* object_id_;
  ::osi3::Spherical3d* position_;
  ::osi3::Spherical3d* position_rmse_;
  ::osi3::Identifier* ambiguity_id_;
  double existence_probability_;
  double radial_velocity_;
  double radial_velocity_rmse_;
  double rcs_;
  double snr_;
  double point_target_probability_;
  int classification_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class LidarDetectionData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:osi3.LidarDetectionData) */ {
 public:
  LidarDetectionData();
  virtual ~LidarDetectionData();

  LidarDetectionData(const LidarDetectionData& from);
  LidarDetectionData(LidarDetectionData&& from) noexcept
    : LidarDetectionData() {
    *this = ::std::move(from);
  }

  inline LidarDetectionData& operator=(const LidarDetectionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline LidarDetectionData& operator=(LidarDetectionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LidarDetectionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LidarDetectionData* internal_default_instance() {
    return reinterpret_cast<const LidarDetectionData*>(
               &_LidarDetectionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LidarDetectionData& a, LidarDetectionData& b) {
    a.Swap(&b);
  }
  inline void Swap(LidarDetectionData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LidarDetectionData* New() const final {
    return CreateMaybeMessage<LidarDetectionData>(nullptr);
  }

  LidarDetectionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LidarDetectionData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LidarDetectionData& from);
  void MergeFrom(const LidarDetectionData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LidarDetectionData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "osi3.LidarDetectionData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_osi_5ffeaturedata_2eproto);
    return ::descriptor_table_osi_5ffeaturedata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetectionFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .osi3.LidarDetection detection = 2;
  int detection_size() const;
  void clear_detection();
  ::osi3::LidarDetection* mutable_detection(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::LidarDetection >*
      mutable_detection();
  const ::osi3::LidarDetection& detection(int index) const;
  ::osi3::LidarDetection* add_detection();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::LidarDetection >&
      detection() const;

  // .osi3.SensorDetectionHeader header = 1;
  bool has_header() const;
  void clear_header();
  const ::osi3::SensorDetectionHeader& header() const;
  ::osi3::SensorDetectionHeader* release_header();
  ::osi3::SensorDetectionHeader* mutable_header();
  void set_allocated_header(::osi3::SensorDetectionHeader* header);

  // @@protoc_insertion_point(class_scope:osi3.LidarDetectionData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::LidarDetection > detection_;
  ::osi3::SensorDetectionHeader* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class LidarDetection :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:osi3.LidarDetection) */ {
 public:
  LidarDetection();
  virtual ~LidarDetection();

  LidarDetection(const LidarDetection& from);
  LidarDetection(LidarDetection&& from) noexcept
    : LidarDetection() {
    *this = ::std::move(from);
  }

  inline LidarDetection& operator=(const LidarDetection& from) {
    CopyFrom(from);
    return *this;
  }
  inline LidarDetection& operator=(LidarDetection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LidarDetection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LidarDetection* internal_default_instance() {
    return reinterpret_cast<const LidarDetection*>(
               &_LidarDetection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LidarDetection& a, LidarDetection& b) {
    a.Swap(&b);
  }
  inline void Swap(LidarDetection* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LidarDetection* New() const final {
    return CreateMaybeMessage<LidarDetection>(nullptr);
  }

  LidarDetection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LidarDetection>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LidarDetection& from);
  void MergeFrom(const LidarDetection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LidarDetection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "osi3.LidarDetection";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_osi_5ffeaturedata_2eproto);
    return ::descriptor_table_osi_5ffeaturedata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 2,
    kPositionFieldNumber = 3,
    kPositionRmseFieldNumber = 4,
    kExistenceProbabilityFieldNumber = 1,
    kHeightFieldNumber = 5,
    kHeightRmseFieldNumber = 6,
    kIntensityFieldNumber = 7,
    kFreeSpaceProbabilityFieldNumber = 8,
    kReflectivityFieldNumber = 10,
    kEchoPulseWidthFieldNumber = 11,
    kClassificationFieldNumber = 9,
  };
  // .osi3.Identifier object_id = 2;
  bool has_object_id() const;
  void clear_object_id();
  const ::osi3::Identifier& object_id() const;
  ::osi3::Identifier* release_object_id();
  ::osi3::Identifier* mutable_object_id();
  void set_allocated_object_id(::osi3::Identifier* object_id);

  // .osi3.Spherical3d position = 3;
  bool has_position() const;
  void clear_position();
  const ::osi3::Spherical3d& position() const;
  ::osi3::Spherical3d* release_position();
  ::osi3::Spherical3d* mutable_position();
  void set_allocated_position(::osi3::Spherical3d* position);

  // .osi3.Spherical3d position_rmse = 4;
  bool has_position_rmse() const;
  void clear_position_rmse();
  const ::osi3::Spherical3d& position_rmse() const;
  ::osi3::Spherical3d* release_position_rmse();
  ::osi3::Spherical3d* mutable_position_rmse();
  void set_allocated_position_rmse(::osi3::Spherical3d* position_rmse);

  // double existence_probability = 1;
  void clear_existence_probability();
  double existence_probability() const;
  void set_existence_probability(double value);

  // double height = 5;
  void clear_height();
  double height() const;
  void set_height(double value);

  // double height_rmse = 6;
  void clear_height_rmse();
  double height_rmse() const;
  void set_height_rmse(double value);

  // double intensity = 7;
  void clear_intensity();
  double intensity() const;
  void set_intensity(double value);

  // double free_space_probability = 8;
  void clear_free_space_probability();
  double free_space_probability() const;
  void set_free_space_probability(double value);

  // double reflectivity = 10;
  void clear_reflectivity();
  double reflectivity() const;
  void set_reflectivity(double value);

  // double echo_pulse_width = 11;
  void clear_echo_pulse_width();
  double echo_pulse_width() const;
  void set_echo_pulse_width(double value);

  // .osi3.DetectionClassification classification = 9;
  void clear_classification();
  ::osi3::DetectionClassification classification() const;
  void set_classification(::osi3::DetectionClassification value);

  // @@protoc_insertion_point(class_scope:osi3.LidarDetection)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::osi3::Identifier* object_id_;
  ::osi3::Spherical3d* position_;
  ::osi3::Spherical3d* position_rmse_;
  double existence_probability_;
  double height_;
  double height_rmse_;
  double intensity_;
  double free_space_probability_;
  double reflectivity_;
  double echo_pulse_width_;
  int classification_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class UltrasonicDetectionSpecificHeader :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:osi3.UltrasonicDetectionSpecificHeader) */ {
 public:
  UltrasonicDetectionSpecificHeader();
  virtual ~UltrasonicDetectionSpecificHeader();

  UltrasonicDetectionSpecificHeader(const UltrasonicDetectionSpecificHeader& from);
  UltrasonicDetectionSpecificHeader(UltrasonicDetectionSpecificHeader&& from) noexcept
    : UltrasonicDetectionSpecificHeader() {
    *this = ::std::move(from);
  }

  inline UltrasonicDetectionSpecificHeader& operator=(const UltrasonicDetectionSpecificHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline UltrasonicDetectionSpecificHeader& operator=(UltrasonicDetectionSpecificHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UltrasonicDetectionSpecificHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UltrasonicDetectionSpecificHeader* internal_default_instance() {
    return reinterpret_cast<const UltrasonicDetectionSpecificHeader*>(
               &_UltrasonicDetectionSpecificHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UltrasonicDetectionSpecificHeader& a, UltrasonicDetectionSpecificHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(UltrasonicDetectionSpecificHeader* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UltrasonicDetectionSpecificHeader* New() const final {
    return CreateMaybeMessage<UltrasonicDetectionSpecificHeader>(nullptr);
  }

  UltrasonicDetectionSpecificHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UltrasonicDetectionSpecificHeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UltrasonicDetectionSpecificHeader& from);
  void MergeFrom(const UltrasonicDetectionSpecificHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UltrasonicDetectionSpecificHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "osi3.UltrasonicDetectionSpecificHeader";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_osi_5ffeaturedata_2eproto);
    return ::descriptor_table_osi_5ffeaturedata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxRangeFieldNumber = 1,
    kNumberOfValidIndirectDetectionsFieldNumber = 2,
  };
  // double max_range = 1;
  void clear_max_range();
  double max_range() const;
  void set_max_range(double value);

  // uint32 number_of_valid_indirect_detections = 2;
  void clear_number_of_valid_indirect_detections();
  ::PROTOBUF_NAMESPACE_ID::uint32 number_of_valid_indirect_detections() const;
  void set_number_of_valid_indirect_detections(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:osi3.UltrasonicDetectionSpecificHeader)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double max_range_;
  ::PROTOBUF_NAMESPACE_ID::uint32 number_of_valid_indirect_detections_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class UltrasonicDetectionData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:osi3.UltrasonicDetectionData) */ {
 public:
  UltrasonicDetectionData();
  virtual ~UltrasonicDetectionData();

  UltrasonicDetectionData(const UltrasonicDetectionData& from);
  UltrasonicDetectionData(UltrasonicDetectionData&& from) noexcept
    : UltrasonicDetectionData() {
    *this = ::std::move(from);
  }

  inline UltrasonicDetectionData& operator=(const UltrasonicDetectionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline UltrasonicDetectionData& operator=(UltrasonicDetectionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UltrasonicDetectionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UltrasonicDetectionData* internal_default_instance() {
    return reinterpret_cast<const UltrasonicDetectionData*>(
               &_UltrasonicDetectionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UltrasonicDetectionData& a, UltrasonicDetectionData& b) {
    a.Swap(&b);
  }
  inline void Swap(UltrasonicDetectionData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UltrasonicDetectionData* New() const final {
    return CreateMaybeMessage<UltrasonicDetectionData>(nullptr);
  }

  UltrasonicDetectionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UltrasonicDetectionData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UltrasonicDetectionData& from);
  void MergeFrom(const UltrasonicDetectionData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UltrasonicDetectionData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "osi3.UltrasonicDetectionData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_osi_5ffeaturedata_2eproto);
    return ::descriptor_table_osi_5ffeaturedata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetectionFieldNumber = 2,
    kIndirectDetectionFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kSpecificHeaderFieldNumber = 3,
  };
  // repeated .osi3.UltrasonicDetection detection = 2;
  int detection_size() const;
  void clear_detection();
  ::osi3::UltrasonicDetection* mutable_detection(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::UltrasonicDetection >*
      mutable_detection();
  const ::osi3::UltrasonicDetection& detection(int index) const;
  ::osi3::UltrasonicDetection* add_detection();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::UltrasonicDetection >&
      detection() const;

  // repeated .osi3.UltrasonicIndirectDetection indirect_detection = 4;
  int indirect_detection_size() const;
  void clear_indirect_detection();
  ::osi3::UltrasonicIndirectDetection* mutable_indirect_detection(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::UltrasonicIndirectDetection >*
      mutable_indirect_detection();
  const ::osi3::UltrasonicIndirectDetection& indirect_detection(int index) const;
  ::osi3::UltrasonicIndirectDetection* add_indirect_detection();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::UltrasonicIndirectDetection >&
      indirect_detection() const;

  // .osi3.SensorDetectionHeader header = 1;
  bool has_header() const;
  void clear_header();
  const ::osi3::SensorDetectionHeader& header() const;
  ::osi3::SensorDetectionHeader* release_header();
  ::osi3::SensorDetectionHeader* mutable_header();
  void set_allocated_header(::osi3::SensorDetectionHeader* header);

  // .osi3.UltrasonicDetectionSpecificHeader specific_header = 3;
  bool has_specific_header() const;
  void clear_specific_header();
  const ::osi3::UltrasonicDetectionSpecificHeader& specific_header() const;
  ::osi3::UltrasonicDetectionSpecificHeader* release_specific_header();
  ::osi3::UltrasonicDetectionSpecificHeader* mutable_specific_header();
  void set_allocated_specific_header(::osi3::UltrasonicDetectionSpecificHeader* specific_header);

  // @@protoc_insertion_point(class_scope:osi3.UltrasonicDetectionData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::UltrasonicDetection > detection_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::UltrasonicIndirectDetection > indirect_detection_;
  ::osi3::SensorDetectionHeader* header_;
  ::osi3::UltrasonicDetectionSpecificHeader* specific_header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class UltrasonicDetection :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:osi3.UltrasonicDetection) */ {
 public:
  UltrasonicDetection();
  virtual ~UltrasonicDetection();

  UltrasonicDetection(const UltrasonicDetection& from);
  UltrasonicDetection(UltrasonicDetection&& from) noexcept
    : UltrasonicDetection() {
    *this = ::std::move(from);
  }

  inline UltrasonicDetection& operator=(const UltrasonicDetection& from) {
    CopyFrom(from);
    return *this;
  }
  inline UltrasonicDetection& operator=(UltrasonicDetection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UltrasonicDetection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UltrasonicDetection* internal_default_instance() {
    return reinterpret_cast<const UltrasonicDetection*>(
               &_UltrasonicDetection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UltrasonicDetection& a, UltrasonicDetection& b) {
    a.Swap(&b);
  }
  inline void Swap(UltrasonicDetection* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UltrasonicDetection* New() const final {
    return CreateMaybeMessage<UltrasonicDetection>(nullptr);
  }

  UltrasonicDetection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UltrasonicDetection>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UltrasonicDetection& from);
  void MergeFrom(const UltrasonicDetection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UltrasonicDetection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "osi3.UltrasonicDetection";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_osi_5ffeaturedata_2eproto);
    return ::descriptor_table_osi_5ffeaturedata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 2,
    kExistenceProbabilityFieldNumber = 1,
    kDistanceFieldNumber = 3,
  };
  // .osi3.Identifier object_id = 2;
  bool has_object_id() const;
  void clear_object_id();
  const ::osi3::Identifier& object_id() const;
  ::osi3::Identifier* release_object_id();
  ::osi3::Identifier* mutable_object_id();
  void set_allocated_object_id(::osi3::Identifier* object_id);

  // double existence_probability = 1;
  void clear_existence_probability();
  double existence_probability() const;
  void set_existence_probability(double value);

  // double distance = 3;
  void clear_distance();
  double distance() const;
  void set_distance(double value);

  // @@protoc_insertion_point(class_scope:osi3.UltrasonicDetection)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::osi3::Identifier* object_id_;
  double existence_probability_;
  double distance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class UltrasonicIndirectDetection :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:osi3.UltrasonicIndirectDetection) */ {
 public:
  UltrasonicIndirectDetection();
  virtual ~UltrasonicIndirectDetection();

  UltrasonicIndirectDetection(const UltrasonicIndirectDetection& from);
  UltrasonicIndirectDetection(UltrasonicIndirectDetection&& from) noexcept
    : UltrasonicIndirectDetection() {
    *this = ::std::move(from);
  }

  inline UltrasonicIndirectDetection& operator=(const UltrasonicIndirectDetection& from) {
    CopyFrom(from);
    return *this;
  }
  inline UltrasonicIndirectDetection& operator=(UltrasonicIndirectDetection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UltrasonicIndirectDetection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UltrasonicIndirectDetection* internal_default_instance() {
    return reinterpret_cast<const UltrasonicIndirectDetection*>(
               &_UltrasonicIndirectDetection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UltrasonicIndirectDetection& a, UltrasonicIndirectDetection& b) {
    a.Swap(&b);
  }
  inline void Swap(UltrasonicIndirectDetection* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UltrasonicIndirectDetection* New() const final {
    return CreateMaybeMessage<UltrasonicIndirectDetection>(nullptr);
  }

  UltrasonicIndirectDetection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UltrasonicIndirectDetection>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UltrasonicIndirectDetection& from);
  void MergeFrom(const UltrasonicIndirectDetection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UltrasonicIndirectDetection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "osi3.UltrasonicIndirectDetection";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_osi_5ffeaturedata_2eproto);
    return ::descriptor_table_osi_5ffeaturedata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 2,
    kReceiverIdFieldNumber = 5,
    kReceiverOriginFieldNumber = 6,
    kExistenceProbabilityFieldNumber = 1,
    kEllipsoidRadialFieldNumber = 3,
    kEllipsoidAxialFieldNumber = 4,
  };
  // .osi3.Identifier object_id = 2;
  bool has_object_id() const;
  void clear_object_id();
  const ::osi3::Identifier& object_id() const;
  ::osi3::Identifier* release_object_id();
  ::osi3::Identifier* mutable_object_id();
  void set_allocated_object_id(::osi3::Identifier* object_id);

  // .osi3.Identifier receiver_id = 5;
  bool has_receiver_id() const;
  void clear_receiver_id();
  const ::osi3::Identifier& receiver_id() const;
  ::osi3::Identifier* release_receiver_id();
  ::osi3::Identifier* mutable_receiver_id();
  void set_allocated_receiver_id(::osi3::Identifier* receiver_id);

  // .osi3.Vector3d receiver_origin = 6;
  bool has_receiver_origin() const;
  void clear_receiver_origin();
  const ::osi3::Vector3d& receiver_origin() const;
  ::osi3::Vector3d* release_receiver_origin();
  ::osi3::Vector3d* mutable_receiver_origin();
  void set_allocated_receiver_origin(::osi3::Vector3d* receiver_origin);

  // double existence_probability = 1;
  void clear_existence_probability();
  double existence_probability() const;
  void set_existence_probability(double value);

  // double ellipsoid_radial = 3;
  void clear_ellipsoid_radial();
  double ellipsoid_radial() const;
  void set_ellipsoid_radial(double value);

  // double ellipsoid_axial = 4;
  void clear_ellipsoid_axial();
  double ellipsoid_axial() const;
  void set_ellipsoid_axial(double value);

  // @@protoc_insertion_point(class_scope:osi3.UltrasonicIndirectDetection)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::osi3::Identifier* object_id_;
  ::osi3::Identifier* receiver_id_;
  ::osi3::Vector3d* receiver_origin_;
  double existence_probability_;
  double ellipsoid_radial_;
  double ellipsoid_axial_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class CameraDetectionSpecificHeader :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:osi3.CameraDetectionSpecificHeader) */ {
 public:
  CameraDetectionSpecificHeader();
  virtual ~CameraDetectionSpecificHeader();

  CameraDetectionSpecificHeader(const CameraDetectionSpecificHeader& from);
  CameraDetectionSpecificHeader(CameraDetectionSpecificHeader&& from) noexcept
    : CameraDetectionSpecificHeader() {
    *this = ::std::move(from);
  }

  inline CameraDetectionSpecificHeader& operator=(const CameraDetectionSpecificHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraDetectionSpecificHeader& operator=(CameraDetectionSpecificHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CameraDetectionSpecificHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraDetectionSpecificHeader* internal_default_instance() {
    return reinterpret_cast<const CameraDetectionSpecificHeader*>(
               &_CameraDetectionSpecificHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CameraDetectionSpecificHeader& a, CameraDetectionSpecificHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraDetectionSpecificHeader* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CameraDetectionSpecificHeader* New() const final {
    return CreateMaybeMessage<CameraDetectionSpecificHeader>(nullptr);
  }

  CameraDetectionSpecificHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CameraDetectionSpecificHeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CameraDetectionSpecificHeader& from);
  void MergeFrom(const CameraDetectionSpecificHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraDetectionSpecificHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "osi3.CameraDetectionSpecificHeader";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_osi_5ffeaturedata_2eproto);
    return ::descriptor_table_osi_5ffeaturedata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberOfValidPointsFieldNumber = 1,
  };
  // uint32 number_of_valid_points = 1;
  void clear_number_of_valid_points();
  ::PROTOBUF_NAMESPACE_ID::uint32 number_of_valid_points() const;
  void set_number_of_valid_points(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:osi3.CameraDetectionSpecificHeader)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 number_of_valid_points_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class CameraDetectionData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:osi3.CameraDetectionData) */ {
 public:
  CameraDetectionData();
  virtual ~CameraDetectionData();

  CameraDetectionData(const CameraDetectionData& from);
  CameraDetectionData(CameraDetectionData&& from) noexcept
    : CameraDetectionData() {
    *this = ::std::move(from);
  }

  inline CameraDetectionData& operator=(const CameraDetectionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraDetectionData& operator=(CameraDetectionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CameraDetectionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraDetectionData* internal_default_instance() {
    return reinterpret_cast<const CameraDetectionData*>(
               &_CameraDetectionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CameraDetectionData& a, CameraDetectionData& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraDetectionData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CameraDetectionData* New() const final {
    return CreateMaybeMessage<CameraDetectionData>(nullptr);
  }

  CameraDetectionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CameraDetectionData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CameraDetectionData& from);
  void MergeFrom(const CameraDetectionData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraDetectionData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "osi3.CameraDetectionData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_osi_5ffeaturedata_2eproto);
    return ::descriptor_table_osi_5ffeaturedata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDetectionFieldNumber = 2,
    kPointFieldNumber = 4,
    kHeaderFieldNumber = 1,
    kSpecificHeaderFieldNumber = 3,
  };
  // repeated .osi3.CameraDetection detection = 2;
  int detection_size() const;
  void clear_detection();
  ::osi3::CameraDetection* mutable_detection(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::CameraDetection >*
      mutable_detection();
  const ::osi3::CameraDetection& detection(int index) const;
  ::osi3::CameraDetection* add_detection();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::CameraDetection >&
      detection() const;

  // repeated .osi3.CameraPoint point = 4;
  int point_size() const;
  void clear_point();
  ::osi3::CameraPoint* mutable_point(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::CameraPoint >*
      mutable_point();
  const ::osi3::CameraPoint& point(int index) const;
  ::osi3::CameraPoint* add_point();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::CameraPoint >&
      point() const;

  // .osi3.SensorDetectionHeader header = 1;
  bool has_header() const;
  void clear_header();
  const ::osi3::SensorDetectionHeader& header() const;
  ::osi3::SensorDetectionHeader* release_header();
  ::osi3::SensorDetectionHeader* mutable_header();
  void set_allocated_header(::osi3::SensorDetectionHeader* header);

  // .osi3.CameraDetectionSpecificHeader specific_header = 3;
  bool has_specific_header() const;
  void clear_specific_header();
  const ::osi3::CameraDetectionSpecificHeader& specific_header() const;
  ::osi3::CameraDetectionSpecificHeader* release_specific_header();
  ::osi3::CameraDetectionSpecificHeader* mutable_specific_header();
  void set_allocated_specific_header(::osi3::CameraDetectionSpecificHeader* specific_header);

  // @@protoc_insertion_point(class_scope:osi3.CameraDetectionData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::CameraDetection > detection_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::CameraPoint > point_;
  ::osi3::SensorDetectionHeader* header_;
  ::osi3::CameraDetectionSpecificHeader* specific_header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class CameraDetection :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:osi3.CameraDetection) */ {
 public:
  CameraDetection();
  virtual ~CameraDetection();

  CameraDetection(const CameraDetection& from);
  CameraDetection(CameraDetection&& from) noexcept
    : CameraDetection() {
    *this = ::std::move(from);
  }

  inline CameraDetection& operator=(const CameraDetection& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraDetection& operator=(CameraDetection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CameraDetection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraDetection* internal_default_instance() {
    return reinterpret_cast<const CameraDetection*>(
               &_CameraDetection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CameraDetection& a, CameraDetection& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraDetection* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CameraDetection* New() const final {
    return CreateMaybeMessage<CameraDetection>(nullptr);
  }

  CameraDetection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CameraDetection>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CameraDetection& from);
  void MergeFrom(const CameraDetection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraDetection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "osi3.CameraDetection";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_osi_5ffeaturedata_2eproto);
    return ::descriptor_table_osi_5ffeaturedata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef CameraDetection_Color Color;
  static constexpr Color COLOR_UNKNOWN =
    CameraDetection_Color_COLOR_UNKNOWN;
  static constexpr Color COLOR_OTHER =
    CameraDetection_Color_COLOR_OTHER;
  static constexpr Color COLOR_BLACK =
    CameraDetection_Color_COLOR_BLACK;
  static constexpr Color COLOR_GREY =
    CameraDetection_Color_COLOR_GREY;
  static constexpr Color COLOR_WHITE =
    CameraDetection_Color_COLOR_WHITE;
  static constexpr Color COLOR_YELLOW =
    CameraDetection_Color_COLOR_YELLOW;
  static constexpr Color COLOR_ORANGE =
    CameraDetection_Color_COLOR_ORANGE;
  static constexpr Color COLOR_RED =
    CameraDetection_Color_COLOR_RED;
  static constexpr Color COLOR_VIOLET =
    CameraDetection_Color_COLOR_VIOLET;
  static constexpr Color COLOR_BLUE =
    CameraDetection_Color_COLOR_BLUE;
  static constexpr Color COLOR_GREEN =
    CameraDetection_Color_COLOR_GREEN;
  static constexpr Color COLOR_REFLECTIVE =
    CameraDetection_Color_COLOR_REFLECTIVE;
  static inline bool Color_IsValid(int value) {
    return CameraDetection_Color_IsValid(value);
  }
  static constexpr Color Color_MIN =
    CameraDetection_Color_Color_MIN;
  static constexpr Color Color_MAX =
    CameraDetection_Color_Color_MAX;
  static constexpr int Color_ARRAYSIZE =
    CameraDetection_Color_Color_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Color_descriptor() {
    return CameraDetection_Color_descriptor();
  }
  template<typename T>
  static inline const std::string& Color_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Color>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Color_Name.");
    return CameraDetection_Color_Name(enum_t_value);
  }
  static inline bool Color_Parse(const std::string& name,
      Color* value) {
    return CameraDetection_Color_Parse(name, value);
  }

  typedef CameraDetection_ImageShapeType ImageShapeType;
  static constexpr ImageShapeType IMAGE_SHAPE_TYPE_UNKNOWN =
    CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_UNKNOWN;
  static constexpr ImageShapeType IMAGE_SHAPE_TYPE_OTHER =
    CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_OTHER;
  static constexpr ImageShapeType IMAGE_SHAPE_TYPE_POINT =
    CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POINT;
  static constexpr ImageShapeType IMAGE_SHAPE_TYPE_BOX =
    CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_BOX;
  static constexpr ImageShapeType IMAGE_SHAPE_TYPE_ELLIPSE =
    CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_ELLIPSE;
  static constexpr ImageShapeType IMAGE_SHAPE_TYPE_POLYGON =
    CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POLYGON;
  static constexpr ImageShapeType IMAGE_SHAPE_TYPE_POLYLINE =
    CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POLYLINE;
  static constexpr ImageShapeType IMAGE_SHAPE_TYPE_POINT_CLOUD =
    CameraDetection_ImageShapeType_IMAGE_SHAPE_TYPE_POINT_CLOUD;
  static inline bool ImageShapeType_IsValid(int value) {
    return CameraDetection_ImageShapeType_IsValid(value);
  }
  static constexpr ImageShapeType ImageShapeType_MIN =
    CameraDetection_ImageShapeType_ImageShapeType_MIN;
  static constexpr ImageShapeType ImageShapeType_MAX =
    CameraDetection_ImageShapeType_ImageShapeType_MAX;
  static constexpr int ImageShapeType_ARRAYSIZE =
    CameraDetection_ImageShapeType_ImageShapeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ImageShapeType_descriptor() {
    return CameraDetection_ImageShapeType_descriptor();
  }
  template<typename T>
  static inline const std::string& ImageShapeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ImageShapeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ImageShapeType_Name.");
    return CameraDetection_ImageShapeType_Name(enum_t_value);
  }
  static inline bool ImageShapeType_Parse(const std::string& name,
      ImageShapeType* value) {
    return CameraDetection_ImageShapeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kObjectIdFieldNumber = 2,
    kTimeDifferenceFieldNumber = 3,
    kAmbiguityIdFieldNumber = 30,
    kColorDescriptionFieldNumber = 33,
    kExistenceProbabilityFieldNumber = 1,
    kImageShapeTypeFieldNumber = 4,
    kShapeClassificationBackgroundFieldNumber = 5,
    kShapeClassificationForegroundFieldNumber = 6,
    kShapeClassificationFlatFieldNumber = 7,
    kShapeClassificationUprightFieldNumber = 8,
    kShapeClassificationGroundFieldNumber = 9,
    kShapeClassificationSkyFieldNumber = 10,
    kShapeClassificationVegetationFieldNumber = 11,
    kShapeClassificationRoadFieldNumber = 12,
    kShapeClassificationNonDrivingLaneFieldNumber = 13,
    kShapeClassificationNonRoadFieldNumber = 14,
    kShapeClassificationStationaryObjectFieldNumber = 15,
    kShapeClassificationMovingObjectFieldNumber = 16,
    kShapeClassificationLandmarkFieldNumber = 17,
    kShapeClassificationTrafficSignFieldNumber = 18,
    kShapeClassificationTrafficLightFieldNumber = 19,
    kShapeClassificationRoadMarkingFieldNumber = 20,
    kShapeClassificationVehicleFieldNumber = 21,
    kShapeClassificationPedestrianFieldNumber = 22,
    kShapeClassificationAnimalFieldNumber = 23,
    kShapeClassificationPedestrianFrontFieldNumber = 24,
    kShapeClassificationPedestrianSideFieldNumber = 25,
    kShapeClassificationPedestrianRearFieldNumber = 26,
    kColorFieldNumber = 28,
    kShapeClassificationProbabilityFieldNumber = 27,
    kColorProbabilityFieldNumber = 29,
    kFirstPointIndexFieldNumber = 31,
    kNumberOfPointsFieldNumber = 32,
  };
  // .osi3.Identifier object_id = 2;
  bool has_object_id() const;
  void clear_object_id();
  const ::osi3::Identifier& object_id() const;
  ::osi3::Identifier* release_object_id();
  ::osi3::Identifier* mutable_object_id();
  void set_allocated_object_id(::osi3::Identifier* object_id);

  // .osi3.Timestamp time_difference = 3;
  bool has_time_difference() const;
  void clear_time_difference();
  const ::osi3::Timestamp& time_difference() const;
  ::osi3::Timestamp* release_time_difference();
  ::osi3::Timestamp* mutable_time_difference();
  void set_allocated_time_difference(::osi3::Timestamp* time_difference);

  // .osi3.Identifier ambiguity_id = 30;
  bool has_ambiguity_id() const;
  void clear_ambiguity_id();
  const ::osi3::Identifier& ambiguity_id() const;
  ::osi3::Identifier* release_ambiguity_id();
  ::osi3::Identifier* mutable_ambiguity_id();
  void set_allocated_ambiguity_id(::osi3::Identifier* ambiguity_id);

  // .osi3.ColorDescription color_description = 33;
  bool has_color_description() const;
  void clear_color_description();
  const ::osi3::ColorDescription& color_description() const;
  ::osi3::ColorDescription* release_color_description();
  ::osi3::ColorDescription* mutable_color_description();
  void set_allocated_color_description(::osi3::ColorDescription* color_description);

  // double existence_probability = 1;
  void clear_existence_probability();
  double existence_probability() const;
  void set_existence_probability(double value);

  // .osi3.CameraDetection.ImageShapeType image_shape_type = 4;
  void clear_image_shape_type();
  ::osi3::CameraDetection_ImageShapeType image_shape_type() const;
  void set_image_shape_type(::osi3::CameraDetection_ImageShapeType value);

  // bool shape_classification_background = 5;
  void clear_shape_classification_background();
  bool shape_classification_background() const;
  void set_shape_classification_background(bool value);

  // bool shape_classification_foreground = 6;
  void clear_shape_classification_foreground();
  bool shape_classification_foreground() const;
  void set_shape_classification_foreground(bool value);

  // bool shape_classification_flat = 7;
  void clear_shape_classification_flat();
  bool shape_classification_flat() const;
  void set_shape_classification_flat(bool value);

  // bool shape_classification_upright = 8;
  void clear_shape_classification_upright();
  bool shape_classification_upright() const;
  void set_shape_classification_upright(bool value);

  // bool shape_classification_ground = 9;
  void clear_shape_classification_ground();
  bool shape_classification_ground() const;
  void set_shape_classification_ground(bool value);

  // bool shape_classification_sky = 10;
  void clear_shape_classification_sky();
  bool shape_classification_sky() const;
  void set_shape_classification_sky(bool value);

  // bool shape_classification_vegetation = 11;
  void clear_shape_classification_vegetation();
  bool shape_classification_vegetation() const;
  void set_shape_classification_vegetation(bool value);

  // bool shape_classification_road = 12;
  void clear_shape_classification_road();
  bool shape_classification_road() const;
  void set_shape_classification_road(bool value);

  // bool shape_classification_non_driving_lane = 13;
  void clear_shape_classification_non_driving_lane();
  bool shape_classification_non_driving_lane() const;
  void set_shape_classification_non_driving_lane(bool value);

  // bool shape_classification_non_road = 14;
  void clear_shape_classification_non_road();
  bool shape_classification_non_road() const;
  void set_shape_classification_non_road(bool value);

  // bool shape_classification_stationary_object = 15;
  void clear_shape_classification_stationary_object();
  bool shape_classification_stationary_object() const;
  void set_shape_classification_stationary_object(bool value);

  // bool shape_classification_moving_object = 16;
  void clear_shape_classification_moving_object();
  bool shape_classification_moving_object() const;
  void set_shape_classification_moving_object(bool value);

  // bool shape_classification_landmark = 17;
  void clear_shape_classification_landmark();
  bool shape_classification_landmark() const;
  void set_shape_classification_landmark(bool value);

  // bool shape_classification_traffic_sign = 18;
  void clear_shape_classification_traffic_sign();
  bool shape_classification_traffic_sign() const;
  void set_shape_classification_traffic_sign(bool value);

  // bool shape_classification_traffic_light = 19;
  void clear_shape_classification_traffic_light();
  bool shape_classification_traffic_light() const;
  void set_shape_classification_traffic_light(bool value);

  // bool shape_classification_road_marking = 20;
  void clear_shape_classification_road_marking();
  bool shape_classification_road_marking() const;
  void set_shape_classification_road_marking(bool value);

  // bool shape_classification_vehicle = 21;
  void clear_shape_classification_vehicle();
  bool shape_classification_vehicle() const;
  void set_shape_classification_vehicle(bool value);

  // bool shape_classification_pedestrian = 22;
  void clear_shape_classification_pedestrian();
  bool shape_classification_pedestrian() const;
  void set_shape_classification_pedestrian(bool value);

  // bool shape_classification_animal = 23;
  void clear_shape_classification_animal();
  bool shape_classification_animal() const;
  void set_shape_classification_animal(bool value);

  // bool shape_classification_pedestrian_front = 24;
  void clear_shape_classification_pedestrian_front();
  bool shape_classification_pedestrian_front() const;
  void set_shape_classification_pedestrian_front(bool value);

  // bool shape_classification_pedestrian_side = 25;
  void clear_shape_classification_pedestrian_side();
  bool shape_classification_pedestrian_side() const;
  void set_shape_classification_pedestrian_side(bool value);

  // bool shape_classification_pedestrian_rear = 26;
  void clear_shape_classification_pedestrian_rear();
  bool shape_classification_pedestrian_rear() const;
  void set_shape_classification_pedestrian_rear(bool value);

  // .osi3.CameraDetection.Color color = 28;
  void clear_color();
  ::osi3::CameraDetection_Color color() const;
  void set_color(::osi3::CameraDetection_Color value);

  // double shape_classification_probability = 27;
  void clear_shape_classification_probability();
  double shape_classification_probability() const;
  void set_shape_classification_probability(double value);

  // double color_probability = 29;
  void clear_color_probability();
  double color_probability() const;
  void set_color_probability(double value);

  // uint32 first_point_index = 31;
  void clear_first_point_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 first_point_index() const;
  void set_first_point_index(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // uint32 number_of_points = 32;
  void clear_number_of_points();
  ::PROTOBUF_NAMESPACE_ID::uint32 number_of_points() const;
  void set_number_of_points(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:osi3.CameraDetection)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::osi3::Identifier* object_id_;
  ::osi3::Timestamp* time_difference_;
  ::osi3::Identifier* ambiguity_id_;
  ::osi3::ColorDescription* color_description_;
  double existence_probability_;
  int image_shape_type_;
  bool shape_classification_background_;
  bool shape_classification_foreground_;
  bool shape_classification_flat_;
  bool shape_classification_upright_;
  bool shape_classification_ground_;
  bool shape_classification_sky_;
  bool shape_classification_vegetation_;
  bool shape_classification_road_;
  bool shape_classification_non_driving_lane_;
  bool shape_classification_non_road_;
  bool shape_classification_stationary_object_;
  bool shape_classification_moving_object_;
  bool shape_classification_landmark_;
  bool shape_classification_traffic_sign_;
  bool shape_classification_traffic_light_;
  bool shape_classification_road_marking_;
  bool shape_classification_vehicle_;
  bool shape_classification_pedestrian_;
  bool shape_classification_animal_;
  bool shape_classification_pedestrian_front_;
  bool shape_classification_pedestrian_side_;
  bool shape_classification_pedestrian_rear_;
  int color_;
  double shape_classification_probability_;
  double color_probability_;
  ::PROTOBUF_NAMESPACE_ID::uint32 first_point_index_;
  ::PROTOBUF_NAMESPACE_ID::uint32 number_of_points_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// -------------------------------------------------------------------

class CameraPoint :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:osi3.CameraPoint) */ {
 public:
  CameraPoint();
  virtual ~CameraPoint();

  CameraPoint(const CameraPoint& from);
  CameraPoint(CameraPoint&& from) noexcept
    : CameraPoint() {
    *this = ::std::move(from);
  }

  inline CameraPoint& operator=(const CameraPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraPoint& operator=(CameraPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CameraPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraPoint* internal_default_instance() {
    return reinterpret_cast<const CameraPoint*>(
               &_CameraPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CameraPoint& a, CameraPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraPoint* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CameraPoint* New() const final {
    return CreateMaybeMessage<CameraPoint>(nullptr);
  }

  CameraPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CameraPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CameraPoint& from);
  void MergeFrom(const CameraPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "osi3.CameraPoint";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_osi_5ffeaturedata_2eproto);
    return ::descriptor_table_osi_5ffeaturedata_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointFieldNumber = 2,
    kPointRmseFieldNumber = 3,
    kExistenceProbabilityFieldNumber = 1,
  };
  // .osi3.Spherical3d point = 2;
  bool has_point() const;
  void clear_point();
  const ::osi3::Spherical3d& point() const;
  ::osi3::Spherical3d* release_point();
  ::osi3::Spherical3d* mutable_point();
  void set_allocated_point(::osi3::Spherical3d* point);

  // .osi3.Spherical3d point_rmse = 3;
  bool has_point_rmse() const;
  void clear_point_rmse();
  const ::osi3::Spherical3d& point_rmse() const;
  ::osi3::Spherical3d* release_point_rmse();
  ::osi3::Spherical3d* mutable_point_rmse();
  void set_allocated_point_rmse(::osi3::Spherical3d* point_rmse);

  // double existence_probability = 1;
  void clear_existence_probability();
  double existence_probability() const;
  void set_existence_probability(double value);

  // @@protoc_insertion_point(class_scope:osi3.CameraPoint)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::osi3::Spherical3d* point_;
  ::osi3::Spherical3d* point_rmse_;
  double existence_probability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_osi_5ffeaturedata_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FeatureData

// .osi3.InterfaceVersion version = 1;
inline bool FeatureData::has_version() const {
  return this != internal_default_instance() && version_ != nullptr;
}
inline const ::osi3::InterfaceVersion& FeatureData::version() const {
  const ::osi3::InterfaceVersion* p = version_;
  // @@protoc_insertion_point(field_get:osi3.FeatureData.version)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::InterfaceVersion*>(
      &::osi3::_InterfaceVersion_default_instance_);
}
inline ::osi3::InterfaceVersion* FeatureData::release_version() {
  // @@protoc_insertion_point(field_release:osi3.FeatureData.version)
  
  ::osi3::InterfaceVersion* temp = version_;
  version_ = nullptr;
  return temp;
}
inline ::osi3::InterfaceVersion* FeatureData::mutable_version() {
  
  if (version_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::InterfaceVersion>(GetArenaNoVirtual());
    version_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.FeatureData.version)
  return version_;
}
inline void FeatureData::set_allocated_version(::osi3::InterfaceVersion* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(version_);
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:osi3.FeatureData.version)
}

// repeated .osi3.RadarDetectionData radar_sensor = 2;
inline int FeatureData::radar_sensor_size() const {
  return radar_sensor_.size();
}
inline void FeatureData::clear_radar_sensor() {
  radar_sensor_.Clear();
}
inline ::osi3::RadarDetectionData* FeatureData::mutable_radar_sensor(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.FeatureData.radar_sensor)
  return radar_sensor_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::RadarDetectionData >*
FeatureData::mutable_radar_sensor() {
  // @@protoc_insertion_point(field_mutable_list:osi3.FeatureData.radar_sensor)
  return &radar_sensor_;
}
inline const ::osi3::RadarDetectionData& FeatureData::radar_sensor(int index) const {
  // @@protoc_insertion_point(field_get:osi3.FeatureData.radar_sensor)
  return radar_sensor_.Get(index);
}
inline ::osi3::RadarDetectionData* FeatureData::add_radar_sensor() {
  // @@protoc_insertion_point(field_add:osi3.FeatureData.radar_sensor)
  return radar_sensor_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::RadarDetectionData >&
FeatureData::radar_sensor() const {
  // @@protoc_insertion_point(field_list:osi3.FeatureData.radar_sensor)
  return radar_sensor_;
}

// repeated .osi3.LidarDetectionData lidar_sensor = 3;
inline int FeatureData::lidar_sensor_size() const {
  return lidar_sensor_.size();
}
inline void FeatureData::clear_lidar_sensor() {
  lidar_sensor_.Clear();
}
inline ::osi3::LidarDetectionData* FeatureData::mutable_lidar_sensor(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.FeatureData.lidar_sensor)
  return lidar_sensor_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::LidarDetectionData >*
FeatureData::mutable_lidar_sensor() {
  // @@protoc_insertion_point(field_mutable_list:osi3.FeatureData.lidar_sensor)
  return &lidar_sensor_;
}
inline const ::osi3::LidarDetectionData& FeatureData::lidar_sensor(int index) const {
  // @@protoc_insertion_point(field_get:osi3.FeatureData.lidar_sensor)
  return lidar_sensor_.Get(index);
}
inline ::osi3::LidarDetectionData* FeatureData::add_lidar_sensor() {
  // @@protoc_insertion_point(field_add:osi3.FeatureData.lidar_sensor)
  return lidar_sensor_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::LidarDetectionData >&
FeatureData::lidar_sensor() const {
  // @@protoc_insertion_point(field_list:osi3.FeatureData.lidar_sensor)
  return lidar_sensor_;
}

// repeated .osi3.UltrasonicDetectionData ultrasonic_sensor = 4;
inline int FeatureData::ultrasonic_sensor_size() const {
  return ultrasonic_sensor_.size();
}
inline void FeatureData::clear_ultrasonic_sensor() {
  ultrasonic_sensor_.Clear();
}
inline ::osi3::UltrasonicDetectionData* FeatureData::mutable_ultrasonic_sensor(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.FeatureData.ultrasonic_sensor)
  return ultrasonic_sensor_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::UltrasonicDetectionData >*
FeatureData::mutable_ultrasonic_sensor() {
  // @@protoc_insertion_point(field_mutable_list:osi3.FeatureData.ultrasonic_sensor)
  return &ultrasonic_sensor_;
}
inline const ::osi3::UltrasonicDetectionData& FeatureData::ultrasonic_sensor(int index) const {
  // @@protoc_insertion_point(field_get:osi3.FeatureData.ultrasonic_sensor)
  return ultrasonic_sensor_.Get(index);
}
inline ::osi3::UltrasonicDetectionData* FeatureData::add_ultrasonic_sensor() {
  // @@protoc_insertion_point(field_add:osi3.FeatureData.ultrasonic_sensor)
  return ultrasonic_sensor_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::UltrasonicDetectionData >&
FeatureData::ultrasonic_sensor() const {
  // @@protoc_insertion_point(field_list:osi3.FeatureData.ultrasonic_sensor)
  return ultrasonic_sensor_;
}

// repeated .osi3.CameraDetectionData camera_sensor = 5;
inline int FeatureData::camera_sensor_size() const {
  return camera_sensor_.size();
}
inline void FeatureData::clear_camera_sensor() {
  camera_sensor_.Clear();
}
inline ::osi3::CameraDetectionData* FeatureData::mutable_camera_sensor(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.FeatureData.camera_sensor)
  return camera_sensor_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::CameraDetectionData >*
FeatureData::mutable_camera_sensor() {
  // @@protoc_insertion_point(field_mutable_list:osi3.FeatureData.camera_sensor)
  return &camera_sensor_;
}
inline const ::osi3::CameraDetectionData& FeatureData::camera_sensor(int index) const {
  // @@protoc_insertion_point(field_get:osi3.FeatureData.camera_sensor)
  return camera_sensor_.Get(index);
}
inline ::osi3::CameraDetectionData* FeatureData::add_camera_sensor() {
  // @@protoc_insertion_point(field_add:osi3.FeatureData.camera_sensor)
  return camera_sensor_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::CameraDetectionData >&
FeatureData::camera_sensor() const {
  // @@protoc_insertion_point(field_list:osi3.FeatureData.camera_sensor)
  return camera_sensor_;
}

// -------------------------------------------------------------------

// SensorDetectionHeader

// .osi3.Timestamp measurement_time = 1;
inline bool SensorDetectionHeader::has_measurement_time() const {
  return this != internal_default_instance() && measurement_time_ != nullptr;
}
inline const ::osi3::Timestamp& SensorDetectionHeader::measurement_time() const {
  const ::osi3::Timestamp* p = measurement_time_;
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.measurement_time)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::Timestamp*>(
      &::osi3::_Timestamp_default_instance_);
}
inline ::osi3::Timestamp* SensorDetectionHeader::release_measurement_time() {
  // @@protoc_insertion_point(field_release:osi3.SensorDetectionHeader.measurement_time)
  
  ::osi3::Timestamp* temp = measurement_time_;
  measurement_time_ = nullptr;
  return temp;
}
inline ::osi3::Timestamp* SensorDetectionHeader::mutable_measurement_time() {
  
  if (measurement_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::Timestamp>(GetArenaNoVirtual());
    measurement_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.SensorDetectionHeader.measurement_time)
  return measurement_time_;
}
inline void SensorDetectionHeader::set_allocated_measurement_time(::osi3::Timestamp* measurement_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(measurement_time_);
  }
  if (measurement_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      measurement_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, measurement_time, submessage_arena);
    }
    
  } else {
    
  }
  measurement_time_ = measurement_time;
  // @@protoc_insertion_point(field_set_allocated:osi3.SensorDetectionHeader.measurement_time)
}

// uint64 cycle_counter = 2;
inline void SensorDetectionHeader::clear_cycle_counter() {
  cycle_counter_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SensorDetectionHeader::cycle_counter() const {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.cycle_counter)
  return cycle_counter_;
}
inline void SensorDetectionHeader::set_cycle_counter(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  cycle_counter_ = value;
  // @@protoc_insertion_point(field_set:osi3.SensorDetectionHeader.cycle_counter)
}

// .osi3.MountingPosition mounting_position = 3;
inline bool SensorDetectionHeader::has_mounting_position() const {
  return this != internal_default_instance() && mounting_position_ != nullptr;
}
inline const ::osi3::MountingPosition& SensorDetectionHeader::mounting_position() const {
  const ::osi3::MountingPosition* p = mounting_position_;
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.mounting_position)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::MountingPosition*>(
      &::osi3::_MountingPosition_default_instance_);
}
inline ::osi3::MountingPosition* SensorDetectionHeader::release_mounting_position() {
  // @@protoc_insertion_point(field_release:osi3.SensorDetectionHeader.mounting_position)
  
  ::osi3::MountingPosition* temp = mounting_position_;
  mounting_position_ = nullptr;
  return temp;
}
inline ::osi3::MountingPosition* SensorDetectionHeader::mutable_mounting_position() {
  
  if (mounting_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::MountingPosition>(GetArenaNoVirtual());
    mounting_position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.SensorDetectionHeader.mounting_position)
  return mounting_position_;
}
inline void SensorDetectionHeader::set_allocated_mounting_position(::osi3::MountingPosition* mounting_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(mounting_position_);
  }
  if (mounting_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      mounting_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mounting_position, submessage_arena);
    }
    
  } else {
    
  }
  mounting_position_ = mounting_position;
  // @@protoc_insertion_point(field_set_allocated:osi3.SensorDetectionHeader.mounting_position)
}

// .osi3.MountingPosition mounting_position_rmse = 4;
inline bool SensorDetectionHeader::has_mounting_position_rmse() const {
  return this != internal_default_instance() && mounting_position_rmse_ != nullptr;
}
inline const ::osi3::MountingPosition& SensorDetectionHeader::mounting_position_rmse() const {
  const ::osi3::MountingPosition* p = mounting_position_rmse_;
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.mounting_position_rmse)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::MountingPosition*>(
      &::osi3::_MountingPosition_default_instance_);
}
inline ::osi3::MountingPosition* SensorDetectionHeader::release_mounting_position_rmse() {
  // @@protoc_insertion_point(field_release:osi3.SensorDetectionHeader.mounting_position_rmse)
  
  ::osi3::MountingPosition* temp = mounting_position_rmse_;
  mounting_position_rmse_ = nullptr;
  return temp;
}
inline ::osi3::MountingPosition* SensorDetectionHeader::mutable_mounting_position_rmse() {
  
  if (mounting_position_rmse_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::MountingPosition>(GetArenaNoVirtual());
    mounting_position_rmse_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.SensorDetectionHeader.mounting_position_rmse)
  return mounting_position_rmse_;
}
inline void SensorDetectionHeader::set_allocated_mounting_position_rmse(::osi3::MountingPosition* mounting_position_rmse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(mounting_position_rmse_);
  }
  if (mounting_position_rmse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      mounting_position_rmse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mounting_position_rmse, submessage_arena);
    }
    
  } else {
    
  }
  mounting_position_rmse_ = mounting_position_rmse;
  // @@protoc_insertion_point(field_set_allocated:osi3.SensorDetectionHeader.mounting_position_rmse)
}

// .osi3.SensorDetectionHeader.DataQualifier data_qualifier = 5;
inline void SensorDetectionHeader::clear_data_qualifier() {
  data_qualifier_ = 0;
}
inline ::osi3::SensorDetectionHeader_DataQualifier SensorDetectionHeader::data_qualifier() const {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.data_qualifier)
  return static_cast< ::osi3::SensorDetectionHeader_DataQualifier >(data_qualifier_);
}
inline void SensorDetectionHeader::set_data_qualifier(::osi3::SensorDetectionHeader_DataQualifier value) {
  
  data_qualifier_ = value;
  // @@protoc_insertion_point(field_set:osi3.SensorDetectionHeader.data_qualifier)
}

// uint32 number_of_valid_detections = 6;
inline void SensorDetectionHeader::clear_number_of_valid_detections() {
  number_of_valid_detections_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SensorDetectionHeader::number_of_valid_detections() const {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.number_of_valid_detections)
  return number_of_valid_detections_;
}
inline void SensorDetectionHeader::set_number_of_valid_detections(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  number_of_valid_detections_ = value;
  // @@protoc_insertion_point(field_set:osi3.SensorDetectionHeader.number_of_valid_detections)
}

// .osi3.Identifier sensor_id = 7;
inline bool SensorDetectionHeader::has_sensor_id() const {
  return this != internal_default_instance() && sensor_id_ != nullptr;
}
inline const ::osi3::Identifier& SensorDetectionHeader::sensor_id() const {
  const ::osi3::Identifier* p = sensor_id_;
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.sensor_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::Identifier*>(
      &::osi3::_Identifier_default_instance_);
}
inline ::osi3::Identifier* SensorDetectionHeader::release_sensor_id() {
  // @@protoc_insertion_point(field_release:osi3.SensorDetectionHeader.sensor_id)
  
  ::osi3::Identifier* temp = sensor_id_;
  sensor_id_ = nullptr;
  return temp;
}
inline ::osi3::Identifier* SensorDetectionHeader::mutable_sensor_id() {
  
  if (sensor_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::Identifier>(GetArenaNoVirtual());
    sensor_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.SensorDetectionHeader.sensor_id)
  return sensor_id_;
}
inline void SensorDetectionHeader::set_allocated_sensor_id(::osi3::Identifier* sensor_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sensor_id_);
  }
  if (sensor_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sensor_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensor_id, submessage_arena);
    }
    
  } else {
    
  }
  sensor_id_ = sensor_id;
  // @@protoc_insertion_point(field_set_allocated:osi3.SensorDetectionHeader.sensor_id)
}

// .osi3.SensorDetectionHeader.ExtendedQualifier extended_qualifier = 8;
inline void SensorDetectionHeader::clear_extended_qualifier() {
  extended_qualifier_ = 0;
}
inline ::osi3::SensorDetectionHeader_ExtendedQualifier SensorDetectionHeader::extended_qualifier() const {
  // @@protoc_insertion_point(field_get:osi3.SensorDetectionHeader.extended_qualifier)
  return static_cast< ::osi3::SensorDetectionHeader_ExtendedQualifier >(extended_qualifier_);
}
inline void SensorDetectionHeader::set_extended_qualifier(::osi3::SensorDetectionHeader_ExtendedQualifier value) {
  
  extended_qualifier_ = value;
  // @@protoc_insertion_point(field_set:osi3.SensorDetectionHeader.extended_qualifier)
}

// -------------------------------------------------------------------

// RadarDetectionData

// .osi3.SensorDetectionHeader header = 1;
inline bool RadarDetectionData::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void RadarDetectionData::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::osi3::SensorDetectionHeader& RadarDetectionData::header() const {
  const ::osi3::SensorDetectionHeader* p = header_;
  // @@protoc_insertion_point(field_get:osi3.RadarDetectionData.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::SensorDetectionHeader*>(
      &::osi3::_SensorDetectionHeader_default_instance_);
}
inline ::osi3::SensorDetectionHeader* RadarDetectionData::release_header() {
  // @@protoc_insertion_point(field_release:osi3.RadarDetectionData.header)
  
  ::osi3::SensorDetectionHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::osi3::SensorDetectionHeader* RadarDetectionData::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::SensorDetectionHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetectionData.header)
  return header_;
}
inline void RadarDetectionData::set_allocated_header(::osi3::SensorDetectionHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:osi3.RadarDetectionData.header)
}

// repeated .osi3.RadarDetection detection = 2;
inline int RadarDetectionData::detection_size() const {
  return detection_.size();
}
inline void RadarDetectionData::clear_detection() {
  detection_.Clear();
}
inline ::osi3::RadarDetection* RadarDetectionData::mutable_detection(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetectionData.detection)
  return detection_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::RadarDetection >*
RadarDetectionData::mutable_detection() {
  // @@protoc_insertion_point(field_mutable_list:osi3.RadarDetectionData.detection)
  return &detection_;
}
inline const ::osi3::RadarDetection& RadarDetectionData::detection(int index) const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetectionData.detection)
  return detection_.Get(index);
}
inline ::osi3::RadarDetection* RadarDetectionData::add_detection() {
  // @@protoc_insertion_point(field_add:osi3.RadarDetectionData.detection)
  return detection_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::RadarDetection >&
RadarDetectionData::detection() const {
  // @@protoc_insertion_point(field_list:osi3.RadarDetectionData.detection)
  return detection_;
}

// -------------------------------------------------------------------

// RadarDetection

// double existence_probability = 1;
inline void RadarDetection::clear_existence_probability() {
  existence_probability_ = 0;
}
inline double RadarDetection::existence_probability() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.existence_probability)
  return existence_probability_;
}
inline void RadarDetection::set_existence_probability(double value) {
  
  existence_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.existence_probability)
}

// .osi3.Identifier object_id = 2;
inline bool RadarDetection::has_object_id() const {
  return this != internal_default_instance() && object_id_ != nullptr;
}
inline const ::osi3::Identifier& RadarDetection::object_id() const {
  const ::osi3::Identifier* p = object_id_;
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.object_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::Identifier*>(
      &::osi3::_Identifier_default_instance_);
}
inline ::osi3::Identifier* RadarDetection::release_object_id() {
  // @@protoc_insertion_point(field_release:osi3.RadarDetection.object_id)
  
  ::osi3::Identifier* temp = object_id_;
  object_id_ = nullptr;
  return temp;
}
inline ::osi3::Identifier* RadarDetection::mutable_object_id() {
  
  if (object_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::Identifier>(GetArenaNoVirtual());
    object_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetection.object_id)
  return object_id_;
}
inline void RadarDetection::set_allocated_object_id(::osi3::Identifier* object_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_id_);
  }
  if (object_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      object_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object_id, submessage_arena);
    }
    
  } else {
    
  }
  object_id_ = object_id;
  // @@protoc_insertion_point(field_set_allocated:osi3.RadarDetection.object_id)
}

// .osi3.Spherical3d position = 3;
inline bool RadarDetection::has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline const ::osi3::Spherical3d& RadarDetection::position() const {
  const ::osi3::Spherical3d* p = position_;
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.position)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::Spherical3d*>(
      &::osi3::_Spherical3d_default_instance_);
}
inline ::osi3::Spherical3d* RadarDetection::release_position() {
  // @@protoc_insertion_point(field_release:osi3.RadarDetection.position)
  
  ::osi3::Spherical3d* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::osi3::Spherical3d* RadarDetection::mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::Spherical3d>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetection.position)
  return position_;
}
inline void RadarDetection::set_allocated_position(::osi3::Spherical3d* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:osi3.RadarDetection.position)
}

// .osi3.Spherical3d position_rmse = 4;
inline bool RadarDetection::has_position_rmse() const {
  return this != internal_default_instance() && position_rmse_ != nullptr;
}
inline const ::osi3::Spherical3d& RadarDetection::position_rmse() const {
  const ::osi3::Spherical3d* p = position_rmse_;
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.position_rmse)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::Spherical3d*>(
      &::osi3::_Spherical3d_default_instance_);
}
inline ::osi3::Spherical3d* RadarDetection::release_position_rmse() {
  // @@protoc_insertion_point(field_release:osi3.RadarDetection.position_rmse)
  
  ::osi3::Spherical3d* temp = position_rmse_;
  position_rmse_ = nullptr;
  return temp;
}
inline ::osi3::Spherical3d* RadarDetection::mutable_position_rmse() {
  
  if (position_rmse_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::Spherical3d>(GetArenaNoVirtual());
    position_rmse_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetection.position_rmse)
  return position_rmse_;
}
inline void RadarDetection::set_allocated_position_rmse(::osi3::Spherical3d* position_rmse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_rmse_);
  }
  if (position_rmse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position_rmse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position_rmse, submessage_arena);
    }
    
  } else {
    
  }
  position_rmse_ = position_rmse;
  // @@protoc_insertion_point(field_set_allocated:osi3.RadarDetection.position_rmse)
}

// double radial_velocity = 5;
inline void RadarDetection::clear_radial_velocity() {
  radial_velocity_ = 0;
}
inline double RadarDetection::radial_velocity() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.radial_velocity)
  return radial_velocity_;
}
inline void RadarDetection::set_radial_velocity(double value) {
  
  radial_velocity_ = value;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.radial_velocity)
}

// double radial_velocity_rmse = 6;
inline void RadarDetection::clear_radial_velocity_rmse() {
  radial_velocity_rmse_ = 0;
}
inline double RadarDetection::radial_velocity_rmse() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.radial_velocity_rmse)
  return radial_velocity_rmse_;
}
inline void RadarDetection::set_radial_velocity_rmse(double value) {
  
  radial_velocity_rmse_ = value;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.radial_velocity_rmse)
}

// double rcs = 7;
inline void RadarDetection::clear_rcs() {
  rcs_ = 0;
}
inline double RadarDetection::rcs() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.rcs)
  return rcs_;
}
inline void RadarDetection::set_rcs(double value) {
  
  rcs_ = value;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.rcs)
}

// double snr = 8;
inline void RadarDetection::clear_snr() {
  snr_ = 0;
}
inline double RadarDetection::snr() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.snr)
  return snr_;
}
inline void RadarDetection::set_snr(double value) {
  
  snr_ = value;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.snr)
}

// double point_target_probability = 9;
inline void RadarDetection::clear_point_target_probability() {
  point_target_probability_ = 0;
}
inline double RadarDetection::point_target_probability() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.point_target_probability)
  return point_target_probability_;
}
inline void RadarDetection::set_point_target_probability(double value) {
  
  point_target_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.point_target_probability)
}

// .osi3.Identifier ambiguity_id = 10;
inline bool RadarDetection::has_ambiguity_id() const {
  return this != internal_default_instance() && ambiguity_id_ != nullptr;
}
inline const ::osi3::Identifier& RadarDetection::ambiguity_id() const {
  const ::osi3::Identifier* p = ambiguity_id_;
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.ambiguity_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::Identifier*>(
      &::osi3::_Identifier_default_instance_);
}
inline ::osi3::Identifier* RadarDetection::release_ambiguity_id() {
  // @@protoc_insertion_point(field_release:osi3.RadarDetection.ambiguity_id)
  
  ::osi3::Identifier* temp = ambiguity_id_;
  ambiguity_id_ = nullptr;
  return temp;
}
inline ::osi3::Identifier* RadarDetection::mutable_ambiguity_id() {
  
  if (ambiguity_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::Identifier>(GetArenaNoVirtual());
    ambiguity_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.RadarDetection.ambiguity_id)
  return ambiguity_id_;
}
inline void RadarDetection::set_allocated_ambiguity_id(::osi3::Identifier* ambiguity_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ambiguity_id_);
  }
  if (ambiguity_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ambiguity_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ambiguity_id, submessage_arena);
    }
    
  } else {
    
  }
  ambiguity_id_ = ambiguity_id;
  // @@protoc_insertion_point(field_set_allocated:osi3.RadarDetection.ambiguity_id)
}

// .osi3.DetectionClassification classification = 11;
inline void RadarDetection::clear_classification() {
  classification_ = 0;
}
inline ::osi3::DetectionClassification RadarDetection::classification() const {
  // @@protoc_insertion_point(field_get:osi3.RadarDetection.classification)
  return static_cast< ::osi3::DetectionClassification >(classification_);
}
inline void RadarDetection::set_classification(::osi3::DetectionClassification value) {
  
  classification_ = value;
  // @@protoc_insertion_point(field_set:osi3.RadarDetection.classification)
}

// -------------------------------------------------------------------

// LidarDetectionData

// .osi3.SensorDetectionHeader header = 1;
inline bool LidarDetectionData::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void LidarDetectionData::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::osi3::SensorDetectionHeader& LidarDetectionData::header() const {
  const ::osi3::SensorDetectionHeader* p = header_;
  // @@protoc_insertion_point(field_get:osi3.LidarDetectionData.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::SensorDetectionHeader*>(
      &::osi3::_SensorDetectionHeader_default_instance_);
}
inline ::osi3::SensorDetectionHeader* LidarDetectionData::release_header() {
  // @@protoc_insertion_point(field_release:osi3.LidarDetectionData.header)
  
  ::osi3::SensorDetectionHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::osi3::SensorDetectionHeader* LidarDetectionData::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::SensorDetectionHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.LidarDetectionData.header)
  return header_;
}
inline void LidarDetectionData::set_allocated_header(::osi3::SensorDetectionHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:osi3.LidarDetectionData.header)
}

// repeated .osi3.LidarDetection detection = 2;
inline int LidarDetectionData::detection_size() const {
  return detection_.size();
}
inline void LidarDetectionData::clear_detection() {
  detection_.Clear();
}
inline ::osi3::LidarDetection* LidarDetectionData::mutable_detection(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.LidarDetectionData.detection)
  return detection_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::LidarDetection >*
LidarDetectionData::mutable_detection() {
  // @@protoc_insertion_point(field_mutable_list:osi3.LidarDetectionData.detection)
  return &detection_;
}
inline const ::osi3::LidarDetection& LidarDetectionData::detection(int index) const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetectionData.detection)
  return detection_.Get(index);
}
inline ::osi3::LidarDetection* LidarDetectionData::add_detection() {
  // @@protoc_insertion_point(field_add:osi3.LidarDetectionData.detection)
  return detection_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::LidarDetection >&
LidarDetectionData::detection() const {
  // @@protoc_insertion_point(field_list:osi3.LidarDetectionData.detection)
  return detection_;
}

// -------------------------------------------------------------------

// LidarDetection

// double existence_probability = 1;
inline void LidarDetection::clear_existence_probability() {
  existence_probability_ = 0;
}
inline double LidarDetection::existence_probability() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.existence_probability)
  return existence_probability_;
}
inline void LidarDetection::set_existence_probability(double value) {
  
  existence_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.existence_probability)
}

// .osi3.Identifier object_id = 2;
inline bool LidarDetection::has_object_id() const {
  return this != internal_default_instance() && object_id_ != nullptr;
}
inline const ::osi3::Identifier& LidarDetection::object_id() const {
  const ::osi3::Identifier* p = object_id_;
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.object_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::Identifier*>(
      &::osi3::_Identifier_default_instance_);
}
inline ::osi3::Identifier* LidarDetection::release_object_id() {
  // @@protoc_insertion_point(field_release:osi3.LidarDetection.object_id)
  
  ::osi3::Identifier* temp = object_id_;
  object_id_ = nullptr;
  return temp;
}
inline ::osi3::Identifier* LidarDetection::mutable_object_id() {
  
  if (object_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::Identifier>(GetArenaNoVirtual());
    object_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.LidarDetection.object_id)
  return object_id_;
}
inline void LidarDetection::set_allocated_object_id(::osi3::Identifier* object_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_id_);
  }
  if (object_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      object_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object_id, submessage_arena);
    }
    
  } else {
    
  }
  object_id_ = object_id;
  // @@protoc_insertion_point(field_set_allocated:osi3.LidarDetection.object_id)
}

// .osi3.Spherical3d position = 3;
inline bool LidarDetection::has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline const ::osi3::Spherical3d& LidarDetection::position() const {
  const ::osi3::Spherical3d* p = position_;
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.position)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::Spherical3d*>(
      &::osi3::_Spherical3d_default_instance_);
}
inline ::osi3::Spherical3d* LidarDetection::release_position() {
  // @@protoc_insertion_point(field_release:osi3.LidarDetection.position)
  
  ::osi3::Spherical3d* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::osi3::Spherical3d* LidarDetection::mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::Spherical3d>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.LidarDetection.position)
  return position_;
}
inline void LidarDetection::set_allocated_position(::osi3::Spherical3d* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:osi3.LidarDetection.position)
}

// .osi3.Spherical3d position_rmse = 4;
inline bool LidarDetection::has_position_rmse() const {
  return this != internal_default_instance() && position_rmse_ != nullptr;
}
inline const ::osi3::Spherical3d& LidarDetection::position_rmse() const {
  const ::osi3::Spherical3d* p = position_rmse_;
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.position_rmse)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::Spherical3d*>(
      &::osi3::_Spherical3d_default_instance_);
}
inline ::osi3::Spherical3d* LidarDetection::release_position_rmse() {
  // @@protoc_insertion_point(field_release:osi3.LidarDetection.position_rmse)
  
  ::osi3::Spherical3d* temp = position_rmse_;
  position_rmse_ = nullptr;
  return temp;
}
inline ::osi3::Spherical3d* LidarDetection::mutable_position_rmse() {
  
  if (position_rmse_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::Spherical3d>(GetArenaNoVirtual());
    position_rmse_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.LidarDetection.position_rmse)
  return position_rmse_;
}
inline void LidarDetection::set_allocated_position_rmse(::osi3::Spherical3d* position_rmse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_rmse_);
  }
  if (position_rmse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position_rmse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position_rmse, submessage_arena);
    }
    
  } else {
    
  }
  position_rmse_ = position_rmse;
  // @@protoc_insertion_point(field_set_allocated:osi3.LidarDetection.position_rmse)
}

// double height = 5;
inline void LidarDetection::clear_height() {
  height_ = 0;
}
inline double LidarDetection::height() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.height)
  return height_;
}
inline void LidarDetection::set_height(double value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.height)
}

// double height_rmse = 6;
inline void LidarDetection::clear_height_rmse() {
  height_rmse_ = 0;
}
inline double LidarDetection::height_rmse() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.height_rmse)
  return height_rmse_;
}
inline void LidarDetection::set_height_rmse(double value) {
  
  height_rmse_ = value;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.height_rmse)
}

// double intensity = 7;
inline void LidarDetection::clear_intensity() {
  intensity_ = 0;
}
inline double LidarDetection::intensity() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.intensity)
  return intensity_;
}
inline void LidarDetection::set_intensity(double value) {
  
  intensity_ = value;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.intensity)
}

// double free_space_probability = 8;
inline void LidarDetection::clear_free_space_probability() {
  free_space_probability_ = 0;
}
inline double LidarDetection::free_space_probability() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.free_space_probability)
  return free_space_probability_;
}
inline void LidarDetection::set_free_space_probability(double value) {
  
  free_space_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.free_space_probability)
}

// .osi3.DetectionClassification classification = 9;
inline void LidarDetection::clear_classification() {
  classification_ = 0;
}
inline ::osi3::DetectionClassification LidarDetection::classification() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.classification)
  return static_cast< ::osi3::DetectionClassification >(classification_);
}
inline void LidarDetection::set_classification(::osi3::DetectionClassification value) {
  
  classification_ = value;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.classification)
}

// double reflectivity = 10;
inline void LidarDetection::clear_reflectivity() {
  reflectivity_ = 0;
}
inline double LidarDetection::reflectivity() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.reflectivity)
  return reflectivity_;
}
inline void LidarDetection::set_reflectivity(double value) {
  
  reflectivity_ = value;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.reflectivity)
}

// double echo_pulse_width = 11;
inline void LidarDetection::clear_echo_pulse_width() {
  echo_pulse_width_ = 0;
}
inline double LidarDetection::echo_pulse_width() const {
  // @@protoc_insertion_point(field_get:osi3.LidarDetection.echo_pulse_width)
  return echo_pulse_width_;
}
inline void LidarDetection::set_echo_pulse_width(double value) {
  
  echo_pulse_width_ = value;
  // @@protoc_insertion_point(field_set:osi3.LidarDetection.echo_pulse_width)
}

// -------------------------------------------------------------------

// UltrasonicDetectionSpecificHeader

// double max_range = 1;
inline void UltrasonicDetectionSpecificHeader::clear_max_range() {
  max_range_ = 0;
}
inline double UltrasonicDetectionSpecificHeader::max_range() const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetectionSpecificHeader.max_range)
  return max_range_;
}
inline void UltrasonicDetectionSpecificHeader::set_max_range(double value) {
  
  max_range_ = value;
  // @@protoc_insertion_point(field_set:osi3.UltrasonicDetectionSpecificHeader.max_range)
}

// uint32 number_of_valid_indirect_detections = 2;
inline void UltrasonicDetectionSpecificHeader::clear_number_of_valid_indirect_detections() {
  number_of_valid_indirect_detections_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UltrasonicDetectionSpecificHeader::number_of_valid_indirect_detections() const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetectionSpecificHeader.number_of_valid_indirect_detections)
  return number_of_valid_indirect_detections_;
}
inline void UltrasonicDetectionSpecificHeader::set_number_of_valid_indirect_detections(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  number_of_valid_indirect_detections_ = value;
  // @@protoc_insertion_point(field_set:osi3.UltrasonicDetectionSpecificHeader.number_of_valid_indirect_detections)
}

// -------------------------------------------------------------------

// UltrasonicDetectionData

// .osi3.SensorDetectionHeader header = 1;
inline bool UltrasonicDetectionData::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void UltrasonicDetectionData::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::osi3::SensorDetectionHeader& UltrasonicDetectionData::header() const {
  const ::osi3::SensorDetectionHeader* p = header_;
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetectionData.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::SensorDetectionHeader*>(
      &::osi3::_SensorDetectionHeader_default_instance_);
}
inline ::osi3::SensorDetectionHeader* UltrasonicDetectionData::release_header() {
  // @@protoc_insertion_point(field_release:osi3.UltrasonicDetectionData.header)
  
  ::osi3::SensorDetectionHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::osi3::SensorDetectionHeader* UltrasonicDetectionData::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::SensorDetectionHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicDetectionData.header)
  return header_;
}
inline void UltrasonicDetectionData::set_allocated_header(::osi3::SensorDetectionHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:osi3.UltrasonicDetectionData.header)
}

// .osi3.UltrasonicDetectionSpecificHeader specific_header = 3;
inline bool UltrasonicDetectionData::has_specific_header() const {
  return this != internal_default_instance() && specific_header_ != nullptr;
}
inline void UltrasonicDetectionData::clear_specific_header() {
  if (GetArenaNoVirtual() == nullptr && specific_header_ != nullptr) {
    delete specific_header_;
  }
  specific_header_ = nullptr;
}
inline const ::osi3::UltrasonicDetectionSpecificHeader& UltrasonicDetectionData::specific_header() const {
  const ::osi3::UltrasonicDetectionSpecificHeader* p = specific_header_;
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetectionData.specific_header)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::UltrasonicDetectionSpecificHeader*>(
      &::osi3::_UltrasonicDetectionSpecificHeader_default_instance_);
}
inline ::osi3::UltrasonicDetectionSpecificHeader* UltrasonicDetectionData::release_specific_header() {
  // @@protoc_insertion_point(field_release:osi3.UltrasonicDetectionData.specific_header)
  
  ::osi3::UltrasonicDetectionSpecificHeader* temp = specific_header_;
  specific_header_ = nullptr;
  return temp;
}
inline ::osi3::UltrasonicDetectionSpecificHeader* UltrasonicDetectionData::mutable_specific_header() {
  
  if (specific_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::UltrasonicDetectionSpecificHeader>(GetArenaNoVirtual());
    specific_header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicDetectionData.specific_header)
  return specific_header_;
}
inline void UltrasonicDetectionData::set_allocated_specific_header(::osi3::UltrasonicDetectionSpecificHeader* specific_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete specific_header_;
  }
  if (specific_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      specific_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, specific_header, submessage_arena);
    }
    
  } else {
    
  }
  specific_header_ = specific_header;
  // @@protoc_insertion_point(field_set_allocated:osi3.UltrasonicDetectionData.specific_header)
}

// repeated .osi3.UltrasonicDetection detection = 2;
inline int UltrasonicDetectionData::detection_size() const {
  return detection_.size();
}
inline void UltrasonicDetectionData::clear_detection() {
  detection_.Clear();
}
inline ::osi3::UltrasonicDetection* UltrasonicDetectionData::mutable_detection(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicDetectionData.detection)
  return detection_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::UltrasonicDetection >*
UltrasonicDetectionData::mutable_detection() {
  // @@protoc_insertion_point(field_mutable_list:osi3.UltrasonicDetectionData.detection)
  return &detection_;
}
inline const ::osi3::UltrasonicDetection& UltrasonicDetectionData::detection(int index) const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetectionData.detection)
  return detection_.Get(index);
}
inline ::osi3::UltrasonicDetection* UltrasonicDetectionData::add_detection() {
  // @@protoc_insertion_point(field_add:osi3.UltrasonicDetectionData.detection)
  return detection_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::UltrasonicDetection >&
UltrasonicDetectionData::detection() const {
  // @@protoc_insertion_point(field_list:osi3.UltrasonicDetectionData.detection)
  return detection_;
}

// repeated .osi3.UltrasonicIndirectDetection indirect_detection = 4;
inline int UltrasonicDetectionData::indirect_detection_size() const {
  return indirect_detection_.size();
}
inline void UltrasonicDetectionData::clear_indirect_detection() {
  indirect_detection_.Clear();
}
inline ::osi3::UltrasonicIndirectDetection* UltrasonicDetectionData::mutable_indirect_detection(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicDetectionData.indirect_detection)
  return indirect_detection_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::UltrasonicIndirectDetection >*
UltrasonicDetectionData::mutable_indirect_detection() {
  // @@protoc_insertion_point(field_mutable_list:osi3.UltrasonicDetectionData.indirect_detection)
  return &indirect_detection_;
}
inline const ::osi3::UltrasonicIndirectDetection& UltrasonicDetectionData::indirect_detection(int index) const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetectionData.indirect_detection)
  return indirect_detection_.Get(index);
}
inline ::osi3::UltrasonicIndirectDetection* UltrasonicDetectionData::add_indirect_detection() {
  // @@protoc_insertion_point(field_add:osi3.UltrasonicDetectionData.indirect_detection)
  return indirect_detection_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::UltrasonicIndirectDetection >&
UltrasonicDetectionData::indirect_detection() const {
  // @@protoc_insertion_point(field_list:osi3.UltrasonicDetectionData.indirect_detection)
  return indirect_detection_;
}

// -------------------------------------------------------------------

// UltrasonicDetection

// double existence_probability = 1;
inline void UltrasonicDetection::clear_existence_probability() {
  existence_probability_ = 0;
}
inline double UltrasonicDetection::existence_probability() const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetection.existence_probability)
  return existence_probability_;
}
inline void UltrasonicDetection::set_existence_probability(double value) {
  
  existence_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.UltrasonicDetection.existence_probability)
}

// .osi3.Identifier object_id = 2;
inline bool UltrasonicDetection::has_object_id() const {
  return this != internal_default_instance() && object_id_ != nullptr;
}
inline const ::osi3::Identifier& UltrasonicDetection::object_id() const {
  const ::osi3::Identifier* p = object_id_;
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetection.object_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::Identifier*>(
      &::osi3::_Identifier_default_instance_);
}
inline ::osi3::Identifier* UltrasonicDetection::release_object_id() {
  // @@protoc_insertion_point(field_release:osi3.UltrasonicDetection.object_id)
  
  ::osi3::Identifier* temp = object_id_;
  object_id_ = nullptr;
  return temp;
}
inline ::osi3::Identifier* UltrasonicDetection::mutable_object_id() {
  
  if (object_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::Identifier>(GetArenaNoVirtual());
    object_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicDetection.object_id)
  return object_id_;
}
inline void UltrasonicDetection::set_allocated_object_id(::osi3::Identifier* object_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_id_);
  }
  if (object_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      object_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object_id, submessage_arena);
    }
    
  } else {
    
  }
  object_id_ = object_id;
  // @@protoc_insertion_point(field_set_allocated:osi3.UltrasonicDetection.object_id)
}

// double distance = 3;
inline void UltrasonicDetection::clear_distance() {
  distance_ = 0;
}
inline double UltrasonicDetection::distance() const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicDetection.distance)
  return distance_;
}
inline void UltrasonicDetection::set_distance(double value) {
  
  distance_ = value;
  // @@protoc_insertion_point(field_set:osi3.UltrasonicDetection.distance)
}

// -------------------------------------------------------------------

// UltrasonicIndirectDetection

// double existence_probability = 1;
inline void UltrasonicIndirectDetection::clear_existence_probability() {
  existence_probability_ = 0;
}
inline double UltrasonicIndirectDetection::existence_probability() const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicIndirectDetection.existence_probability)
  return existence_probability_;
}
inline void UltrasonicIndirectDetection::set_existence_probability(double value) {
  
  existence_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.UltrasonicIndirectDetection.existence_probability)
}

// .osi3.Identifier object_id = 2;
inline bool UltrasonicIndirectDetection::has_object_id() const {
  return this != internal_default_instance() && object_id_ != nullptr;
}
inline const ::osi3::Identifier& UltrasonicIndirectDetection::object_id() const {
  const ::osi3::Identifier* p = object_id_;
  // @@protoc_insertion_point(field_get:osi3.UltrasonicIndirectDetection.object_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::Identifier*>(
      &::osi3::_Identifier_default_instance_);
}
inline ::osi3::Identifier* UltrasonicIndirectDetection::release_object_id() {
  // @@protoc_insertion_point(field_release:osi3.UltrasonicIndirectDetection.object_id)
  
  ::osi3::Identifier* temp = object_id_;
  object_id_ = nullptr;
  return temp;
}
inline ::osi3::Identifier* UltrasonicIndirectDetection::mutable_object_id() {
  
  if (object_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::Identifier>(GetArenaNoVirtual());
    object_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicIndirectDetection.object_id)
  return object_id_;
}
inline void UltrasonicIndirectDetection::set_allocated_object_id(::osi3::Identifier* object_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_id_);
  }
  if (object_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      object_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object_id, submessage_arena);
    }
    
  } else {
    
  }
  object_id_ = object_id;
  // @@protoc_insertion_point(field_set_allocated:osi3.UltrasonicIndirectDetection.object_id)
}

// double ellipsoid_radial = 3;
inline void UltrasonicIndirectDetection::clear_ellipsoid_radial() {
  ellipsoid_radial_ = 0;
}
inline double UltrasonicIndirectDetection::ellipsoid_radial() const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicIndirectDetection.ellipsoid_radial)
  return ellipsoid_radial_;
}
inline void UltrasonicIndirectDetection::set_ellipsoid_radial(double value) {
  
  ellipsoid_radial_ = value;
  // @@protoc_insertion_point(field_set:osi3.UltrasonicIndirectDetection.ellipsoid_radial)
}

// double ellipsoid_axial = 4;
inline void UltrasonicIndirectDetection::clear_ellipsoid_axial() {
  ellipsoid_axial_ = 0;
}
inline double UltrasonicIndirectDetection::ellipsoid_axial() const {
  // @@protoc_insertion_point(field_get:osi3.UltrasonicIndirectDetection.ellipsoid_axial)
  return ellipsoid_axial_;
}
inline void UltrasonicIndirectDetection::set_ellipsoid_axial(double value) {
  
  ellipsoid_axial_ = value;
  // @@protoc_insertion_point(field_set:osi3.UltrasonicIndirectDetection.ellipsoid_axial)
}

// .osi3.Identifier receiver_id = 5;
inline bool UltrasonicIndirectDetection::has_receiver_id() const {
  return this != internal_default_instance() && receiver_id_ != nullptr;
}
inline const ::osi3::Identifier& UltrasonicIndirectDetection::receiver_id() const {
  const ::osi3::Identifier* p = receiver_id_;
  // @@protoc_insertion_point(field_get:osi3.UltrasonicIndirectDetection.receiver_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::Identifier*>(
      &::osi3::_Identifier_default_instance_);
}
inline ::osi3::Identifier* UltrasonicIndirectDetection::release_receiver_id() {
  // @@protoc_insertion_point(field_release:osi3.UltrasonicIndirectDetection.receiver_id)
  
  ::osi3::Identifier* temp = receiver_id_;
  receiver_id_ = nullptr;
  return temp;
}
inline ::osi3::Identifier* UltrasonicIndirectDetection::mutable_receiver_id() {
  
  if (receiver_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::Identifier>(GetArenaNoVirtual());
    receiver_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicIndirectDetection.receiver_id)
  return receiver_id_;
}
inline void UltrasonicIndirectDetection::set_allocated_receiver_id(::osi3::Identifier* receiver_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(receiver_id_);
  }
  if (receiver_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      receiver_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, receiver_id, submessage_arena);
    }
    
  } else {
    
  }
  receiver_id_ = receiver_id;
  // @@protoc_insertion_point(field_set_allocated:osi3.UltrasonicIndirectDetection.receiver_id)
}

// .osi3.Vector3d receiver_origin = 6;
inline bool UltrasonicIndirectDetection::has_receiver_origin() const {
  return this != internal_default_instance() && receiver_origin_ != nullptr;
}
inline const ::osi3::Vector3d& UltrasonicIndirectDetection::receiver_origin() const {
  const ::osi3::Vector3d* p = receiver_origin_;
  // @@protoc_insertion_point(field_get:osi3.UltrasonicIndirectDetection.receiver_origin)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::Vector3d*>(
      &::osi3::_Vector3d_default_instance_);
}
inline ::osi3::Vector3d* UltrasonicIndirectDetection::release_receiver_origin() {
  // @@protoc_insertion_point(field_release:osi3.UltrasonicIndirectDetection.receiver_origin)
  
  ::osi3::Vector3d* temp = receiver_origin_;
  receiver_origin_ = nullptr;
  return temp;
}
inline ::osi3::Vector3d* UltrasonicIndirectDetection::mutable_receiver_origin() {
  
  if (receiver_origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::Vector3d>(GetArenaNoVirtual());
    receiver_origin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.UltrasonicIndirectDetection.receiver_origin)
  return receiver_origin_;
}
inline void UltrasonicIndirectDetection::set_allocated_receiver_origin(::osi3::Vector3d* receiver_origin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(receiver_origin_);
  }
  if (receiver_origin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      receiver_origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, receiver_origin, submessage_arena);
    }
    
  } else {
    
  }
  receiver_origin_ = receiver_origin;
  // @@protoc_insertion_point(field_set_allocated:osi3.UltrasonicIndirectDetection.receiver_origin)
}

// -------------------------------------------------------------------

// CameraDetectionSpecificHeader

// uint32 number_of_valid_points = 1;
inline void CameraDetectionSpecificHeader::clear_number_of_valid_points() {
  number_of_valid_points_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CameraDetectionSpecificHeader::number_of_valid_points() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetectionSpecificHeader.number_of_valid_points)
  return number_of_valid_points_;
}
inline void CameraDetectionSpecificHeader::set_number_of_valid_points(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  number_of_valid_points_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetectionSpecificHeader.number_of_valid_points)
}

// -------------------------------------------------------------------

// CameraDetectionData

// .osi3.SensorDetectionHeader header = 1;
inline bool CameraDetectionData::has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline void CameraDetectionData::clear_header() {
  if (GetArenaNoVirtual() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::osi3::SensorDetectionHeader& CameraDetectionData::header() const {
  const ::osi3::SensorDetectionHeader* p = header_;
  // @@protoc_insertion_point(field_get:osi3.CameraDetectionData.header)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::SensorDetectionHeader*>(
      &::osi3::_SensorDetectionHeader_default_instance_);
}
inline ::osi3::SensorDetectionHeader* CameraDetectionData::release_header() {
  // @@protoc_insertion_point(field_release:osi3.CameraDetectionData.header)
  
  ::osi3::SensorDetectionHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::osi3::SensorDetectionHeader* CameraDetectionData::mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::SensorDetectionHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetectionData.header)
  return header_;
}
inline void CameraDetectionData::set_allocated_header(::osi3::SensorDetectionHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraDetectionData.header)
}

// .osi3.CameraDetectionSpecificHeader specific_header = 3;
inline bool CameraDetectionData::has_specific_header() const {
  return this != internal_default_instance() && specific_header_ != nullptr;
}
inline void CameraDetectionData::clear_specific_header() {
  if (GetArenaNoVirtual() == nullptr && specific_header_ != nullptr) {
    delete specific_header_;
  }
  specific_header_ = nullptr;
}
inline const ::osi3::CameraDetectionSpecificHeader& CameraDetectionData::specific_header() const {
  const ::osi3::CameraDetectionSpecificHeader* p = specific_header_;
  // @@protoc_insertion_point(field_get:osi3.CameraDetectionData.specific_header)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::CameraDetectionSpecificHeader*>(
      &::osi3::_CameraDetectionSpecificHeader_default_instance_);
}
inline ::osi3::CameraDetectionSpecificHeader* CameraDetectionData::release_specific_header() {
  // @@protoc_insertion_point(field_release:osi3.CameraDetectionData.specific_header)
  
  ::osi3::CameraDetectionSpecificHeader* temp = specific_header_;
  specific_header_ = nullptr;
  return temp;
}
inline ::osi3::CameraDetectionSpecificHeader* CameraDetectionData::mutable_specific_header() {
  
  if (specific_header_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::CameraDetectionSpecificHeader>(GetArenaNoVirtual());
    specific_header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetectionData.specific_header)
  return specific_header_;
}
inline void CameraDetectionData::set_allocated_specific_header(::osi3::CameraDetectionSpecificHeader* specific_header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete specific_header_;
  }
  if (specific_header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      specific_header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, specific_header, submessage_arena);
    }
    
  } else {
    
  }
  specific_header_ = specific_header;
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraDetectionData.specific_header)
}

// repeated .osi3.CameraDetection detection = 2;
inline int CameraDetectionData::detection_size() const {
  return detection_.size();
}
inline void CameraDetectionData::clear_detection() {
  detection_.Clear();
}
inline ::osi3::CameraDetection* CameraDetectionData::mutable_detection(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetectionData.detection)
  return detection_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::CameraDetection >*
CameraDetectionData::mutable_detection() {
  // @@protoc_insertion_point(field_mutable_list:osi3.CameraDetectionData.detection)
  return &detection_;
}
inline const ::osi3::CameraDetection& CameraDetectionData::detection(int index) const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetectionData.detection)
  return detection_.Get(index);
}
inline ::osi3::CameraDetection* CameraDetectionData::add_detection() {
  // @@protoc_insertion_point(field_add:osi3.CameraDetectionData.detection)
  return detection_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::CameraDetection >&
CameraDetectionData::detection() const {
  // @@protoc_insertion_point(field_list:osi3.CameraDetectionData.detection)
  return detection_;
}

// repeated .osi3.CameraPoint point = 4;
inline int CameraDetectionData::point_size() const {
  return point_.size();
}
inline void CameraDetectionData::clear_point() {
  point_.Clear();
}
inline ::osi3::CameraPoint* CameraDetectionData::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetectionData.point)
  return point_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::CameraPoint >*
CameraDetectionData::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:osi3.CameraDetectionData.point)
  return &point_;
}
inline const ::osi3::CameraPoint& CameraDetectionData::point(int index) const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetectionData.point)
  return point_.Get(index);
}
inline ::osi3::CameraPoint* CameraDetectionData::add_point() {
  // @@protoc_insertion_point(field_add:osi3.CameraDetectionData.point)
  return point_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::osi3::CameraPoint >&
CameraDetectionData::point() const {
  // @@protoc_insertion_point(field_list:osi3.CameraDetectionData.point)
  return point_;
}

// -------------------------------------------------------------------

// CameraDetection

// double existence_probability = 1;
inline void CameraDetection::clear_existence_probability() {
  existence_probability_ = 0;
}
inline double CameraDetection::existence_probability() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.existence_probability)
  return existence_probability_;
}
inline void CameraDetection::set_existence_probability(double value) {
  
  existence_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.existence_probability)
}

// .osi3.Identifier object_id = 2;
inline bool CameraDetection::has_object_id() const {
  return this != internal_default_instance() && object_id_ != nullptr;
}
inline const ::osi3::Identifier& CameraDetection::object_id() const {
  const ::osi3::Identifier* p = object_id_;
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.object_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::Identifier*>(
      &::osi3::_Identifier_default_instance_);
}
inline ::osi3::Identifier* CameraDetection::release_object_id() {
  // @@protoc_insertion_point(field_release:osi3.CameraDetection.object_id)
  
  ::osi3::Identifier* temp = object_id_;
  object_id_ = nullptr;
  return temp;
}
inline ::osi3::Identifier* CameraDetection::mutable_object_id() {
  
  if (object_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::Identifier>(GetArenaNoVirtual());
    object_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetection.object_id)
  return object_id_;
}
inline void CameraDetection::set_allocated_object_id(::osi3::Identifier* object_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(object_id_);
  }
  if (object_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      object_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object_id, submessage_arena);
    }
    
  } else {
    
  }
  object_id_ = object_id;
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraDetection.object_id)
}

// .osi3.Timestamp time_difference = 3;
inline bool CameraDetection::has_time_difference() const {
  return this != internal_default_instance() && time_difference_ != nullptr;
}
inline const ::osi3::Timestamp& CameraDetection::time_difference() const {
  const ::osi3::Timestamp* p = time_difference_;
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.time_difference)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::Timestamp*>(
      &::osi3::_Timestamp_default_instance_);
}
inline ::osi3::Timestamp* CameraDetection::release_time_difference() {
  // @@protoc_insertion_point(field_release:osi3.CameraDetection.time_difference)
  
  ::osi3::Timestamp* temp = time_difference_;
  time_difference_ = nullptr;
  return temp;
}
inline ::osi3::Timestamp* CameraDetection::mutable_time_difference() {
  
  if (time_difference_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::Timestamp>(GetArenaNoVirtual());
    time_difference_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetection.time_difference)
  return time_difference_;
}
inline void CameraDetection::set_allocated_time_difference(::osi3::Timestamp* time_difference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_difference_);
  }
  if (time_difference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      time_difference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_difference, submessage_arena);
    }
    
  } else {
    
  }
  time_difference_ = time_difference;
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraDetection.time_difference)
}

// .osi3.CameraDetection.ImageShapeType image_shape_type = 4;
inline void CameraDetection::clear_image_shape_type() {
  image_shape_type_ = 0;
}
inline ::osi3::CameraDetection_ImageShapeType CameraDetection::image_shape_type() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.image_shape_type)
  return static_cast< ::osi3::CameraDetection_ImageShapeType >(image_shape_type_);
}
inline void CameraDetection::set_image_shape_type(::osi3::CameraDetection_ImageShapeType value) {
  
  image_shape_type_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.image_shape_type)
}

// bool shape_classification_background = 5;
inline void CameraDetection::clear_shape_classification_background() {
  shape_classification_background_ = false;
}
inline bool CameraDetection::shape_classification_background() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_background)
  return shape_classification_background_;
}
inline void CameraDetection::set_shape_classification_background(bool value) {
  
  shape_classification_background_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_background)
}

// bool shape_classification_foreground = 6;
inline void CameraDetection::clear_shape_classification_foreground() {
  shape_classification_foreground_ = false;
}
inline bool CameraDetection::shape_classification_foreground() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_foreground)
  return shape_classification_foreground_;
}
inline void CameraDetection::set_shape_classification_foreground(bool value) {
  
  shape_classification_foreground_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_foreground)
}

// bool shape_classification_flat = 7;
inline void CameraDetection::clear_shape_classification_flat() {
  shape_classification_flat_ = false;
}
inline bool CameraDetection::shape_classification_flat() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_flat)
  return shape_classification_flat_;
}
inline void CameraDetection::set_shape_classification_flat(bool value) {
  
  shape_classification_flat_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_flat)
}

// bool shape_classification_upright = 8;
inline void CameraDetection::clear_shape_classification_upright() {
  shape_classification_upright_ = false;
}
inline bool CameraDetection::shape_classification_upright() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_upright)
  return shape_classification_upright_;
}
inline void CameraDetection::set_shape_classification_upright(bool value) {
  
  shape_classification_upright_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_upright)
}

// bool shape_classification_ground = 9;
inline void CameraDetection::clear_shape_classification_ground() {
  shape_classification_ground_ = false;
}
inline bool CameraDetection::shape_classification_ground() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_ground)
  return shape_classification_ground_;
}
inline void CameraDetection::set_shape_classification_ground(bool value) {
  
  shape_classification_ground_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_ground)
}

// bool shape_classification_sky = 10;
inline void CameraDetection::clear_shape_classification_sky() {
  shape_classification_sky_ = false;
}
inline bool CameraDetection::shape_classification_sky() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_sky)
  return shape_classification_sky_;
}
inline void CameraDetection::set_shape_classification_sky(bool value) {
  
  shape_classification_sky_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_sky)
}

// bool shape_classification_vegetation = 11;
inline void CameraDetection::clear_shape_classification_vegetation() {
  shape_classification_vegetation_ = false;
}
inline bool CameraDetection::shape_classification_vegetation() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_vegetation)
  return shape_classification_vegetation_;
}
inline void CameraDetection::set_shape_classification_vegetation(bool value) {
  
  shape_classification_vegetation_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_vegetation)
}

// bool shape_classification_road = 12;
inline void CameraDetection::clear_shape_classification_road() {
  shape_classification_road_ = false;
}
inline bool CameraDetection::shape_classification_road() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_road)
  return shape_classification_road_;
}
inline void CameraDetection::set_shape_classification_road(bool value) {
  
  shape_classification_road_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_road)
}

// bool shape_classification_non_driving_lane = 13;
inline void CameraDetection::clear_shape_classification_non_driving_lane() {
  shape_classification_non_driving_lane_ = false;
}
inline bool CameraDetection::shape_classification_non_driving_lane() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_non_driving_lane)
  return shape_classification_non_driving_lane_;
}
inline void CameraDetection::set_shape_classification_non_driving_lane(bool value) {
  
  shape_classification_non_driving_lane_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_non_driving_lane)
}

// bool shape_classification_non_road = 14;
inline void CameraDetection::clear_shape_classification_non_road() {
  shape_classification_non_road_ = false;
}
inline bool CameraDetection::shape_classification_non_road() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_non_road)
  return shape_classification_non_road_;
}
inline void CameraDetection::set_shape_classification_non_road(bool value) {
  
  shape_classification_non_road_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_non_road)
}

// bool shape_classification_stationary_object = 15;
inline void CameraDetection::clear_shape_classification_stationary_object() {
  shape_classification_stationary_object_ = false;
}
inline bool CameraDetection::shape_classification_stationary_object() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_stationary_object)
  return shape_classification_stationary_object_;
}
inline void CameraDetection::set_shape_classification_stationary_object(bool value) {
  
  shape_classification_stationary_object_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_stationary_object)
}

// bool shape_classification_moving_object = 16;
inline void CameraDetection::clear_shape_classification_moving_object() {
  shape_classification_moving_object_ = false;
}
inline bool CameraDetection::shape_classification_moving_object() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_moving_object)
  return shape_classification_moving_object_;
}
inline void CameraDetection::set_shape_classification_moving_object(bool value) {
  
  shape_classification_moving_object_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_moving_object)
}

// bool shape_classification_landmark = 17;
inline void CameraDetection::clear_shape_classification_landmark() {
  shape_classification_landmark_ = false;
}
inline bool CameraDetection::shape_classification_landmark() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_landmark)
  return shape_classification_landmark_;
}
inline void CameraDetection::set_shape_classification_landmark(bool value) {
  
  shape_classification_landmark_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_landmark)
}

// bool shape_classification_traffic_sign = 18;
inline void CameraDetection::clear_shape_classification_traffic_sign() {
  shape_classification_traffic_sign_ = false;
}
inline bool CameraDetection::shape_classification_traffic_sign() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_traffic_sign)
  return shape_classification_traffic_sign_;
}
inline void CameraDetection::set_shape_classification_traffic_sign(bool value) {
  
  shape_classification_traffic_sign_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_traffic_sign)
}

// bool shape_classification_traffic_light = 19;
inline void CameraDetection::clear_shape_classification_traffic_light() {
  shape_classification_traffic_light_ = false;
}
inline bool CameraDetection::shape_classification_traffic_light() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_traffic_light)
  return shape_classification_traffic_light_;
}
inline void CameraDetection::set_shape_classification_traffic_light(bool value) {
  
  shape_classification_traffic_light_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_traffic_light)
}

// bool shape_classification_road_marking = 20;
inline void CameraDetection::clear_shape_classification_road_marking() {
  shape_classification_road_marking_ = false;
}
inline bool CameraDetection::shape_classification_road_marking() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_road_marking)
  return shape_classification_road_marking_;
}
inline void CameraDetection::set_shape_classification_road_marking(bool value) {
  
  shape_classification_road_marking_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_road_marking)
}

// bool shape_classification_vehicle = 21;
inline void CameraDetection::clear_shape_classification_vehicle() {
  shape_classification_vehicle_ = false;
}
inline bool CameraDetection::shape_classification_vehicle() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_vehicle)
  return shape_classification_vehicle_;
}
inline void CameraDetection::set_shape_classification_vehicle(bool value) {
  
  shape_classification_vehicle_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_vehicle)
}

// bool shape_classification_pedestrian = 22;
inline void CameraDetection::clear_shape_classification_pedestrian() {
  shape_classification_pedestrian_ = false;
}
inline bool CameraDetection::shape_classification_pedestrian() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_pedestrian)
  return shape_classification_pedestrian_;
}
inline void CameraDetection::set_shape_classification_pedestrian(bool value) {
  
  shape_classification_pedestrian_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_pedestrian)
}

// bool shape_classification_animal = 23;
inline void CameraDetection::clear_shape_classification_animal() {
  shape_classification_animal_ = false;
}
inline bool CameraDetection::shape_classification_animal() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_animal)
  return shape_classification_animal_;
}
inline void CameraDetection::set_shape_classification_animal(bool value) {
  
  shape_classification_animal_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_animal)
}

// bool shape_classification_pedestrian_front = 24;
inline void CameraDetection::clear_shape_classification_pedestrian_front() {
  shape_classification_pedestrian_front_ = false;
}
inline bool CameraDetection::shape_classification_pedestrian_front() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_pedestrian_front)
  return shape_classification_pedestrian_front_;
}
inline void CameraDetection::set_shape_classification_pedestrian_front(bool value) {
  
  shape_classification_pedestrian_front_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_pedestrian_front)
}

// bool shape_classification_pedestrian_side = 25;
inline void CameraDetection::clear_shape_classification_pedestrian_side() {
  shape_classification_pedestrian_side_ = false;
}
inline bool CameraDetection::shape_classification_pedestrian_side() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_pedestrian_side)
  return shape_classification_pedestrian_side_;
}
inline void CameraDetection::set_shape_classification_pedestrian_side(bool value) {
  
  shape_classification_pedestrian_side_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_pedestrian_side)
}

// bool shape_classification_pedestrian_rear = 26;
inline void CameraDetection::clear_shape_classification_pedestrian_rear() {
  shape_classification_pedestrian_rear_ = false;
}
inline bool CameraDetection::shape_classification_pedestrian_rear() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_pedestrian_rear)
  return shape_classification_pedestrian_rear_;
}
inline void CameraDetection::set_shape_classification_pedestrian_rear(bool value) {
  
  shape_classification_pedestrian_rear_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_pedestrian_rear)
}

// double shape_classification_probability = 27;
inline void CameraDetection::clear_shape_classification_probability() {
  shape_classification_probability_ = 0;
}
inline double CameraDetection::shape_classification_probability() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.shape_classification_probability)
  return shape_classification_probability_;
}
inline void CameraDetection::set_shape_classification_probability(double value) {
  
  shape_classification_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.shape_classification_probability)
}

// .osi3.CameraDetection.Color color = 28;
inline void CameraDetection::clear_color() {
  color_ = 0;
}
inline ::osi3::CameraDetection_Color CameraDetection::color() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.color)
  return static_cast< ::osi3::CameraDetection_Color >(color_);
}
inline void CameraDetection::set_color(::osi3::CameraDetection_Color value) {
  
  color_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.color)
}

// double color_probability = 29;
inline void CameraDetection::clear_color_probability() {
  color_probability_ = 0;
}
inline double CameraDetection::color_probability() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.color_probability)
  return color_probability_;
}
inline void CameraDetection::set_color_probability(double value) {
  
  color_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.color_probability)
}

// .osi3.Identifier ambiguity_id = 30;
inline bool CameraDetection::has_ambiguity_id() const {
  return this != internal_default_instance() && ambiguity_id_ != nullptr;
}
inline const ::osi3::Identifier& CameraDetection::ambiguity_id() const {
  const ::osi3::Identifier* p = ambiguity_id_;
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.ambiguity_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::Identifier*>(
      &::osi3::_Identifier_default_instance_);
}
inline ::osi3::Identifier* CameraDetection::release_ambiguity_id() {
  // @@protoc_insertion_point(field_release:osi3.CameraDetection.ambiguity_id)
  
  ::osi3::Identifier* temp = ambiguity_id_;
  ambiguity_id_ = nullptr;
  return temp;
}
inline ::osi3::Identifier* CameraDetection::mutable_ambiguity_id() {
  
  if (ambiguity_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::Identifier>(GetArenaNoVirtual());
    ambiguity_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetection.ambiguity_id)
  return ambiguity_id_;
}
inline void CameraDetection::set_allocated_ambiguity_id(::osi3::Identifier* ambiguity_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ambiguity_id_);
  }
  if (ambiguity_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ambiguity_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ambiguity_id, submessage_arena);
    }
    
  } else {
    
  }
  ambiguity_id_ = ambiguity_id;
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraDetection.ambiguity_id)
}

// uint32 first_point_index = 31;
inline void CameraDetection::clear_first_point_index() {
  first_point_index_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CameraDetection::first_point_index() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.first_point_index)
  return first_point_index_;
}
inline void CameraDetection::set_first_point_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  first_point_index_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.first_point_index)
}

// uint32 number_of_points = 32;
inline void CameraDetection::clear_number_of_points() {
  number_of_points_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CameraDetection::number_of_points() const {
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.number_of_points)
  return number_of_points_;
}
inline void CameraDetection::set_number_of_points(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  number_of_points_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraDetection.number_of_points)
}

// .osi3.ColorDescription color_description = 33;
inline bool CameraDetection::has_color_description() const {
  return this != internal_default_instance() && color_description_ != nullptr;
}
inline const ::osi3::ColorDescription& CameraDetection::color_description() const {
  const ::osi3::ColorDescription* p = color_description_;
  // @@protoc_insertion_point(field_get:osi3.CameraDetection.color_description)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::ColorDescription*>(
      &::osi3::_ColorDescription_default_instance_);
}
inline ::osi3::ColorDescription* CameraDetection::release_color_description() {
  // @@protoc_insertion_point(field_release:osi3.CameraDetection.color_description)
  
  ::osi3::ColorDescription* temp = color_description_;
  color_description_ = nullptr;
  return temp;
}
inline ::osi3::ColorDescription* CameraDetection::mutable_color_description() {
  
  if (color_description_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::ColorDescription>(GetArenaNoVirtual());
    color_description_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.CameraDetection.color_description)
  return color_description_;
}
inline void CameraDetection::set_allocated_color_description(::osi3::ColorDescription* color_description) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_description_);
  }
  if (color_description) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      color_description = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color_description, submessage_arena);
    }
    
  } else {
    
  }
  color_description_ = color_description;
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraDetection.color_description)
}

// -------------------------------------------------------------------

// CameraPoint

// double existence_probability = 1;
inline void CameraPoint::clear_existence_probability() {
  existence_probability_ = 0;
}
inline double CameraPoint::existence_probability() const {
  // @@protoc_insertion_point(field_get:osi3.CameraPoint.existence_probability)
  return existence_probability_;
}
inline void CameraPoint::set_existence_probability(double value) {
  
  existence_probability_ = value;
  // @@protoc_insertion_point(field_set:osi3.CameraPoint.existence_probability)
}

// .osi3.Spherical3d point = 2;
inline bool CameraPoint::has_point() const {
  return this != internal_default_instance() && point_ != nullptr;
}
inline const ::osi3::Spherical3d& CameraPoint::point() const {
  const ::osi3::Spherical3d* p = point_;
  // @@protoc_insertion_point(field_get:osi3.CameraPoint.point)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::Spherical3d*>(
      &::osi3::_Spherical3d_default_instance_);
}
inline ::osi3::Spherical3d* CameraPoint::release_point() {
  // @@protoc_insertion_point(field_release:osi3.CameraPoint.point)
  
  ::osi3::Spherical3d* temp = point_;
  point_ = nullptr;
  return temp;
}
inline ::osi3::Spherical3d* CameraPoint::mutable_point() {
  
  if (point_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::Spherical3d>(GetArenaNoVirtual());
    point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.CameraPoint.point)
  return point_;
}
inline void CameraPoint::set_allocated_point(::osi3::Spherical3d* point) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_);
  }
  if (point) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      point = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point, submessage_arena);
    }
    
  } else {
    
  }
  point_ = point;
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraPoint.point)
}

// .osi3.Spherical3d point_rmse = 3;
inline bool CameraPoint::has_point_rmse() const {
  return this != internal_default_instance() && point_rmse_ != nullptr;
}
inline const ::osi3::Spherical3d& CameraPoint::point_rmse() const {
  const ::osi3::Spherical3d* p = point_rmse_;
  // @@protoc_insertion_point(field_get:osi3.CameraPoint.point_rmse)
  return p != nullptr ? *p : *reinterpret_cast<const ::osi3::Spherical3d*>(
      &::osi3::_Spherical3d_default_instance_);
}
inline ::osi3::Spherical3d* CameraPoint::release_point_rmse() {
  // @@protoc_insertion_point(field_release:osi3.CameraPoint.point_rmse)
  
  ::osi3::Spherical3d* temp = point_rmse_;
  point_rmse_ = nullptr;
  return temp;
}
inline ::osi3::Spherical3d* CameraPoint::mutable_point_rmse() {
  
  if (point_rmse_ == nullptr) {
    auto* p = CreateMaybeMessage<::osi3::Spherical3d>(GetArenaNoVirtual());
    point_rmse_ = p;
  }
  // @@protoc_insertion_point(field_mutable:osi3.CameraPoint.point_rmse)
  return point_rmse_;
}
inline void CameraPoint::set_allocated_point_rmse(::osi3::Spherical3d* point_rmse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_rmse_);
  }
  if (point_rmse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      point_rmse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point_rmse, submessage_arena);
    }
    
  } else {
    
  }
  point_rmse_ = point_rmse;
  // @@protoc_insertion_point(field_set_allocated:osi3.CameraPoint.point_rmse)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace osi3

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::osi3::SensorDetectionHeader_DataQualifier> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::osi3::SensorDetectionHeader_DataQualifier>() {
  return ::osi3::SensorDetectionHeader_DataQualifier_descriptor();
}
template <> struct is_proto_enum< ::osi3::SensorDetectionHeader_ExtendedQualifier> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::osi3::SensorDetectionHeader_ExtendedQualifier>() {
  return ::osi3::SensorDetectionHeader_ExtendedQualifier_descriptor();
}
template <> struct is_proto_enum< ::osi3::CameraDetection_Color> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::osi3::CameraDetection_Color>() {
  return ::osi3::CameraDetection_Color_descriptor();
}
template <> struct is_proto_enum< ::osi3::CameraDetection_ImageShapeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::osi3::CameraDetection_ImageShapeType>() {
  return ::osi3::CameraDetection_ImageShapeType_descriptor();
}
template <> struct is_proto_enum< ::osi3::DetectionClassification> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::osi3::DetectionClassification>() {
  return ::osi3::DetectionClassification_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_osi_5ffeaturedata_2eproto
